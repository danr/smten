
Sat Mar 24 08:21:35 EDT 2012

I want to give seri another shot, for the fun of it. But also as something
potentially useful. It's strange how I keep going around in full circles, and
I did a full circle away from seri and now back again.

But let me see if I can't make it rather cleaner this time around.

What's the goal?

We want the following:

- An intermediate representation for describing seri programs.
This will consist of expressions, types, perhaps modules.
My vision is to have an IR which is described in such a way that you can pick
and choose just the pieces you want to use, and it's extensible, so you can
add in things for where you want to use it. So it's not specific to my
language, but should, for example, work for a lambda calculus that Nirav wants
for SMT, work for BCL, for Structural Spec, and all seri all at once, but in a
clean way.

- C code generation of IR.
To separate things out, have a C IR for describing a C program in haskell. Or
C++ or both or something like that. Then have conversion from the seri IR to
that C ir, and have that C ir support pretty printing.

- BSV code generation of IR.
Analogous to the C code generation: we have a BSV IR we can translate to, then
pretty print to get working bluespec.

- Haskell code generation of IR.
Just convert to haskell's existing IR, and pretty print that.

- Haskell Interpreter for IR.
Aka: Static elaborator of IR.

- Clean front end.
This could be hard. What I want is this: I want to be able to describe
programs in haskell, using the full generality and abstractions haskell
provides. I want to generate from them a monomorphic, simple seri IR.

This might involve having a parser, or some translation to/from template
haskell. Important things: we want to leverage the abstractions of haskell. We
want to pass meaningful names into the IR from the front end. We want to have
types checked properly. It should not be messy yucky to write.


I think, perhaps, the first step would be to come up with a simple lambda IR.
Have booleans and integers and tuples, or whatever seri has.

Start writing the C or C++ and BSV IRs (which are completely separate modules
which can be reused elsewhere, which is really nice).

Once I have that baseline, then play with it to try and find good ways of
making the IR extensible and making the front end nice the way I really want
it to be.

Cool. This sounds like fun. Let me get started after breakfast.

Sat Mar 24 08:46:22 EDT 2012

First step: define my base language. My simple ir.

Types:
  Unit, Integer, Bool, Tuple, Function

Expressions:
  Unit, Integer, Boolean, Tuple,
  Add, Mul, Sub, Eq, Lt, If, Fst, Snd
  App, Lam, Fix

I'm not sure I like using Fix for recursive functions, but I can fix that
later. This will be enough of a start for factorial.

Sat Mar 24 08:57:49 EDT 2012

Okay, so I've defined my language.

The next thing to do is write a simple program in it.

Let's not start with a recursive program just yet.
In fact, let me get rid of Fix, because I don't want to start with a recursive
program.

First expression...

(\x -> x*x + 3*x + 2) 5

Sat Mar 24 09:26:00 EDT 2012

Nifty! It works.

What's the next step, do you think?

I think it would be nice to pretty print the expression. This is different
from Show.

Let me do that, then brainstorm what the next steps should be. I think it
probably makes sense to try and get all the parts of my goal in a nice way for
the simplest version of the IR, so I'm not rewriting so much code as I try
different things.

So, perhaps the first thing to get done are the basics:

+ pretty print seri
+ generate C from seri
x generate BSV from seri
+ generate Haskell from seri
- have a nice front end
- make seri extensible

The last two points will be hard, but very important. They are really the meat
of what I want to do. So work on them, see what I can come up with. Add more
to seri if I need to demonstrate the issues I'm worried about. And so on.

Okay, cool. I have something to work on now.

Sat Mar 24 10:14:10 EDT 2012

I did the printing. It works fine, it's just riddled with parentheses I'd like
to get rid of if I could.

The question is, what precedence do I want?

(\x -> x*x + 3*x + 2) 5

lam, +, *, app


Sat Mar 24 10:22:57 EDT 2012

Okay, That works well enough.

Next step?

Convert to haskell... done.

Next?

I think, either C or BSV back end?

The concern is how to do anonymous functions in those.
Perhaps, instead, I have to give each anonymous function a name?

Let me do a simple C ir. Just enough of what I need. Just to have something
more than haskell, something where types aren't inferred automatically. No
need to support bsv yet.

What do I need for C?

(\x = x*x + 3*x + 2) 5

Should become something like:

int l1(int x)
{
    return x*x + 3*x + 2;
}

l1(5)

So...

Dec = FunD Name [(Type Name)] Type [Stmt]
Stmt = ReturnS Exp
Exp = Int | Mul | Add

Let me stick to C for now. I don't anticipate needing C++ for my explorations.
    
Okay, last thing I need before playing with front end: the C code generation.

I'll want to use a monad, because an expression could return a bunch of
declarations as well.

Okay, good. That works.

Next step: a nice front end.

Sat Mar 24 11:21:46 EDT 2012

This part is going to take some thought, and experiment.

What are my requirements?

A. Assume user knows haskell
B. Haskell code should be easily incorporated into front end code for static
  elaboration.
C. Names used in front end should be preserved in the ir
D. It should be nice to write programs.
For example: writing in the IR is NOT nice. We want to use syntax.
E. Type checking must be done somewhere.
F. ? Error messages should be interpretable

Let's walk through some possible ideas, and evaluate them under the above
requirements.

Write in IR directly
--------------------
This is what I've been testing so far.
B. Good. We can easily generate code from haskell.
C. Good. Because the names are one and the same.
D. Terrible. Horrific.
E. We could add a step to check your types are consistent fairly easily,
right? A simple type check (not type inference).
F. We wouldn't have line numbers for type errors. Haskell will catch other
errors in its type system just fine.

Write a parser for the IR
-------------------------
B. Not good initially. Perhaps some extra work could let you inline haskell
fairly easily. This is worth looking into.
C. Good. Names transfer easily.
D. Good. We get just the syntax we want.
E. Don't know. How hard would type inference be? Perhaps we could require type
annotations? But that would make it more annoying to write programs in.
F. We could pass through line numbers, so this is fine.

Translate from Haskell using Template Haskell
---------------------------------------------
B. Good.
C. Good.
D. Okay. It's not clear how easy it will be to add custom primitives and such.
E. Haskell does the Type checking. We may need to infer types.
F. We wouldn't have line numbers.

Translate from Haskell using Quasi Quoting
------------------------------------------
This is like having our own parser, with haskell type checking.


So, there are some questions I think it's worth exploring before deciding on
theses.

1. How hard is it to write a type checker.
So, given a Seri Ir, just return whether or not it types correctly, and
ideally a nice message if it doesn't as to why it doesn't.

2. How hard is it to write type inference?
So, given a Seri Ir, assuming no type annotations, how hard to figure out what
the types should be?

If the primitives are all explicitly typed, that's fine. But what I suspect we
would want is overloading. So, given '+', how do we know what type to use for
it? Can that be inferred?

Do we support polymorphism? Or does every function have a concrete type? So
length of list of Integer is a different function than length of list of
Boolean, and so on?

3. How could we incorporate abstractions of haskell into the front end?
Can you have some sort of $ substitution, or something like that?


I'm afraid some of these depend on language features. They may be easy to do
now, but adding some language feature could suddenly make it much harder.

Anyway, let me investigate these questions and see what comes out of it.

Sat Mar 24 12:15:43 EDT 2012

Checking the types are consistent, given the types, is not hard.
If I had line number information, I could give pretty decent error messages
too I think.

What do I have to do for type inference?

Well, you have to give some types.

I wonder if SMT could do this for me. I just ask: does there exist a
consistent typing for this expression? If so, give me evidence. And then I
could ask if there were others as well. If there is exactly 1, then we are all
set. If less, it's not well typed. If more, it's ambiguous.

I don't think SMT will give me very good error messages though.

What would type inference look like for me?

The things you infer types for are:

Applications. Just take the return type of function.
Lambda - based on type of the variables and type of the expression
    The names could be inconsistent
Variables - based on the type of the lambda.

So you would need to give information about either the variables, or the
lambdas. Otherwise it could be ambiguous. We need to make sure all the uses of
the variable have the same type.

I feel like, if we don't have polymorphism, then it's easy. If we don't have
typeclass or overloading, then it's easy.

If I were to do this, I would want another kind of type. An Unknown type, or
some such, to distinguish between those types I know and those I don't.

I'm pretty confident I could do type checking of this simple IR. I think it
could get much more difficult when I make it a more realistic IR.

Let me skip now to question (3). I'll take an initial look, then think about
it over lunch.

How could we easily integrate haskell into the front end?

I need an example. A concrete example to work with...

Okay, so here's an example...

I wonder if my language is too simple right now.

What I want is something where you have a list of statements you want to
write, using haskell. Or, when you want to compute a number statically with a
haskell function. That's good. Let me start with that.

So I have some language, where say foo is in the IR, but bar is something we
want to evaluate statically. Either in haskell, or in the IR?

    foo x + (bar 24.5)

Here we don't know to do bar in haskell. The proposal then would be something
like:

    foo x + $(bar 24.5)

Says, evaluate $(e) as a haskell expression.

There are a couple of cases. First case: the haskell expression returns a
haskell value, and we require you have a way to convert that haskell value to
a seri value. Second case, which I guess is a special case, is that haskell
function returns a seri object directly.

So let me propose the general case first. We say any expression... or anything
really (?) in our front end can be described using $(...) which statically
evaluates haskell code, as long as that haskell code can be transformed into
the kind of object we are expecting.

I would love it if there were some way I could convert haskell template code
into a pure haskell object, then possibly translate that into my language.

This is perhaps doable. You could imagine something like:
   $($(toseri [e| \x -> x+2 |]))

Unfortunately the $() is being overloaded here. The outside is meant to be let
me do haskell, the inside one is meant to be template haskell's splice, where
toseri goes from template haskell Exp to a Q Exp which is of type Seri IR,
which can then trivially be converted to Seri IR. So that's something we could
do. Not sure how useful it would be.

I should consider too how I intend to parse and execute haskell code
statically.

The other thing I may want to do is manipulate seri constructs in haskell.

So, something like,
  Say x is a variable in Seri front end in scope, or whatever...

I guess what I'm saying, is I want a way to input a nice front end string, and
turn it into a haskell seri object, which I can then pass to a haskell
function, which gives me back a new haskell seri object, which I can then
splice into seri front end again.

So, I guess I need two things.

We have the notion of a front end context. Not sure how I want to do that just
yet. I'm leaning towards quasi quoting at this point.

1. Inside a front end context, I want a splice, which lets me run arbitrary
haskell code, if that code returns a value we can turn into a seri object.

2. I want a way to convert a front end context into haskell code, which can
then be passed to haskell functions.

For example, let's say this is pure haskell code. I could do things like:

----------
foo :: Seri.Exp
foo = [seri| (\x -> x*x + 3*x + 2) 5 |]

three :: Integer
three = 3

bar :: Seri.Exp
bar = [seri| (\x -> x*x + $(three)*x + 2) 5 |]

sludge :: Seri.Exp
sludge = [seri| (\x -> $(muln 2 [seri| x |]) + 3*2) 5|]
----------

And, I thus hypothesize this is all the integration I need to do all the nice
static elaboration I want. Though I'm not at all convinced of this. I think
the best way to test that is through practice and trying to write real
programs in Seri, leveraging haskell as much as I can.

Cool! So, let me have some lunch, come back, and understand if quasi quoting
will give me everything I want, and if so, how specifically it looks.

Sat Mar 24 13:13:39 EDT 2012

Oh boy. So this is exciting.

The concerns with this method, over say, BCL's front end, are:
1. How much work is it to do type checking and inference
2. How much work is it to write a parser
3. How hard is it to get reasonable error messages?

Let me look at quasiquoting now.

Hmm...

So I provide a quoter. Let's just look at the expression context for now.

I provide a function: String -> Q Exp.

Then, [s| ... |]  just calls the function to get back the Q Exp.

Now then, here's how this would work.

Let me define my own slice notation, to avoid confusion. In my seri language,
let's say a splice is... inside: @(...).

I implement a quasiquoter s. It parses the string, and returns a Q Exp, where
the Exp describes a Seri.Exp.

Now the examples look as follows:


----------
foo :: Seri.Exp
foo = $([s| (\x -> x*x + 3*x + 2) 5 |])

three :: Integer
three = 3

bar :: Seri.Exp
bar = $([s| (\x -> x*x + @(three)*x + 2) 5 |])

sludge :: Seri.Exp
sludge = $([s| (\x -> @(muln 2 $([s| x |]) + 3*2) 5|])
----------

Fine. The real question is, how do I do the @() splice? How do I implement it?

Well, I need a haskell expression parser. I parse the expression into a QExp
(I'm in the Q monad, so that's fine). Then I have an Exp in haskell, I wrap it
in, say, an AppE toseri foo, where foo is that expression. When the quote
returns, template haskell will evaluate that application, evaluate foo, do the
conversion, and give me the result. Here toseri has type a -> Seri.Exp, for
some haskell type a (we'll want a typeclass for haskell things you can lift
into Seri.Exp).

The other slight issue is nesting of [s|...|]. I'll have to add a way to
escape.

What type checking do we get? Your haskell code will be typechecked and run.
The seri code we'll have to type check.

Okay? 

I think quasiquoting is a better idea than parsing from strings, just because
it makes it that much easier to embed in haskell. We can still read from
files too, using the same thing. This way we get type checking of the haskell
code for free.

I'm not sure about line numbers, but I could certainly keep track of them
myself as I parse the string. So you get a line number relative to a slice,
and presumably haskell tells you the line of the slice that failed.

We don't use a DSEL, or the type checking we could get from that.

That's interesting. Perhaps we could have an intermediate DSEL, it gives us
the type info we want, still use quasiquoting, then we leverage haskell's type
system.

That's an idea. Let me try not doing that first, and reconsider it when type
inference starts causing me problems.

Cool. I'm going to take a walk, then start getting to the nitty gritty, to see
if I can make this work.

Sat Mar 24 14:01:36 EDT 2012

Here are the steps.

1. Write a parsec (3) parser for Seri.Exp.

parse :: String -> m Seri.Exp.

To test: parse the foo expression.

2. Implement lifting of Seri.Exp to TH.Exp

This should give me a quasiquoter for seri.

To test: write down foo as [s| ... |].

Not sure what this adds at this point...

3. Add support for slices in the front end.

This may require finding or implementing a haskell expression parser.

This is where using quasiquoting becomes important.

Try the bar test.

I don't imagine I'll get this far today, so let me stop the list there, and
start working.

First step, a parsec parser for Seri.Exp.

Sat Mar 24 15:02:04 EDT 2012

Okay! I have a parser. It's picky about whitespace, but it's enough of what I
want right now.

Sat Mar 24 16:16:35 EDT 2012

Next step: quasiquoting.

I can tell you at least one benefit of this. Maybe two.
1. Don't have to escape backsash.
2. vim will syntax highlight the contents of the string.
Now, admittedly it will use haskell syntax, but I could always add to vim an
escape to do specialized syntax highlighting for the quasiquote.

Little things, but let's see how it goes.

First step: lifting a Seri.Exp into TH.Exp. I wonder if there is a typeclass
for this already I could use?

Yes! There is. In Language.Haskell.TH.Syntax, called Lift.

Except... err... it would be Seri.Exp -> QExp. Is that okay?

Look, I can provide the pure version too. The lift instance will just be to
return that. Fine.

Sat Mar 24 16:30:15 EDT 2012

If what I'm doing will work, it will be much easier to lift into Q Exp than
Exp. Just wrap everything in th brackets. Let's see if it works.

How to test...

I suppose the way to test is to make a quoter, and see if it works.

Sat Mar 24 16:46:48 EDT 2012

It works! A slight difference than what I expected: the quoted thing returns
that thing directly, not a Q Exp. But that's fine with me.

Cool! Next step... slices.

Now then... how do I want to go about doing this?

I can parse everything between @(...) into a single string, with matched
parenthesis. Now I have a string.

How about I add an expression type to Seri (I wince a little at this thought,
but I'll clean things up later as needed), which is that Seri can have an
expression which is a THQExp.

Now all I need are two things.

1. Add that to the lift instance. Which is trivial, right?
2. Find a haskell parser to convert String into Q Exp.

The second point is just a little harder. Let's see what there is out there.

Looks like: Language.Haskell.Meta.QQ.Hs has hs quasiquoter for haskell, which
is just what I want.

So then, this should be simple.


1. Add Q Exp as a kind of seri expression.
2. Figure out how to parse the string @(...), with nested parens.
And also, probably want to escape |] at some point. But don't worry about that
now.
3. Use hs quasiquoter to convert String to Q Exp.
4. Implement lifting.

Or whatever. There's nothing big here. It should all work swell.

But! I should go eat dinner first.

Sat Mar 24 18:02:24 EDT 2012

It works! Haskell slices work just swell. That's awesome.

Currently the slice has to return a Seri.Exp. It might be nice if it can
return any arbitrary haskell value that can be converted to a Seri.Exp.

That should be simple to do. I just need to introduce a typeclass.

Cool.

Sat Mar 24 20:09:50 EDT 2012

Now then, what should I call this typeclass?

Seriable? Sounds too much like Serializable?
Seriable and seriize. Err...

Seriable seriate. Good.

Sat Mar 24 20:16:42 EDT 2012

That works nicely.

What remains to do now?

From my list above, I just want to try nested quotes. I think it will require
escape characters to make work.

Yup, nesting needs to be escaped.
I can escape it with...
Uh... "|~]" how about?


You know what? We don't need nested quotes. I can always say
 let x = [s| ... |]
 in [s| ... @(x) ... |]

And that's just fine with me. The issue is, we would run into double nesting
issues, triple nesting, and so on. It's just not worth the effort to deal
with.

Okay! Cool.

What's left?

The big thing missing now is just type inference. Because I really can't do
type inference in the parser. Can I? Can I just have explicit types?

Well, we would like some explicit types, and some type inference.

I think, give me type inference. And it can be sloppy. Infer types, then run
typecheck on the inferred types. Hopefully that's easier than trying to do it
all at once.

I'm a little worried about error messages and line numbers, but ... don't
worry about that just yet.

How can I do type inference?

I feel like I tried this before with drizzt, or whatever language I had. And
it was messy.

Let's assume no polymorphism for now.

Conceptually you can assign a type variable to each unknown type, and come up
with a bunch of constraints.

Can I use an SMT solver for this? That would certainly be cool...

Is it worth trying to do in yices manually?

For example, how would I typecheck qbar?

AppE A (LamE B "x" (AddE (AddE (MulE (VarE C "x")
(VarE D "x")) (MulE (IntegerE 4) (VarE E "x"))) (IntegerE 2)))
(IntegerE 5)
 

Variables: A, B, C, D, E.

Constraints:

B = ArrowT F G  -- function in apply must have ArrowT type
A = G           -- type of apply is return type of function
F = C           -- type of variable is same as input to lambda
F = D
F = E


Hmm... Maybe it makes sense to combine this with type check.

I come up with a set of constraints of these forms, introducing variables as
needed.

Then I ought to be able to use SMT or something to solve this, right?

Come up with a set of constraints, then try to solve.

Let me alter the typecheck function...

No, let me write another function, which given an expression, returns a set of
constraints. Where each constraint is of the form (Type, Type). And we add
VarT as a type. We'll have a state monad to collect constraints, and a counter
to keep track of free variable types.

I'll run this, print out what it gives for my expression, make sure it looks
right, then see if I can solve that with yices.

Err... I really hate to have to go to IO to do typecheck.
Could I not implement a constraint solver?

Well, let's see what I can do with the constraints.

Here are the constraints I generated for Q Sludge.
 
V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
ArrowT V5 V6 = V1
IntegerT = ,IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

What do we see? Clearly I have my types wrong, because this is not
satisfiable. Let me go fix my bugs.

V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
ArrowT V5 V6 = V1
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

Now if I solve this by hand, I get...

V0 = V8
V1 = IntegerT V6
V2 = IntegerT
V3 = IntegerT
V4 = IntegerT
V5 = IntegerT
V6 = V8
V7 = IntegerT

Hm... We don't have all the info we need.

Let me print the expression out too.

(AppE (VarT 0) (LamE IntegerT "x" (AddE (AddE (MulE (VarE IntegerT "x") (VarE
IntegerT "x")) (MulE (IntegerE 3) (VarE IntegerT "x"))) (IntegerE 2)))
(IntegerE 5),

I'm missing a constraint. One that says the type of an application is the
output type of the function called?

Okay, I see what I missed. Now let's see.

(AppE (VarT 0) (LamE (VarT 1) "x" (AddE (AddE (MulE (VarE (VarT 2) "x") (VarE
(VarT 3) "x")) (MulE (IntegerE 3) (VarE (VarT 4) "x"))) (IntegerE 2)))
(IntegerE 5),

V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
V6 = IntegerT
ArrowT V5 V6 = V1
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

If I solve it manually, I get:

V0 = IntegerT
V1 = ArrowT IntegerT IntegerT
V2 = IntegerT
V3 = IntegerT
V4 = IntegerT
V5 = IntegerT
V6 = IntegerT
V7 = IntegerT
V8 = IntegerT

Perfect. Just what we want.

Now, I think it would be good practice to try asking this question to the SMT
solver, yices. I'll do that tomorrow morning.

My question to you is, is there a systematic way to solve this system of
equations? Can I do variable elimination? In some order?

Perhaps I can eliminate constraints?

X = X  - drop the constraint, because it's trivial.
ArrowT X Y = ArrowT W Z  - replace with X = W, Y = Z
X = Y - If we can give priority to types, say smaller types have higher
priority than larger types, we could say, substitute every occurence of Y with
X, recording that Y is Y.

Repeat until we reach some sort of fixed point?

Let me try it.

V7 = IntegerT
V8 = V0
V1 = ArrowT IntegerT V0
V5 = V4
V4 = V3
V3 = V2
V6 = IntegerT
V2 = IntegerT
V0 = IntegerT

We make pretty good progress after one round, but now what? Another round
isn't going to help any.

Maybe I have to replace all of them?
Let me try that.

So we say the following: you may only replace a variable with a better known
variable. That should finish us. Let me try it.


V7 = IntegerT
V8 = IntegerT
V1 = ArrowT IntegerT IntegerT
V5 = IntegerT
V4 = IntegerT
V3 = IntegerT
V6 = IntegerT
V2 = IntegerT
V0 = IntegerT

Wow. Well, that works pretty well here.

Perhaps there is some fixed point thing or something. It would be nice to try
and prove in coq or some such.

The idea is this. We order expressions from best known to least known.

Whenever you encounter the constraint: X = Y, flip it so that whatever is on
the left is the last known. Call that X. Then, replace every other occurrence
of X in all other constraints with Y. You have just made things better known
overall.

Ignore constraints of the form X = X
Fail at constraints of the form X = Y where X and Y are known but don't match.
Reduce constraints of the form ArrowT A B = ArrowT C D to two simpler
constraints: A = C, B = D.

The hpothesis is, running this algorithm will leave you with an association
list mapping unknown types to known types. Just look up your type variable in
the list, it will tell you, as best it can, what the type of that is.

Well, it's late enough I need to call it a day.

Here's the plan for tomorrow.

+ Implement my proposed type constraint solving algorithm.
+ Combine that with the constraint generation to do type inference.
x Try using yices to solve the above constraint problem.
Mostly just for practice with yices. I don't actually want to use it in my
compiler because I don't want to have to go to IO. It will be good to have
confidence that I can use an SMT solver if things start getting messy though.

At this point, I should have a full front end, parser, type inference, type
checker (if not subsumed by type inference, it might be nice to have type
checker to make it easier to figure out type errors), elaborator, pretty
printer, haskell generator, c generator.

+ Reorganize code into something nice.
+ Write up HUnit test cases.
+ Expand Seri to support factorial function with fix operator.

This should give me a feel for things. At this point, I think I'll have enough
to go on to try and understand extensibility. I'd like to answer questions
such as:
* Can we augment the IR with unknown type just for parsing?
* Can we augment the IR with variable types just for type checking?
* Can we augment the IR with source pos info for parsing and type checking?
* Can we separate primitives out of IR in a nice way? 

If this is not enough to go on, then continue to expand the IR until it
supports everything I want for tibby. See if I can describe QR in my IR, how
nice it is, if it all works, and then try to compile to C, BSV, and Fiddler.

That's really the ultimate for this project. If I can do QR in those
languages, them I'm ready to roll.

Sun Mar 25 06:48:06 EDT 2012

First step: implement my type constraint solver.

Well, it seems to have worked on my simple example. We shall see if it works
in general.

Next step: make type inference much nicer.

Here's how it should work.

1. UnUnknown expression
2. Generate type constraints
3. Solve type constraints
4. apply solution

Let's allow the user to do typecheck separately from inference.
And we just say, well, inference may not return a correct result, so you
should probably check the solution it gets.

Sun Mar 25 07:37:56 EDT 2012

I don't feel much like playing with yices right now.

Let me instead move on to code cleanup.

I'll start by looking at the code, proposing a solution. Then I'll take a
break for breakfast, come back, and clean stuff up.

Proposed hierarchy:

C - ir, ppr
Seri - Seri.IR, Seri.Elaborate, Seri.Parser, Seri.Quoter, Seri.TypeCheck, Seri.TypeInfer
Seri.IR - ir, typeof, ppr
Seri.Elaborate elaborate
Seri.Parser parser
Seri.Quoter quoter, thlift
Seri.TypeCheck typecheck
Seri.TypeInfer typeinfer
Seri.Backend.C
Seri.Backend.Haskell

I think that will make for a nice structure, and clean sharing, and such like.

And we should have test cases for everything.
Let each module define its own tests? Yes, as HUnit.

Good. This will be nice to do.

Sun Mar 25 08:32:21 EDT 2012

Next step: switch to using HUnit for tests.

Sun Mar 25 09:11:23 EDT 2012

I want to see if I can simplify the code some. This will help for
understanding how I could do generic programming too.

The issue is, I feel like I implement recursion down the expression tree lots
and lots of times, repeating lots of the same stuff.

Can I make some generic expression traversals to make things easier?

Let's look at all the times I do this recursion, and see if I see any common
forms.

elaborate: 
    integer: does something
    adde: recurses to a, b, does something
    mule: recurses to a, b, does something
    appe: recurses to f, x, does something
    lame: does something (this is a leaf for elaborate)
    vare: does something

reduce: takes args
    integer: does something
    add,mul: recurse to a, b, does something
    app: recurse to f, x, does something
    lame: recurses to body, does something
    var: does something

typeof: does something for each. No recursion.

ppr: does the recursion like reduce

lift: does something for each. Nor recursion.
    
checkvars, typecheck use our common recursion
tereplace does, ununknown does, constrain does, constrainvs does

In summary, we do this recursion in the following places:

reduce, ppr, checkvars, typecheck, tereplace, ununknown, constrain, constrainvs

You would think I could factor out the common code.

Okay, so let me make a stab at a proposal for the traversal function.

At the high level, we want to produce a function of the form: Exp -> a
I want to provide the following:

Integer :: Integer -> a
AddE :: a -> a -> a, 
MulE :: a -> a -> a,
AppE :: Type -> a -> a -> a
LamE :: Type -> Name -> a -> a
VarE :: Type -> Name -> a

For example, reduce would be:
Integer :: IntegerE
AddE :: AddE
MulE :: MulE
AppE :: AppE
LamE :: \t ln b -> if ln /= n then LamE t ln b else (original LamE)
VarE :: \t vn -> if vn == n then v else VarE t vn

So maybe we also pass around the original expression, as an escape hatch if
you don't want to do the recursion completely.

How would you specify these? As arguments, or in a structure.

I think this is worth trying out at least. See if it cleans things up at all
or not. See if it works or not.

Sun Mar 25 09:45:48 EDT 2012

Well, there's less code written. But I'm not sure you can read the code and
understand how it works. Maybe that's not true. Maybe it actually captures the
heart of what you want to do?

Anyway, let's see how much work it is to use with elaborate.
Elaborate works fine.

ppr - doesn't exactly match form. I could rewrite it so it does, but let me
skip it for now.

typecheck - doesn't work so well, because of the monad. Perhaps I can have a
monadic traversal implementation? Let me skip this for now.

ununknown - another one which could take advantage of a monadic traversal.
constrain - same, monadic traversal would be nice
constrainvs - same.

And even the one I did which was monadic could take advantage of this.
Oh, no, actually checkvars doesn't work so well with monadic, because we have
a case where we don't want to apply the monadic part.

Sun Mar 25 11:07:31 EDT 2012

Okay, so that's maybe a little bit cleaner.

I don't know. It still feels a little irksome to me, but I don't know why.

Anyway, let me expand the language to support a factorial function. This will
be a bit of grunt work, but it will be valuable.

In particular, pay attention to what I need to do to add a new construct to
the IR. This is the kind of information I'll need an IR extender to write.
This is the kind of information we want to be component specific.

Fine. What's first?

What's the sum list of things I need?

Well, I want to write something like:

  let factorial = [s| !f \x -> if (x < 1) then 1 else x * f (n - 1)
  in [|s @(factorial) 5 |]

I need the following:
+ Subtract
+ Bool
+ Lt
+ If
+ fix operator

Start with subtract.

Things to add:

- IR construct for it: SubE
- Add syntax to parser: -
- TH lift (TODO: can't we automatic this in most cases?)
- traverseM
- ununknown
- constrain
- traverse
- elaborate
- reduce
- tereplace
- constrainvs
- typecheck
- checkvars

All that just to run the thing. This doesn't include pretty printing of
conversions to C or Haskell.

I do observe AddE, SubE, and MulE are all implemented in almost exactly the
same way.

Next: Bool. This is a type, so there will be some difference.
Really we want Bool.

Sun Mar 25 12:04:02 EDT 2012

I notice adding new constructs seems fairly straight forward.
SubE was just like AddE.
BoolT, BoolE were just like IntegerT, IntegerE.

It makes you wonder if you should have primitive types, or binary integral
functions, or some more general representations of things.

Anyway, on to Lt. This is another binary function, but it has a different type
than the previous ones.

Yup, adding that was pretty straight forward.

Next: If.

This one might be more interesting.

Sun Mar 25 12:32:07 EDT 2012

In all these things, the Parser is most fragile. Adding more stuff can break
it easily. That's not so much the case for anything else.

Sun Mar 25 12:41:01 EDT 2012

Next, and the last needed for factorial, though perhaps the one I need be most
careful about...

Let me wait to do 'fix' until after lunch.

Sun Mar 25 13:15:06 EDT 2012

Okay, so, how do I implement fix?

I think everything is straight forward except for elaboration.

FixE :: Type -> Name -> Exp -> Exp

How do I reduce this?

Well, the idea is, it's an expression, and we can construct the new expression
as ...

I need to be careful.

Let's say you have to fix a function, not just a value?

Ug. What I want to do, is, we have Exp -> Exp which unrolls the expression. We
just call haskell's fix point operator on that, then fix goes away, and it
becomes... what?

Well, it becomes a lambda.
The trouble is, if you try to print it out, for example, it will become an
infinite lambda. So, don't try to print this out.

I feel like what I could do, is say: the type of the Fix expression has to be
a function type. Then we only go to unroll it when we try to apply to it.

Okay, fine. Whatever. Let me just do it this way: to evaluate fix, use
haskell's fixed point. Haskell is lazy. As long as we don't try printing the
result, we should be fine.

So, to elaborate fix, I would do the following:

Okay, I think I got it. Let me try and see what happens.

Sun Mar 25 13:40:36 EDT 2012

Okay! So, we have a type error.

The expression is x.
The expected value is Integer. That's good.

The inferred type is:

---------
((IntegerT -> IntegerT -> V8)
    ->  (IntegerT -> IntegerT -> V8)
    -> V8)
-> ((IntegerT -> IntegerT -> V8) -> V8)
---------

That's very strange.

First note: I should print types in errors, not show them.

Oh, I had some bugs. Now it type checks.

Trouble though: elaboration doesn't complete.

That is, elaboration returns this big old expression.

Oh. I bet I just forgot to elaborate the result of the fix.

No. That wasn't it. Hmm...

I should be pretty printing the results, not showing them. Hmm...

Oh. I had a typo in the input. I used both n and x, but n was free, it wasn't
bound. That caused the problem.

Hey! Cool. Fix point works. Factorial works.

Sun Mar 25 14:10:21 EDT 2012

Next goal: Extensibility.

I'm pretty confident I could write a bunch of cool stuff, have a bunch of
features. But I want it to be clean. That is, I want each feature to be like a
library, and I just need to pull in whatever libraries I need for my
application.

Let me start with perhaps a simpler goal than I had before, but still a big
step towards extensibility.

Right now we have things broken up by phase: parse, quote, typeinfer,
typecheck, elaborate. What I really want, though, is to be broken up by
construct: Bool, Integer, Add, Sub, Mul, Fix, If.

Hum. This seems rather daunting. Perhaps I can put up some strawmen and see
how well they do.

Let me ignore the parser for now, because I think that's its own issue.

I have these functions: typeinfer, typecheck, elaborate, and friends.

What I want, in my vision, is that these will work on any kind of IR type that
has each function properly described. Thus, it would seem, typeclasses could
help us. I want each feature of the IR to be its own type, I implement the
right typeclass, and suddenly I can use the functions.

In particular, it would seem I'd like a way to put a bunch of features
together, so that given an IR and a Feature, I get back a new IR.

Okay, good, that all sounds good.

And I'm fine having a core IR with variables, lambdas, and applications, if
that helps to kick-start things.

Okay, now what? Um, let's say every IR has an Exp type and a Type type? I
don't know what I'm doing, let me just write things down and see where I end
up.

Ug.

Say a Feature involves some Type and Exp it adds.
For example, boolean might add: BoolT, BoolE.
We have a core IR with Type and Exp

I want a new IR with (Type, BoolT) (Exp, BoolE).

Err...

data Exp a = IntegerE
           | AddE (Exp a) (Exp a)
           | ...
           | a
           ;

This is an extensible expression type. To extend it, you just add expressions
as described by the 'a' type. So, this becomes a bit like stacking monad
transformers.

Now, I could fill that with a feature, right? And the Feature should be
extensible...

data Feature a = BoolE
               | a
               ;

No. It doesn't work, because the new features need access to all the old stuff
too.

hmm.. an IR augmented with a feature can be typechecked, for example, if the
IR can be typechecked, and the new feature can be typechecked.

Let me use If as the example, I think it will reveal more.

data CoreE t e = 
    AppE t e e
  | LamE t Name e
  | VarE t e e
   
        
data IfE t e = IfE t e e e

Okay, so we specify features like this, say. Parameterized by t and e.

Now, in order to instantiate our concrete IR, we would do something like:

data MyExp = Core (CoreE MyType MyExp)
           | If (IfE MyType MyExp)

Ooh. This looks like it has potential to me.

instance Typeof MyExp where
    typeof (Core x) = typeof x
    typeof (If x) = typeof x

And we could maybe even use generics to help us write these, but let's not
worry about that just now.

instance Traverse MyExp where   
    traverse... It should work.

I want to try this for a little example. Maybe, have the core be everything
now aside from fix. Then add Fix as a feature. That will be a good test.

I'll have type classes for all the phases. I'll implement Core to work the way
you would expect.

Um, things could get messy. I would recommend: don't worry about messing a
bunch of stuff up.

In fact, it may make sense to try and start from scratch with a simple core,
one bit at a time, copying code. Yes, I bet that will be easier than trying to
modify this whole thing.

Cool. I like this vision.

Sun Mar 25 15:45:34 EDT 2012

Slight change in plan. I'm going to try and adapt the existing code rather
than starting from scratch.

We'll say the parser is for my specific choice of combinations (what I have
currently).

I'll pull pieces out of Exp and Type a bit at a time.

First thing to pull out: Fix.

Pull it out, make type classes for each feature.
After that, I should be able to pull things out a piece at a time.

There is one issue I might run into. I'll probably run into. Let me deal with
it when I get there, but have it in my mind now. That's, some features depend
on others. Like, you can have If unless you have Bool. How will those compose
together? Hmm... worried. But let me try this anyhow and see how it goes.

Sun Mar 25 15:54:14 EDT 2012

Not sure how to deal with traversal. Can I come back to that later?

Things to pull fix out of:

elaborate.

Hmm... this seems to interact poorly with traversal...

Let me try typecheck, which doesn't have the traversal issue.

But that depends on checkvars, which has the traversal issue.

This traversal thing... doesn't seem to help.

Let me remove use of traversal from all of TypeCheck, then try to pull FixE_F
out of it.

Sun Mar 25 16:20:52 EDT 2012

I should figure out how they use generic programming in haskell to implement a
generic show. That way I can write a generic implementation for your concrete
IR, given the implementation for all the pieces.

Anyway, continuing on with extraction of FixE.

Sun Mar 25 16:38:51 EDT 2012

Trouble with the Elaborate class. We need to pass in the top level expression
container. Does that mean it needs to be part of the class?

It seems like a Fix point specific thing, because fix has to refer to itself.

Ug.

I think, maybe, I should take a break from this track, and look more closely
at generic programming? Perhaps that will give me ideas?

Erg...

Sun Mar 25 17:17:59 EDT 2012

I looked into generic programming a little bit. I think I can make use of it.

Let me try the following.

In TypeInfer, we have this function tereplace.

I bet that I can implement that in a generic way.
I fear this could be slightly problematic, if, for example, you want to have a
Type in your expression which you don't want substituted, but that seems
unlikely to me. So let me try this.

I'm going to make the replacement work for any typeable thing. And I'm going
to see recurse through the structure, and replace all types.

Wish me luck.

Well! It works.

That's no so bad actually, using everywhere and mkT.

And you know what this means? I don't need to implement that function for each
separate feature. That's nice.

Let me go see where else I can apply this.

Aha! It would seem ununknownt is a good candidate. Monadic this time.

Wow. that's really nice.

It means much less work for adding new features, that's for sure.

Sun Mar 25 17:46:29 EDT 2012

I'm not sure there are other really generic kinds of functions that I could
take advantage of Data.Generics for.

Hmm... So the real question is, could I use this to say something like:

We have a typeclass which says, given a constructor FixE, for example, and all
its fields, knows how to do, say, elaboration on it.

Then each feature is a constructor.

Hum hum... I feel like that's worth pursuing.

Let me think about this a bit.

Sun Mar 25 19:55:06 EDT 2012

Type classes could lead to trouble with generics. That is, you can't use a
typeclass to define your transformation function (a -> a) because we don't
know that every a you encounter will be an instance of that typeclass.

Sun Mar 25 20:06:37 EDT 2012

One thing I can do is ask for a constructor of a given object. I'm not sure
how that helps.

How about this. Let me not get caught up in Data.Generics. I know how it can
be used, how it can be useful, but that's enough. I'll use it where it makes
sense.

I think the original plan still holds. Try to pull Fix outside, into its own
file.

Sun Mar 25 20:23:56 EDT 2012

Perhaps it does make sense to try start from scratch after all?

I can make my parameterized core. Build it from the ground up?

I suppose it's worth a try.

First step: IR/Core:

AppE, LamE, VarE
ArrowT, UnknownT, VarT

Trouble is, I can't really do anything with that, can I?

I'll want, perhaps, also IR/Arithmetic:

IntegerE, AddE, SubE, MulE
IntegerT

I'm not sure this can work.

Okay, maybe I just need to think of myself as having type features as well as
expression features.

This could get messy.

I wonder... Could I make this cleaner?


For example, what we really want is to have some expression e.

That is, imagine an expression. And say,

data FixE = FixE ...

This is a kind of expression.

data LamE = ...

is a kind of expression.

Now, my functions work on expressions.

The question really is, how do you define what all types of sub expressions an
expression could have? Well... that's defined by what you import, right?

For example, we could define the following expressions:

data BoolE = BoolE Bool
data IntegerE = IntegerE Integer
data AddE where
    (Exp e1, e2) => e1 -> e2 -> AddE

I fear this is starting to look just a bit like GADTs... 

But let me keep looking.

Okay, fine... now how do I do, say, elaborate?

instance Elaborate IntegerE where
    elaborate e = e

instance Elaborate AddE where
    elaborate (AddE e1 e2) =
        case (elaborate a, elaborate b) of
            ... -> IntegerE
            ... -> AddE

Aha! Now we see the problem.

What's the return type of elaborate? In the case above, two branches have
different types! That's bad news.
            
Something about this feels nice though. Like, the dependency problem I was
worried about goes away or some such.

What if you defined some top level Exp type, which is the union of all the
kinds of expressions you want.

instance (ToE AddE, ToE IntegerE) => Elaborate AddE E where
    elaborate (AddE e1 e2) =
        case (elaborate a, elaborate b) of
            ... -> toE IntegerE
            ... -> toE AddE

So now we can build up a library of specific expressions. Then, when you want
to define you top level thing, all you need to do is define your top level
data type, and deriving ToE. That, perhaps, could also be automated with
template haskell or generics.

The real question is, is there any chance at all this could work?
How could I come up with a proof of concept?

Let's start with: Elaborate, IR. Using Core and Arithmetic.
Then add TypeCheck. If all goes well, expand it slowly.

Shall I take a quick stab at things?

We have a type level expression. We have a type level type.
LiftE, LiftT.

Let me try to get started. For now, treat all names as String. It will be
simpler.

Sun Mar 25 21:00:14 EDT 2012

Okay, we'll see if this is going to work or not.

Just try to get elaboration to work with core and integer.
That should show me lots of issues.

In fact, let me ignore types for now, because we don't need them for
elaboration. I can add them later.

Sun Mar 25 21:10:32 EDT 2012

Let's simplify even more for this first attempt. Forget core. Just be able to
do expressions like: 2 + 3 + 4...
    
Sun Mar 25 21:42:26 EDT 2012

Well, believe it or not, something works.
It's a little scary typewise.

There are a lot of places where we need explicit type info.

Sun Mar 25 21:56:47 EDT 2012

Okay, so I cleaned up a little.

It seems like I've ended up close to where I was headed towards in my last
attempt. The key idea is: have inject, and unject to be able to stuff an
expression into the top level expression and extract an expression from the
top level expression. That gives me the dependency stuff I need.

I believe this has some promise.

Let me figure out how to elaborate my favorite expression:
    (\x -> x*x + 3*x + 2) 5

That should help force the issues.

Once I can do that, add some type info, and move on to type checking.
From there move on to type inference.

Mon Mar 26 08:21:15 EDT 2012

Okay, so it seems robust to adding MulE. That's good.

And I think it should be relatively easy to automate the generate of the
Inject interface and the top level elaborate interfaces using template
haskell.

I feel like I should be able to do similar with generics, but I don't know how
to get around this typeclass issue. I feel like template haskell is safer,
because it does that extra type checking step.

Next step: application, var, and lambda.

Mon Mar 26 09:02:54 EDT 2012

Foo works!

Good. So I'm feeling pretty confident in the way things are going for
elaborate. I think now would be a good time to step back, think about what's
going on, and do some code cleanup.

Mon Mar 26 09:08:21 EDT 2012

Basically the idea is each expression can be boxed (injected) into the full
expression, and we can go back and forth. So it's like a dynamic typing sort
of thing.

The problems currently are:
- You have to specify lots of types explicitly, because any time you construct
  an expression, and especially if you then inject it, you have an ambiguous
  type. Perhaps there's some way to get rid of this, but nothing comes to mind
  immediately.

- boilerplate code for MyExp (the box) is really annoying, though simple.

- Have to deal with all these multi param type class, flexible instance and
  contexts, undecidable contexts and scoped type variables. That worries me a
  little. But we don't need GADTs, which I guess is nice.

So, next step is clear, I think. Automate the boiler plate code, because it's
only going to get more annoying.

After that... I think we have interesting enough constructs to try and flesh
out the whole stack, from parser down to... let's stick with elaboration for
now. No need to go to the backends just yet, because that's too hard to test.

First step. automation. I can do this with template haskell, I'm sure.
Can I do it easily with generics?

We want two things: an instance of Inject for each field.
   instance Inject Foo MyExp where
        inject = MyFoo
        unject (MyFoo x) = Just x
        unject _ = Nothing

An instance for Elaborate, which just applies the same functions to each
immediate sub constructor.

I feel like the elaborate instance should be ... It's like a query. So I
should be able to use generics, aside from this typeclass issue.

Ah, but we can have a default value, no?

I think it's worth a try. It would be much cleaner than template haskell.

No, I don't think I'll get it to work, because, again, of this typeclass
issue. Fundamentally I need to figure out how to do a transformation on
typeclasses, where ideally it would though a static error if you would ever
try to use it on an object that doesn't implement that type class. Or, in
other words, template haskell will give me just what I want.

So let me use template haskell.

First step: the instances of inject.

Mon Mar 26 10:18:36 EDT 2012

Template haskell and quotes seem so promising, but when you get into it,
little details make them, basically, unusuable. Like, not being able to splice
in patterns. Not being able to splice in non-top level declarations.

I almost feel like it would work better to use a haskell quasi quoter, where I
supposedly can do those things. That may be worth experimenting with.

Anyway, I have automatic generation of Inject now. Next I need elaborate.

Mon Mar 26 17:50:01 EDT 2012

Elaborate.

for each constructor
    elaborate (Foo x) = elaborate x
for each constructor
    reduce n v (Foo x) = reduce n v x

I don't believe template haskell quotes will work here, so let me not bother
with them.

Mon Mar 26 18:04:10 EDT 2012

Okay! So that wasn't too bad. We now automate self elaboration. Good. What's
next?

We have enough of the expressions. I'm confident I could keep adding more and
still have that work out for elaborate.

The real challenge next is...

Type checking. Adding and checking type information.

And note, we'll want the types to be extensible too.

What types do I need for type checking?

Assuming the are all known, for now it should be enough to have IntegerT and
ArrowT.

For each expression we need: typecheck, checkvars
We also need pretty printing of expressions and types.

I don't need any sort of traversal of types to do this, which is nice.

Okay, so, it's straight forward, right?

class (Eq t, Ppr t, Ppr e, Inject ) => TypeCheck t e...

One thing is we return the type in typecheck. We could just as easily use
typeof to get at the type, right? I honestly think that makes more sense.

Hmm... it's hard to figure out what I need to do.

Well, first step, let's say, is to add type parameters to Var, Lam, App.
See what all headaches that causes.

Here's an idea, maybe LamE should be a VarE and a body. That makes sense,
right? It does to me...

Mon Mar 26 18:27:34 EDT 2012

I'm getting this error:
    No instance for (Inject (LamE t MyExp) MyExp)
      arising from a use of `reduce'
    Possible fix:
      add an instance declaration for (Inject (LamE t MyExp) MyExp)
    In the expression: reduce n v x
    In an equation for `reduce': reduce n v (MyApp x) = reduce n v x
    In the instance declaration for `Elaborate MyExp MyExp'

I think the issue is, reduce requires you can inject any LamE t, but you can
only inject a LamE MyType. That is, t is determined by MyExp. So we need some
form of functional dependencies.

Well... we could have inject know about types, right?

But why doesn't VarT have that issue?

That's odd... AppE doesn't have the issue either. Did I implement something
wrong?

And now it works fine... okay, whatever.

So I added a type parameter. I just don't have any interesting types yet.

Let me define an interesting type: IntegerT, ArrowT.

Mon Mar 26 18:38:29 EDT 2012

Okay, now when I start to use different expressions, we have issues with the
types. That is, our boilerplate code defines instances for
Inject (AppE MyType MyExp) MyExp

It does not for
Inject (AppE IntegerT MyExp) MyExp.

Maybe I just need to do the injections of the types.

So I want a way to inject IntegerT into MyType.

Okay, I had a typeo. Remember, you have to lift everything up to MyType or
MyExp before passing it to a bigger expression or type. This is very annoying
when writing the IR code by hand, but hopefully the parse will have no trouble
at all with it.

And now, let me automate generate of instances for the types too. It should be
exactly the same. I'll add an argument to the ir function.

Cool, so that's all automated, and we have types inside of expressions.

Now let's see if typechecking is made any easier.

Let me start with checkvars, which is the simpler of the two things.

class TypeCheck t e | e -> t where
    checkvars :: Monad m => Name -> t -> e -> m ()

Say? Let me just dive into code, not really knowing what I'm doing, and see if
anything comes out of it other than a big mess.

Mon Mar 26 19:22:22 EDT 2012

checkvars works now. I feel like there was a bad test case that magically
fixed itself. Oh well.

Anyway, we have more boilerplate code to do away with.
Instance TypeCheck MyType MyExp.

Mon Mar 26 20:39:02 EDT 2012

Next step: the typecheck function.

Mon Mar 26 21:09:58 EDT 2012

Nifty, so that's done, and we have type checking!

The type errors are terrible to read though, because we don't have pretty
printing of expressions. That's something it would be very useful to have.

Well, it's safe if I use parenthesis, but otherwise, how do we deal with
operator precedence? Do we go the haskell route and just use parentheses
everywhere?

Well, anything is better than what show gives us, so I should think ppr would
be just fine.

I think, perhaps, I'm running a little low on steam just now, so let me call
it a day there.

What are the next steps?

+ pretty printing of expressions and types
- VarT, UnknownT
- type inference
- parser - good luck figuring this one out.
- quoter
- add to expressions until we can implement factorial.

Tue Mar 27 13:13:29 EDT 2012

Type inference will take a little bit of thought.

What are the assumptions about types we use?

Well, there's this thing called a VarT. I think type checking has to assume
that. Then we say a VarT is less known than any other type, and a VarT with
greater id is less known than a VarT with lesser id.

Is there ever a type which should be less known than VarT?
I don't think so.

The other issue is ArrowT. This is a type constructor. Somehow we need to know
it has fields ArrowT a b, so if comparing two of these things, the types of
the fields should be set to equal.

This is not specific to ArrowT. You could imagine ListT, VectorT, MaybeT, any
sort of type constructor could have some number of arguments, and these
arguments have to match.

One way we could capture this information is by specifying a function of the
form: t -> [t]. So, given a type, return all the list of component types. And
we just say all the component types have to be equal.

This is close, but not enough to do type replacement, so map every VarT X into
the corresponding thing in the association list. Perhaps what we want is some
generic way of doing traversals? Like the traversal mechanism I had before,
just made into a typeclass?

Err... what I want is, I give you a function, it should work on types
generically. You apply that function to all your subtypes, and do some
composition of the results, and give me that back?

For example, to collect the list of subtypes, I'd say something like:

traverse id (:)?
No, that's not a good example, because it isn't a recursive kind of search.

How about more specific cases?

Constrain. We have an expression. I want to say, apply some ...

You know what? I don't think this makes sense. You have to specify type
specific composition anyway, so may as well let the type specific recursion
happen in the same place.

The goal is just to somehow make it so you don't have to specify as much for
each expression or type. Like, can I extract all the information I need in
some generic way, then apply that, but I don't think that's the case.

Okay. Let me list all the functions I think I'll need from each expression and
type in order to do type inference, and we'll see how it looks.


-- replace all occurrence of a type with some other type in the given
-- expression.
typesubst :: [(t, t)] -> e -> e

-- replace all occurrences of UnknownT in e with a VarT with unique id.
ununknown :: e -> State Integer e

-- replace all occurrences of UnknownT in t with a VarT with unique id.
ununknownt :: t -> State Integer t

-- Generate type constraints for the given expression.
constrain :: e -> State (Integer, [(t, t)]) ()

-- add a constraint that every variable with the given name has the given type
-- in the given expression.
constrainvs :: Name -> t -> e -> State (Integer, [(t, t)]) ()

-- Given the constraint t == t, reduce it to a smaller constraint.
-- So, both t's should be of the same type, otherwise you can do nothing.
-- Then, if they are the same... this feels messy to me.
subconstrain :: t -> t -> State (Integer, [(t, t)]) ()

I wonder if you could do it slightly differently. What if we had the
following:

-- Given type, return its subtypes.
unconstruct :: t -> [t]

-- Given sub types, construct the type.
construct :: [t] -> t


Now, typesubst is something like:
    subs <- unconstruct
    construct (map typesubst subs)

Now, ununknown is something like:
    
well, if we could ask for all the expressions in it, we could map on those, if
we could ask for all the types in it, we could replace those.

In other words, I feel like it's worth trying to use generics for this. If
it's not efficient, we'll see that and we can deal with it later. But for now,
isn't it much easier?

I should try getting more practice with generics. Let me see if I can't
convert more of the functions in my old seri to use generics.

Tue Mar 27 14:02:36 EDT 2012

No, I had tried that before. There are some things which are just plain
specific. Like, don't descend into a LamT if it introduce a new name. That
sort of thing. The sort of thing I'd rather not hardcode. It should be up to
each expression how it wants to do things.

I don't know.

Wed Mar 28 10:05:38 EDT 2012

I want to think about, or investigate more, this idea of leveraging haskell's
type system to do inference. I think my type inference is fine for my simple
lambda calculus, but it would be good in general to be able to leverage
haskell's type system.

The idea is this: we want to make it so when you write an expression in a
quoter or what have you, it is automatically type checked. That is, we will
convert it into a TH.Exp which constructs the object for you, and makes it
type correctly by construction.

The first thing we need is some type safe way to construct expressions.
Let me work on the old version to try and figure this idea out.

For example, in what sorts of ways can we build up expressions improperly
typed?

Application. That's a good example.

AppE Type Exp Exp

The function needs type a -> b, the expression type a, the application type b.

This only works, I fear, if we can associate a haskell type with each
expression. That's something I personally rather would have avoided. Or at
least separate out into a different step...

Okay, let's say I have a type like this:

data TypedExp a = TypedExp Exp

Now Exp stays how it was, but TypedExp is associated with a haskell type.

Given a TypedExp, it's trivial to extract the Exp without that type
annotation. So we can get at the raw thing. Oh, I like this.

Now how do we do apply?

-----
appE :: TypedExp (a -> b) -> TypedExp a -> TypedExp b
appE (TypedExp f) (TypedExp x) = TypedExp (AppE t f x)
-----

That's fine. But how do we figure out what 't' is?
Can we just do:

----
t = (convtype :: b)
----

I fear that won't work (though it would be good to try out).

Cool. I like this solution. Then I implement a Quoter which uses the type safe
constructions (we'll have to merge Quoter and Parser together). And we can
know the primitive types.

What if I want to introduce a primitive name? Say, foo, and I want it to be
typed as Foo -> Bar. To do this we would need a primitive function foo, of
proper type, that we know about and can use to construct. Fine, just use the
name foo. Easy. All you have to do is define the primitive version, you don't
have to describe this yucky undefined haskell version.

The key thing is, for Quoters, you don't have to typecheck before parsing,
only after. That's definitely a better solution than template haskell gives.

I'm confident we can do the translation. And splicing in and out of haskell
too.

I should work up a proof of concept for this though, just to make sure.

If it works, and it's easier than type inference, perhaps I should ditch type
inference entirely? I don't know. We'll see.

But cool. Nifty. Let me work at this right now, see if I can get anywhere.

Wed Mar 28 11:15:38 EDT 2012

Wow. This is neat. So I have type safe constructors for expressions, and we
get all the type information constructed we need as we go. Exactly as I was
hoping for.

What's the next part?

I want a type safe quoter. So it will have to do parsing directly from String
to Q Exp. Or Exp if I prefer, but I suspect Q Exp will be easier.

Shall I just duplicate the parser?

Wed Mar 28 13:13:13 EDT 2012

It works! My typed quoter works. That's really cool.

Wed Mar 28 13:51:37 EDT 2012

So I say, ditch my typechecking and type inference. I don't need it anymore.

Talked to Nirav. He suggests the following would be good to have:

- higher order stuff. That is, be able to write the program
    (id id) 5
Where id can have two different types.

- Declarations

- Better use of primitives.
Meaning, I suspect, instead of: AddE Exp Exp, we'll want something like
PrimE Type Name.

Then a primitive will be: "add", and we can elaborate based on that. Or, I
suppose, you could have a list of primitives (I think I like that better).

+ For SeriType class, have a -> Type, not TypedExp a -> Type. The way to make
  it work in haskell is, Nirav claims, something like:

constseri :: TypedExp a -> a
constseri _ = undefined

Then, (seritype r) should still work.

Okay? Good. I think I'll switch back to the specific version, and avoid this
generalization thing. With haskell for type inference, I think that becomes
easier. And perhaps if we let users define their own primitives, you can stuff
all the library stuff into primitives. That sounds better to me.

Wed Mar 28 14:22:59 EDT 2012

Cool, I like this.

I think the next step is fairly clear.

Add primitives.

So, for example, Add, Mul, Fix, True, False, Lt should all turn into
primitives.

What is PrimE?

I think it should be either a String, or a Primitive, which is just a union. I
think I prefer primitive, because it makes it much more clear what you do and
don't consider a primitive, and you can write functions in primitives. That
harder part is, perhaps, parsing primitives? Annotating the type of
primitives?

Let me start with that though. We'll want functions:

prim :: String -> Maybe Primitive
primtype :: Primitive -> TH.Type?

Wed Mar 28 15:59:11 EDT 2012

The primitives I'm using: +, -, *, etc... are special in that they are infix.
Let me deal with them specially for now. The real test should come when I turn
FixE into a primitive 'fix' function.

infix has two arguments, right? I could maybe use that to make things easier
parsing.

Wed Mar 28 16:29:11 EDT 2012

Okay, so parsing of infix primitives is clean now.

I'm a little annoyed out how clumsy it is to specify how to elaborate a
primitive expression. Perhaps that can be improved in time.

Last primitive to deal with: the 'fix' primitive.

First step: preserve my special syntax. Second step: dump the special syntax.

Wed Mar 28 16:39:06 EDT 2012

Actually, here's an idea. True and False should be made primitives. I can use
that to work out the naming thing. Then change the syntax for fix. Then try to
make fix a primitive. Let's see how that goes.

