
Sat Mar 24 08:21:35 EDT 2012

I want to give seri another shot, for the fun of it. But also as something
potentially useful. It's strange how I keep going around in full circles, and
I did a full circle away from seri and now back again.

But let me see if I can't make it rather cleaner this time around.

What's the goal?

We want the following:

- An intermediate representation for describing seri programs.
This will consist of expressions, types, perhaps modules.
My vision is to have an IR which is described in such a way that you can pick
and choose just the pieces you want to use, and it's extensible, so you can
add in things for where you want to use it. So it's not specific to my
language, but should, for example, work for a lambda calculus that Nirav wants
for SMT, work for BCL, for Structural Spec, and all seri all at once, but in a
clean way.

- C code generation of IR.
To separate things out, have a C IR for describing a C program in haskell. Or
C++ or both or something like that. Then have conversion from the seri IR to
that C ir, and have that C ir support pretty printing.

- BSV code generation of IR.
Analogous to the C code generation: we have a BSV IR we can translate to, then
pretty print to get working bluespec.

- Haskell code generation of IR.
Just convert to haskell's existing IR, and pretty print that.

- Haskell Interpreter for IR.
Aka: Static elaborator of IR.

- Clean front end.
This could be hard. What I want is this: I want to be able to describe
programs in haskell, using the full generality and abstractions haskell
provides. I want to generate from them a monomorphic, simple seri IR.

This might involve having a parser, or some translation to/from template
haskell. Important things: we want to leverage the abstractions of haskell. We
want to pass meaningful names into the IR from the front end. We want to have
types checked properly. It should not be messy yucky to write.


I think, perhaps, the first step would be to come up with a simple lambda IR.
Have booleans and integers and tuples, or whatever seri has.

Start writing the C or C++ and BSV IRs (which are completely separate modules
which can be reused elsewhere, which is really nice).

Once I have that baseline, then play with it to try and find good ways of
making the IR extensible and making the front end nice the way I really want
it to be.

Cool. This sounds like fun. Let me get started after breakfast.

Sat Mar 24 08:46:22 EDT 2012

First step: define my base language. My simple ir.

Types:
  Unit, Integer, Bool, Tuple, Function

Expressions:
  Unit, Integer, Boolean, Tuple,
  Add, Mul, Sub, Eq, Lt, If, Fst, Snd
  App, Lam, Fix

I'm not sure I like using Fix for recursive functions, but I can fix that
later. This will be enough of a start for factorial.

Sat Mar 24 08:57:49 EDT 2012

Okay, so I've defined my language.

The next thing to do is write a simple program in it.

Let's not start with a recursive program just yet.
In fact, let me get rid of Fix, because I don't want to start with a recursive
program.

First expression...

(\x -> x*x + 3*x + 2) 5

Sat Mar 24 09:26:00 EDT 2012

Nifty! It works.

What's the next step, do you think?

I think it would be nice to pretty print the expression. This is different
from Show.

Let me do that, then brainstorm what the next steps should be. I think it
probably makes sense to try and get all the parts of my goal in a nice way for
the simplest version of the IR, so I'm not rewriting so much code as I try
different things.

So, perhaps the first thing to get done are the basics:

+ pretty print seri
+ generate C from seri
x generate BSV from seri
+ generate Haskell from seri
- have a nice front end
- make seri extensible

The last two points will be hard, but very important. They are really the meat
of what I want to do. So work on them, see what I can come up with. Add more
to seri if I need to demonstrate the issues I'm worried about. And so on.

Okay, cool. I have something to work on now.

Sat Mar 24 10:14:10 EDT 2012

I did the printing. It works fine, it's just riddled with parentheses I'd like
to get rid of if I could.

The question is, what precedence do I want?

(\x -> x*x + 3*x + 2) 5

lam, +, *, app


Sat Mar 24 10:22:57 EDT 2012

Okay, That works well enough.

Next step?

Convert to haskell... done.

Next?

I think, either C or BSV back end?

The concern is how to do anonymous functions in those.
Perhaps, instead, I have to give each anonymous function a name?

Let me do a simple C ir. Just enough of what I need. Just to have something
more than haskell, something where types aren't inferred automatically. No
need to support bsv yet.

What do I need for C?

(\x = x*x + 3*x + 2) 5

Should become something like:

int l1(int x)
{
    return x*x + 3*x + 2;
}

l1(5)

So...

Dec = FunD Name [(Type Name)] Type [Stmt]
Stmt = ReturnS Exp
Exp = Int | Mul | Add

Let me stick to C for now. I don't anticipate needing C++ for my explorations.
    
Okay, last thing I need before playing with front end: the C code generation.

I'll want to use a monad, because an expression could return a bunch of
declarations as well.

Okay, good. That works.

Next step: a nice front end.

Sat Mar 24 11:21:46 EDT 2012

This part is going to take some thought, and experiment.

What are my requirements?

A. Assume user knows haskell
B. Haskell code should be easily incorporated into front end code for static
  elaboration.
C. Names used in front end should be preserved in the ir
D. It should be nice to write programs.
For example: writing in the IR is NOT nice. We want to use syntax.
E. Type checking must be done somewhere.
F. ? Error messages should be interpretable

Let's walk through some possible ideas, and evaluate them under the above
requirements.

Write in IR directly
--------------------
This is what I've been testing so far.
B. Good. We can easily generate code from haskell.
C. Good. Because the names are one and the same.
D. Terrible. Horrific.
E. We could add a step to check your types are consistent fairly easily,
right? A simple type check (not type inference).
F. We wouldn't have line numbers for type errors. Haskell will catch other
errors in its type system just fine.

Write a parser for the IR
-------------------------
B. Not good initially. Perhaps some extra work could let you inline haskell
fairly easily. This is worth looking into.
C. Good. Names transfer easily.
D. Good. We get just the syntax we want.
E. Don't know. How hard would type inference be? Perhaps we could require type
annotations? But that would make it more annoying to write programs in.
F. We could pass through line numbers, so this is fine.

Translate from Haskell using Template Haskell
---------------------------------------------
B. Good.
C. Good.
D. Okay. It's not clear how easy it will be to add custom primitives and such.
E. Haskell does the Type checking. We may need to infer types.
F. We wouldn't have line numbers.

Translate from Haskell using Quasi Quoting
------------------------------------------
This is like having our own parser, with haskell type checking.


So, there are some questions I think it's worth exploring before deciding on
theses.

1. How hard is it to write a type checker.
So, given a Seri Ir, just return whether or not it types correctly, and
ideally a nice message if it doesn't as to why it doesn't.

2. How hard is it to write type inference?
So, given a Seri Ir, assuming no type annotations, how hard to figure out what
the types should be?

If the primitives are all explicitly typed, that's fine. But what I suspect we
would want is overloading. So, given '+', how do we know what type to use for
it? Can that be inferred?

Do we support polymorphism? Or does every function have a concrete type? So
length of list of Integer is a different function than length of list of
Boolean, and so on?

3. How could we incorporate abstractions of haskell into the front end?
Can you have some sort of $ substitution, or something like that?


I'm afraid some of these depend on language features. They may be easy to do
now, but adding some language feature could suddenly make it much harder.

Anyway, let me investigate these questions and see what comes out of it.

Sat Mar 24 12:15:43 EDT 2012

Checking the types are consistent, given the types, is not hard.
If I had line number information, I could give pretty decent error messages
too I think.

What do I have to do for type inference?

Well, you have to give some types.

I wonder if SMT could do this for me. I just ask: does there exist a
consistent typing for this expression? If so, give me evidence. And then I
could ask if there were others as well. If there is exactly 1, then we are all
set. If less, it's not well typed. If more, it's ambiguous.

I don't think SMT will give me very good error messages though.

What would type inference look like for me?

The things you infer types for are:

Applications. Just take the return type of function.
Lambda - based on type of the variables and type of the expression
    The names could be inconsistent
Variables - based on the type of the lambda.

So you would need to give information about either the variables, or the
lambdas. Otherwise it could be ambiguous. We need to make sure all the uses of
the variable have the same type.

I feel like, if we don't have polymorphism, then it's easy. If we don't have
typeclass or overloading, then it's easy.

If I were to do this, I would want another kind of type. An Unknown type, or
some such, to distinguish between those types I know and those I don't.

I'm pretty confident I could do type checking of this simple IR. I think it
could get much more difficult when I make it a more realistic IR.

Let me skip now to question (3). I'll take an initial look, then think about
it over lunch.

How could we easily integrate haskell into the front end?

I need an example. A concrete example to work with...

Okay, so here's an example...

I wonder if my language is too simple right now.

What I want is something where you have a list of statements you want to
write, using haskell. Or, when you want to compute a number statically with a
haskell function. That's good. Let me start with that.

So I have some language, where say foo is in the IR, but bar is something we
want to evaluate statically. Either in haskell, or in the IR?

    foo x + (bar 24.5)

Here we don't know to do bar in haskell. The proposal then would be something
like:

    foo x + $(bar 24.5)

Says, evaluate $(e) as a haskell expression.

There are a couple of cases. First case: the haskell expression returns a
haskell value, and we require you have a way to convert that haskell value to
a seri value. Second case, which I guess is a special case, is that haskell
function returns a seri object directly.

So let me propose the general case first. We say any expression... or anything
really (?) in our front end can be described using $(...) which statically
evaluates haskell code, as long as that haskell code can be transformed into
the kind of object we are expecting.

I would love it if there were some way I could convert haskell template code
into a pure haskell object, then possibly translate that into my language.

This is perhaps doable. You could imagine something like:
   $($(toseri [e| \x -> x+2 |]))

Unfortunately the $() is being overloaded here. The outside is meant to be let
me do haskell, the inside one is meant to be template haskell's splice, where
toseri goes from template haskell Exp to a Q Exp which is of type Seri IR,
which can then trivially be converted to Seri IR. So that's something we could
do. Not sure how useful it would be.

I should consider too how I intend to parse and execute haskell code
statically.

The other thing I may want to do is manipulate seri constructs in haskell.

So, something like,
  Say x is a variable in Seri front end in scope, or whatever...

I guess what I'm saying, is I want a way to input a nice front end string, and
turn it into a haskell seri object, which I can then pass to a haskell
function, which gives me back a new haskell seri object, which I can then
splice into seri front end again.

So, I guess I need two things.

We have the notion of a front end context. Not sure how I want to do that just
yet. I'm leaning towards quasi quoting at this point.

1. Inside a front end context, I want a splice, which lets me run arbitrary
haskell code, if that code returns a value we can turn into a seri object.

2. I want a way to convert a front end context into haskell code, which can
then be passed to haskell functions.

For example, let's say this is pure haskell code. I could do things like:

----------
foo :: Seri.Exp
foo = [seri| (\x -> x*x + 3*x + 2) 5 |]

three :: Integer
three = 3

bar :: Seri.Exp
bar = [seri| (\x -> x*x + $(three)*x + 2) 5 |]

sludge :: Seri.Exp
sludge = [seri| (\x -> $(muln 2 [seri| x |]) + 3*2) 5|]
----------

And, I thus hypothesize this is all the integration I need to do all the nice
static elaboration I want. Though I'm not at all convinced of this. I think
the best way to test that is through practice and trying to write real
programs in Seri, leveraging haskell as much as I can.

Cool! So, let me have some lunch, come back, and understand if quasi quoting
will give me everything I want, and if so, how specifically it looks.

Sat Mar 24 13:13:39 EDT 2012

Oh boy. So this is exciting.

The concerns with this method, over say, BCL's front end, are:
1. How much work is it to do type checking and inference
2. How much work is it to write a parser
3. How hard is it to get reasonable error messages?

Let me look at quasiquoting now.

Hmm...

So I provide a quoter. Let's just look at the expression context for now.

I provide a function: String -> Q Exp.

Then, [s| ... |]  just calls the function to get back the Q Exp.

Now then, here's how this would work.

Let me define my own slice notation, to avoid confusion. In my seri language,
let's say a splice is... inside: @(...).

I implement a quasiquoter s. It parses the string, and returns a Q Exp, where
the Exp describes a Seri.Exp.

Now the examples look as follows:


----------
foo :: Seri.Exp
foo = $([s| (\x -> x*x + 3*x + 2) 5 |])

three :: Integer
three = 3

bar :: Seri.Exp
bar = $([s| (\x -> x*x + @(three)*x + 2) 5 |])

sludge :: Seri.Exp
sludge = $([s| (\x -> @(muln 2 $([s| x |]) + 3*2) 5|])
----------

Fine. The real question is, how do I do the @() splice? How do I implement it?

Well, I need a haskell expression parser. I parse the expression into a QExp
(I'm in the Q monad, so that's fine). Then I have an Exp in haskell, I wrap it
in, say, an AppE toseri foo, where foo is that expression. When the quote
returns, template haskell will evaluate that application, evaluate foo, do the
conversion, and give me the result. Here toseri has type a -> Seri.Exp, for
some haskell type a (we'll want a typeclass for haskell things you can lift
into Seri.Exp).

The other slight issue is nesting of [s|...|]. I'll have to add a way to
escape.

What type checking do we get? Your haskell code will be typechecked and run.
The seri code we'll have to type check.

Okay? 

I think quasiquoting is a better idea than parsing from strings, just because
it makes it that much easier to embed in haskell. We can still read from
files too, using the same thing. This way we get type checking of the haskell
code for free.

I'm not sure about line numbers, but I could certainly keep track of them
myself as I parse the string. So you get a line number relative to a slice,
and presumably haskell tells you the line of the slice that failed.

We don't use a DSEL, or the type checking we could get from that.

That's interesting. Perhaps we could have an intermediate DSEL, it gives us
the type info we want, still use quasiquoting, then we leverage haskell's type
system.

That's an idea. Let me try not doing that first, and reconsider it when type
inference starts causing me problems.

Cool. I'm going to take a walk, then start getting to the nitty gritty, to see
if I can make this work.

Sat Mar 24 14:01:36 EDT 2012

Here are the steps.

1. Write a parsec (3) parser for Seri.Exp.

parse :: String -> m Seri.Exp.

To test: parse the foo expression.

2. Implement lifting of Seri.Exp to TH.Exp

This should give me a quasiquoter for seri.

To test: write down foo as [s| ... |].

Not sure what this adds at this point...

3. Add support for slices in the front end.

This may require finding or implementing a haskell expression parser.

This is where using quasiquoting becomes important.

Try the bar test.

I don't imagine I'll get this far today, so let me stop the list there, and
start working.

First step, a parsec parser for Seri.Exp.

Sat Mar 24 15:02:04 EDT 2012

Okay! I have a parser. It's picky about whitespace, but it's enough of what I
want right now.

Sat Mar 24 16:16:35 EDT 2012

Next step: quasiquoting.

I can tell you at least one benefit of this. Maybe two.
1. Don't have to escape backsash.
2. vim will syntax highlight the contents of the string.
Now, admittedly it will use haskell syntax, but I could always add to vim an
escape to do specialized syntax highlighting for the quasiquote.

Little things, but let's see how it goes.

First step: lifting a Seri.Exp into TH.Exp. I wonder if there is a typeclass
for this already I could use?

Yes! There is. In Language.Haskell.TH.Syntax, called Lift.

Except... err... it would be Seri.Exp -> QExp. Is that okay?

Look, I can provide the pure version too. The lift instance will just be to
return that. Fine.

Sat Mar 24 16:30:15 EDT 2012

If what I'm doing will work, it will be much easier to lift into Q Exp than
Exp. Just wrap everything in th brackets. Let's see if it works.

How to test...

I suppose the way to test is to make a quoter, and see if it works.

Sat Mar 24 16:46:48 EDT 2012

It works! A slight difference than what I expected: the quoted thing returns
that thing directly, not a Q Exp. But that's fine with me.

Cool! Next step... slices.

Now then... how do I want to go about doing this?

I can parse everything between @(...) into a single string, with matched
parenthesis. Now I have a string.

How about I add an expression type to Seri (I wince a little at this thought,
but I'll clean things up later as needed), which is that Seri can have an
expression which is a THQExp.

Now all I need are two things.

1. Add that to the lift instance. Which is trivial, right?
2. Find a haskell parser to convert String into Q Exp.

The second point is just a little harder. Let's see what there is out there.

Looks like: Language.Haskell.Meta.QQ.Hs has hs quasiquoter for haskell, which
is just what I want.

So then, this should be simple.


1. Add Q Exp as a kind of seri expression.
2. Figure out how to parse the string @(...), with nested parens.
And also, probably want to escape |] at some point. But don't worry about that
now.
3. Use hs quasiquoter to convert String to Q Exp.
4. Implement lifting.

Or whatever. There's nothing big here. It should all work swell.

But! I should go eat dinner first.

Sat Mar 24 18:02:24 EDT 2012

It works! Haskell slices work just swell. That's awesome.

Currently the slice has to return a Seri.Exp. It might be nice if it can
return any arbitrary haskell value that can be converted to a Seri.Exp.

That should be simple to do. I just need to introduce a typeclass.

Cool.

Sat Mar 24 20:09:50 EDT 2012

Now then, what should I call this typeclass?

Seriable? Sounds too much like Serializable?
Seriable and seriize. Err...

Seriable seriate. Good.

Sat Mar 24 20:16:42 EDT 2012

That works nicely.

What remains to do now?

From my list above, I just want to try nested quotes. I think it will require
escape characters to make work.

Yup, nesting needs to be escaped.
I can escape it with...
Uh... "|~]" how about?


You know what? We don't need nested quotes. I can always say
 let x = [s| ... |]
 in [s| ... @(x) ... |]

And that's just fine with me. The issue is, we would run into double nesting
issues, triple nesting, and so on. It's just not worth the effort to deal
with.

Okay! Cool.

What's left?

The big thing missing now is just type inference. Because I really can't do
type inference in the parser. Can I? Can I just have explicit types?

Well, we would like some explicit types, and some type inference.

I think, give me type inference. And it can be sloppy. Infer types, then run
typecheck on the inferred types. Hopefully that's easier than trying to do it
all at once.

I'm a little worried about error messages and line numbers, but ... don't
worry about that just yet.

How can I do type inference?

I feel like I tried this before with drizzt, or whatever language I had. And
it was messy.

Let's assume no polymorphism for now.

Conceptually you can assign a type variable to each unknown type, and come up
with a bunch of constraints.

Can I use an SMT solver for this? That would certainly be cool...

Is it worth trying to do in yices manually?

For example, how would I typecheck qbar?

AppE A (LamE B "x" (AddE (AddE (MulE (VarE C "x")
(VarE D "x")) (MulE (IntegerE 4) (VarE E "x"))) (IntegerE 2)))
(IntegerE 5)
 

Variables: A, B, C, D, E.

Constraints:

B = ArrowT F G  -- function in apply must have ArrowT type
A = G           -- type of apply is return type of function
F = C           -- type of variable is same as input to lambda
F = D
F = E


Hmm... Maybe it makes sense to combine this with type check.

I come up with a set of constraints of these forms, introducing variables as
needed.

Then I ought to be able to use SMT or something to solve this, right?

Come up with a set of constraints, then try to solve.

Let me alter the typecheck function...

No, let me write another function, which given an expression, returns a set of
constraints. Where each constraint is of the form (Type, Type). And we add
VarT as a type. We'll have a state monad to collect constraints, and a counter
to keep track of free variable types.

I'll run this, print out what it gives for my expression, make sure it looks
right, then see if I can solve that with yices.

Err... I really hate to have to go to IO to do typecheck.
Could I not implement a constraint solver?

Well, let's see what I can do with the constraints.

Here are the constraints I generated for Q Sludge.
 
V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
ArrowT V5 V6 = V1
IntegerT = ,IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

What do we see? Clearly I have my types wrong, because this is not
satisfiable. Let me go fix my bugs.

V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
ArrowT V5 V6 = V1
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

Now if I solve this by hand, I get...

V0 = V8
V1 = IntegerT V6
V2 = IntegerT
V3 = IntegerT
V4 = IntegerT
V5 = IntegerT
V6 = V8
V7 = IntegerT

Hm... We don't have all the info we need.

Let me print the expression out too.

(AppE (VarT 0) (LamE IntegerT "x" (AddE (AddE (MulE (VarE IntegerT "x") (VarE
IntegerT "x")) (MulE (IntegerE 3) (VarE IntegerT "x"))) (IntegerE 2)))
(IntegerE 5),

I'm missing a constraint. One that says the type of an application is the
output type of the function called?

Okay, I see what I missed. Now let's see.

(AppE (VarT 0) (LamE (VarT 1) "x" (AddE (AddE (MulE (VarE (VarT 2) "x") (VarE
(VarT 3) "x")) (MulE (IntegerE 3) (VarE (VarT 4) "x"))) (IntegerE 2)))
(IntegerE 5),

V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
V6 = IntegerT
ArrowT V5 V6 = V1
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

If I solve it manually, I get:

V0 = IntegerT
V1 = ArrowT IntegerT IntegerT
V2 = IntegerT
V3 = IntegerT
V4 = IntegerT
V5 = IntegerT
V6 = IntegerT
V7 = IntegerT
V8 = IntegerT

Perfect. Just what we want.

Now, I think it would be good practice to try asking this question to the SMT
solver, yices. I'll do that tomorrow morning.

My question to you is, is there a systematic way to solve this system of
equations? Can I do variable elimination? In some order?

Perhaps I can eliminate constraints?

X = X  - drop the constraint, because it's trivial.
ArrowT X Y = ArrowT W Z  - replace with X = W, Y = Z
X = Y - If we can give priority to types, say smaller types have higher
priority than larger types, we could say, substitute every occurence of Y with
X, recording that Y is Y.

Repeat until we reach some sort of fixed point?

Let me try it.

V7 = IntegerT
V8 = V0
V1 = ArrowT IntegerT V0
V5 = V4
V4 = V3
V3 = V2
V6 = IntegerT
V2 = IntegerT
V0 = IntegerT

We make pretty good progress after one round, but now what? Another round
isn't going to help any.

Maybe I have to replace all of them?
Let me try that.

So we say the following: you may only replace a variable with a better known
variable. That should finish us. Let me try it.


V7 = IntegerT
V8 = IntegerT
V1 = ArrowT IntegerT IntegerT
V5 = IntegerT
V4 = IntegerT
V3 = IntegerT
V6 = IntegerT
V2 = IntegerT
V0 = IntegerT

Wow. Well, that works pretty well here.

Perhaps there is some fixed point thing or something. It would be nice to try
and prove in coq or some such.

The idea is this. We order expressions from best known to least known.

Whenever you encounter the constraint: X = Y, flip it so that whatever is on
the left is the last known. Call that X. Then, replace every other occurrence
of X in all other constraints with Y. You have just made things better known
overall.

Ignore constraints of the form X = X
Fail at constraints of the form X = Y where X and Y are known but don't match.
Reduce constraints of the form ArrowT A B = ArrowT C D to two simpler
constraints: A = C, B = D.

The hpothesis is, running this algorithm will leave you with an association
list mapping unknown types to known types. Just look up your type variable in
the list, it will tell you, as best it can, what the type of that is.

Well, it's late enough I need to call it a day.

Here's the plan for tomorrow.

+ Implement my proposed type constraint solving algorithm.
+ Combine that with the constraint generation to do type inference.
- Try using yices to solve the above constraint problem.
Mostly just for practice with yices. I don't actually want to use it in my
compiler because I don't want to have to go to IO. It will be good to have
confidence that I can use an SMT solver if things start getting messy though.

At this point, I should have a full front end, parser, type inference, type
checker (if not subsumed by type inference, it might be nice to have type
checker to make it easier to figure out type errors), elaborator, pretty
printer, haskell generator, c generator.

- Reorganize code into something nice.
- Write up HUnit test cases.
- Expand Seri to support factorial function with fix operator.

This should give me a feel for things. At this point, I think I'll have enough
to go on to try and understand extensibility. I'd like to answer questions
such as:
* Can we augment the IR with unknown type just for parsing?
* Can we augment the IR with variable types just for type checking?
* Can we augment the IR with source pos info for parsing and type checking?
* Can we separate primitives out of IR in a nice way? 

If this is not enough to go on, then continue to expand the IR until it
supports everything I want for tibby. See if I can describe QR in my IR, how
nice it is, if it all works, and then try to compile to C, BSV, and Fiddler.

That's really the ultimate for this project. If I can do QR in those
languages, them I'm ready to roll.

Sun Mar 25 06:48:06 EDT 2012

First step: implement my type constraint solver.

Well, it seems to have worked on my simple example. We shall see if it works
in general.

Next step: make type inference much nicer.

Here's how it should work.

1. UnUnknown expression
2. Generate type constraints
3. Solve type constraints
4. apply solution

Let's allow the user to do typecheck separately from inference.
And we just say, well, inference may not return a correct result, so you
should probably check the solution it gets.

Sun Mar 25 07:37:56 EDT 2012

I don't feel much like playing with yices right now.

Let me instead move on to code cleanup.

I'll start by looking at the code, proposing a solution. Then I'll take a
break for breakfast, come back, and clean stuff up.

Proposed hierarchy:

C - ir, ppr
Seri - Seri.IR, Seri.Elaborate, Seri.Parser, Seri.Quoter, Seri.TypeCheck, Seri.TypeInfer
Seri.IR - ir, typeof, ppr
Seri.Elaborate elaborate
Seri.Parser parser
Seri.Quoter quoter, thlift
Seri.TypeCheck typecheck
Seri.TypeInfer typeinfer
Seri.Backend.C
Seri.Backend.Haskell

I think that will make for a nice structure, and clean sharing, and such like.

And we should have test cases for everything.
Let each module define its own tests? Yes, as HUnit.

Good. This will be nice to do.

