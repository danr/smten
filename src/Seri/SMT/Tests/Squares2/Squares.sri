
module Seri.SMT.Tests.Squares2.Squares where {

import Seri.Lib.Prelude;
import Seri.Lib.Bit;
import Seri.SMT.SMT;

import Seri.SMT.Tests.Squares2.Prelude;
import Seri.SMT.Tests.Squares2.Reg;
import Seri.SMT.Tests.Squares2.FIFO2;

-- Lambda Calculus description for the following bluespec module.
-- Generates the sequence of squares: 1, 4, 9, 16, ...
-- module mkSquares
--   Reg#(Bit#(32)) odds <- mkReg(1)
--   Reg#(Bit#(32)) squares <- mkReg(0)
-- 
--   FIFO#(Bit#(32)) pipeQ <- mkFIFO()
-- 
--   rule produce
--     pipeQ.enq(odds)
--     odds <= odds + 2
-- 
--   rule consume
--     squares <= pipeQ.first() + squares
--     pipeQ.deq()

data MOD_mkSquares = MOD_mkSquares {
  inst_odds :: MOD_mkReg (Bit #32),
  inst_squares :: MOD_mkReg (Bit #32),
  inst_pipeQ :: MOD_mkFIFO (Bit #32)
} deriving (Eq);

on_odds :: Action (MOD_mkReg (Bit #32)) a -> Action MOD_mkSquares a;
on_odds = liftA inst_odds __inst_odds_update;

on_squares :: Action (MOD_mkReg (Bit #32)) a -> Action MOD_mkSquares a;
on_squares = liftA inst_squares __inst_squares_update;

on_pipeQ :: Action (MOD_mkFIFO (Bit #32)) a -> Action MOD_mkSquares a;
on_pipeQ = liftA inst_pipeQ __inst_pipeQ_update;

instance State MOD_mkSquares where {
  newState (MOD_mkSquares odds1 squares1 pipeQ1)
    = let {
        odds = newState odds1;
        squares = newState squares1;
        pipeQ = newState pipeQ1;
      } in MOD_mkSquares odds squares pipeQ;

  parMerge (MOD_mkSquares odds1 squares1 pipeQ1) (MOD_mkSquares odds2 squares2 pipeQ2)
    = do {
        odds <- parMerge odds1 odds2;
        squares <- parMerge squares1 squares2;
        pipeQ <- parMerge pipeQ1 pipeQ2;
        return (MOD_mkSquares odds squares pipeQ);
    };

  seqMerge (MOD_mkSquares odds1 squares1 pipeQ1) (MOD_mkSquares odds2 squares2 pipeQ2)
    = let {
        odds = seqMerge odds1 odds2;
        squares = seqMerge squares1 squares2;
        pipeQ = seqMerge pipeQ1 pipeQ2;
      } in MOD_mkSquares odds squares pipeQ;
};

ctor_mkSquares :: MOD_mkSquares;
ctor_mkSquares =
  MOD_mkSquares {
    inst_odds = ctor_mkReg 1,
    inst_squares = ctor_mkReg 0,
    inst_pipeQ = ctor_mkFIFO
  };

rule_RL_produce_mkSquares :: Action MOD_mkSquares ();
rule_RL_produce_mkSquares = do {
  v1 <- on_odds meth_read_mkReg;
  on_pipeQ $ meth_enq_mkFIFO v1;
  on_odds $ meth_write_mkReg (v1 + 2);
};

rule_RL_consume_mkSquares :: Action MOD_mkSquares ();
rule_RL_consume_mkSquares = do {
   v1 <- on_pipeQ meth_first_mkFIFO;
   v2 <- on_squares meth_read_mkReg;
   on_squares $ meth_write_mkReg (v1 + v2);
   on_pipeQ $ meth_deq_mkFIFO;
};

-- Some rule sequences.
p :: Action MOD_mkSquares ();
p = rule_RL_produce_mkSquares;

c :: Action MOD_mkSquares ();
c = rule_RL_consume_mkSquares;

pc :: Action MOD_mkSquares ();
pc = p <$> c;

ppc :: Action MOD_mkSquares ();
ppc = seq [p, p, c];

pcp :: Action MOD_mkSquares ();
pcp = seq [p, c, p];

main :: Query (Answer MOD_mkSquares);
main = not_mutually_exclusive p c;

}

