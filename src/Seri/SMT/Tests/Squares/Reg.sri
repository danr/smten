
module Seri.SMT.Tests.Squares.Reg where {

import Seri.Lib.Prelude;
import Seri.SMT.Tests.Squares.Prelude;

data MOD_mkReg a = MOD_mkReg {
   modified :: Bool,
   value :: a
};

instance State (MOD_mkReg a) where {
    newState r = r { modified = False };

    parMerge a b =
      let {
        g = not (modified a && modified b);
        s = if (modified a) then a else b;
      } in (g, s);

    seqMerge a b = if modified b then b else a;
};

instance (Eq a) => Eq (MOD_mkReg a) where {
    (==) a b = (value a == value b);
    (/=) a b = not (a == b);
};

ctor_mkReg :: a -> MOD_mkReg a;
ctor_mkReg v = MOD_mkReg False v;

meth_read_mkReg :: MOD_mkReg a -> (Bool, MOD_mkReg a, a);
meth_read_mkReg r = (True, r, value r);

meth_write_mkReg :: MOD_mkReg a -> a -> (Bool, MOD_mkReg a);
meth_write_mkReg r v = (True, r { modified = True, value = v});

}

