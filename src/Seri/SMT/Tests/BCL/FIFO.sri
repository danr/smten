
module Seri.SMT.Tests.BCL.FIFO where {

import Seri.Lib.Prelude;
import Seri.SMT.Array;

data FIFO a = FIFO{ max_cnt :: Integer
                  , enq_idx :: Integer
                  , deq_idx :: Integer
                  , arr     :: (Integer -> a)
                  , mod_enq :: Bool
                  , mod_deq :: Bool };


notEmpty_val_FIFO_a :: FIFO a -> Bool;
notEmpty_val_FIFO_a fifo = (enq_idx fifo) /= (deq_idx fifo);

notFull_val_FIFO_a :: FIFO a -> Bool; 
notFull_val_FIFO_a fifo = let {
                     ei = enq_idx fifo;
                     ma = max_cnt fifo;
                     di = deq_idx fifo;
                   } in if (ei == ma) then (di /= 0) else (di /= (ei + 1));
    
first_val_FIFO_a :: FIFO a -> a;
first_val_FIFO_a fifo = (arr fifo) (deq_idx fifo);

clear_FIFO_a :: FIFO a ->  (Bool, FIFO a, ());
clear_FIFO_a fifo = (True, fifo{enq_idx=0,deq_idx=0}, ());

deq_FIFO_a :: FIFO a ->  (Bool, FIFO a, ());
deq_FIFO_a fifo = let {
             di = deq_idx fifo;
             ma = max_cnt fifo;
             new_di = if (di == ma) then 0 else (di + 1);
           } in (notEmpty_val_FIFO_a fifo, fifo{deq_idx=new_di,mod_deq=True}, ());

enq_FIFO_a :: a -> FIFO a -> (Bool, FIFO a, ()); 
enq_FIFO_a x fifo = let {
               ei = enq_idx fifo;
               ma = max_cnt fifo;
               ar = arr fifo; 
               new_ei = if (ei == ma) then 0 else (ei + 1);
               new_ar = update ar ei x
             } in  (notFull_val_FIFO_a fifo, fifo{enq_idx=new_ei,arr=new_ar,mod_enq=True}, ());
 

first_guard_FIFO_a :: FIFO a -> Bool;
first_guard_FIFO_a fifo = True;

notFull_guard_FIFO_a :: FIFO a -> Bool;
notFull_guard_FIFO_a fifo = True;

notEmpty_guard_FIFO_a :: FIFO a -> Bool;
notEmpty_guard_FIFO_a fifo = True;

merge_p_FIFO_a :: FIFO a -> FIFO a -> FIFO a;
merge_p_FIFO_a a b = let {
                enq_f = if (mod_enq a) then a else b;
                deq_f = if (mod_deq b) then b else a;
                di = deq_idx deq_f;
              } in enq_f{deq_idx=di,mod_deq=(mod_deq deq_f)};

count_FIFO_a :: FIFO a -> Integer;
count_FIFO_a fifo = let {
               ei = enq_idx fifo;
               di = deq_idx fifo;
               ma = max_cnt fifo;
             } in if (ei < di) then  (((ma + 1) - di) + ei) else (ei - di);

sub_FIFO_a :: FIFO a -> Integer -> a;
sub_FIFO_a fifo idx = let {
                 ma = max_cnt fifo;
                 sum = (deq_idx fifo) + idx;
                 off = if (sum > ma) then ((sum - ma) - 1) else sum;
               } in  (arr fifo) off;

eq_FIFO_a :: (Eq a) => FIFO a -> FIFO a -> Bool;
eq_FIFO_a a b = let {
           a_cnt = count_FIFO_a a;
           b_cnt = count_FIFO_a b;
         } in  (((max_cnt a) == (max_cnt b)) && 
	        ((a_cnt == b_cnt) &&
	         ((if (a_cnt > 0) then ((sub_FIFO_a a 0) == (sub_FIFO_a b 0)) else True) &&
	          ((if (a_cnt > 1) then ((sub_FIFO_a a 1) == (sub_FIFO_a b 1)) else True) &&
	           (if (a_cnt > 2) then ((sub_FIFO_a a 2) == (sub_FIFO_a b 2)) else True)))));

class DefaultValue a where {
  defaultValue :: a;
};

instance DefaultValue Integer where{
  defaultValue = 0;
};

instance (Eq a) => Eq (FIFO a) where {
  (==) a b = (max_cnt a == max_cnt b) && 
             ((enq_idx a == enq_idx b) &&
              ((deq_idx a == deq_idx b) &&
               ((mod_enq a == mod_enq b) &&
                ((mod_deq a == mod_deq b)))));
  (/=) a b = not (a == b);
};

ctor_FIFO_a :: (DefaultValue a) => Integer -> FIFO Integer;
ctor_FIFO_a sz = FIFO sz  0  0  (\x -> defaultValue) False False;

clear_dirty_bits_FIFO_a :: FIFO a -> FIFO a;
clear_dirty_bits_FIFO_a a = FIFO (max_cnt a) (enq_idx a) (deq_idx a) (arr a) False False;

dimension_FIFO_a :: FIFO a -> FIFO a -> Bool;
dimension_FIFO_a conc free = (((max_cnt conc) == (max_cnt free)) &&
                       ((not ((enq_idx conc) < 0)) &&
                        ((not ((enq_idx conc) > (max_cnt conc))) &&
                         ((not ((deq_idx conc) < 0)) &&
                          ((not ((deq_idx conc) > (max_cnt conc))) &&
                           ((not ((enq_idx free) < 0)) &&
                            ((not ((enq_idx free) > (max_cnt free))) &&
                             ((not ((deq_idx free) < 0)) &&
                              (not ((deq_idx free) > (max_cnt free)))))))))));







mkUGSizedFIFOF__FIFO__Int_32_ctor :: Integer -> FIFO Integer;
mkUGSizedFIFOF__FIFO__Int_32_ctor sz = FIFO sz 0 0 (\x -> 0) False False;

mkUGSizedFIFOF__FIFO__Int_32_clear_dirty_bits :: FIFO Integer -> FIFO Integer;
mkUGSizedFIFOF__FIFO__Int_32_clear_dirty_bits a = clear_dirty_bits_FIFO_a a;

mkUGSizedFIFOF__FIFO__Int_32_idfn :: FIFO Integer -> FIFO Integer;
mkUGSizedFIFOF__FIFO__Int_32_idfn a = a;

mkUGSizedFIFOF__FIFO__Int_32_dimension :: FIFO Integer -> FIFO Integer -> Bool;
mkUGSizedFIFOF__FIFO__Int_32_dimension = dimension_FIFO_a;

mkUGSizedFIFOF__FIFO__Int_32_eq :: FIFO Integer -> FIFO Integer -> Bool;
mkUGSizedFIFOF__FIFO__Int_32_eq = eq_FIFO_a;


notEmpty_val_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> Bool;
notEmpty_val_mkUGSizedFIFOF__FIFO__Int_32 = notEmpty_val_FIFO_a;

notFull_val_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> Bool;
notFull_val_mkUGSizedFIFOF__FIFO__Int_32 = notFull_val_FIFO_a;

notEmpty_guard_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> Bool;
notEmpty_guard_mkUGSizedFIFOF__FIFO__Int_32 = notEmpty_guard_FIFO_a;

notFull_guard_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> Bool;
notFull_guard_mkUGSizedFIFOF__FIFO__Int_32 = notFull_guard_FIFO_a;

clear_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> (Bool, FIFO Integer, ());
clear_mkUGSizedFIFOF__FIFO__Int_32 = clear_FIFO_a;

first_val_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> Integer;
first_val_mkUGSizedFIFOF__FIFO__Int_32 = first_val_FIFO_a;

first_guard_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> Bool;
first_guard_mkUGSizedFIFOF__FIFO__Int_32 = first_guard_FIFO_a;

deq_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> (Bool, FIFO Integer, ());
deq_mkUGSizedFIFOF__FIFO__Int_32 = deq_FIFO_a;

enq_mkUGSizedFIFOF__FIFO__Int_32 :: Integer -> FIFO Integer -> (Bool, FIFO Integer, ());
enq_mkUGSizedFIFOF__FIFO__Int_32 = enq_FIFO_a;

merge_p_mkUGSizedFIFOF__FIFO__Int_32 :: FIFO Integer -> FIFO Integer -> FIFO Integer;
merge_p_mkUGSizedFIFOF__FIFO__Int_32 = merge_p_FIFO_a;


}

