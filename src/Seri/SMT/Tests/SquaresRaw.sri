
module Seri.SMT.Tests.SquaresRaw where {

import Seri.Lib.Prelude;
import Seri.Lib.Bit;
import Seri.SMT.SMT;

-- Raw Lambda Calculus description for the following bluespec module.
-- Generates the sequence of squares: 1, 4, 9, 16, ...
-- module mkSquares
--   Reg#(Bit#(32)) odds <- mkReg(1)
--   Reg#(Bit#(32)) squares <- mkReg(0)
-- 
--   FIFO#(Bit#(32)) pipeQ <- mkFIFO()
-- 
--   rule produce
--     pipeQ.enq(odds)
--     odds <= odds + 2
-- 
--   rule consume
--     squares <= pipeQ.first() + squares
--     pipeQ.deq()

-- Sugar for bit extraction.
-- Extracts n bits from the given bit vector, with lsb indicated by the given
-- integer.
(@) :: Bit #m -> Integer -> Bit #n;
(@) = bv_extract;

(&) :: Bit #m -> Bit #m -> Bit #m;
(&) = bv_and;

(<>) :: Bit #n -> Bit #m -> Bit #p;
(<>) a b = bv_truncate (bv_concat a b);

bit1 :: Integer -> Bit #1;
bit1 = fromInteger;

bit32 :: Integer -> Bit #32;
bit32 = fromInteger;

bit33 :: Bit #33 -> Bit #33;
bit33 = id;

bit65 :: Bit #65 -> Bit #65;
bit65 = id;

bit66 :: Bit #66 -> Bit #66;
bit66 = id;

bit100 :: Bit #100 -> Bit #100;
bit100 = id;

-- Registers are represented as a packed bit vector:
--   { rmod,    1 bit
--     rval    32 bits
--   }.
rmod :: Bit #33 -> Bit #1;
rmod r = r@32;

rval :: Bit #33 -> Bit #32;
rval r = r@0;

-- A FIFO is represented as:
--  { fmod,         1 bit
--    fvalid1,      1 bit
--    fdata1,      32 bits
--    fvalid2,      1 bit
--    fdata2       32 bits
--  }
fmod :: Bit #67 -> Bit #1;
fmod f = f@66;

fvalid1 :: Bit #67 -> Bit #1;
fvalid1 f = f@65;

fdata1 :: Bit #67 -> Bit #32;
fdata1 f = f@33;

fvalid2 :: Bit #67 -> Bit #1;
fvalid2 f = f@32;

fdata2 :: Bit #67 -> Bit #32;
fdata2 f = f@0;

fmake :: Bit #1 -> Bit #1 -> Bit #32 -> Bit #1 -> Bit #32 -> Bit #67;
fmake m v1 d1 v2 d2 = m <> (bit66 (v1 <> (bit65 (d1 <> (bit33 (v2 <> d2))))));

-- The whole state is represented as:
--  { odds,         33 bits
--    squares,      33 bits
--    pipeQ         67 bits
--  }
odds :: Bit #133 -> Bit #33;
odds s = s@100;

squares :: Bit #133 -> Bit #33;
squares s = s@67;

pipeQ :: Bit #133 -> Bit #67;
pipeQ s = s@0;

odds_init :: Bit #33;
odds_init = bit1 0 <> bit32 1;

squares_init :: Bit #33;
squares_init = bit1 0 <> bit32 0;

pipeQ_init :: Bit #67;
pipeQ_init = 0;

state_init :: Bit #133;
state_init = mks odds_init squares_init pipeQ_init;

-- A maybe state is 
--  { valid,      1 bit
--    state     133 bits
--  }
valid :: Bit #134 -> Bit #1;
valid ms = ms@133;

state :: Bit #134 -> Bit #133;
state ms = ms@0;

mks :: Bit #33 -> Bit #33 -> Bit #67 -> Bit #133;
mks o s p = o <> (bit100 (s <> p));

-- Methods of the modules on the global state.
odds_read :: Bit #133 -> Bit #32;
odds_read s = rval (odds s);

squares_read :: Bit #133 -> Bit #32;
squares_read s = rval (squares s);

odds_write :: Bit #32 -> Bit #133 -> Bit #134;
odds_write v s = bit1 1 <> mks (bit1 1 <> v) (squares s) (pipeQ s);
 
squares_write :: Bit #32 -> Bit #133 -> Bit #134;
squares_write v s = bit1 1 <> mks (odds s) (bit1 1 <> v) (pipeQ s);

pipeQ_enq :: Bit #32 -> Bit #133 -> Bit #134;
pipeQ_deq v s =
  let {
    pq = pipeQ s;
  } in if ((fvalid1 pq == 1) && (fvalid2 pq == 1))
        then 0
        else if (fvalid1 pq == 1)
                then bit1 1 <> mks (odds s) (squares s) (fmake 1 1 (fdata1 pq) 1 v)
                else bit1 1 <> mks (odds s) (squares s) (fmake 1 1 v 0 0);

pipeQ_deq :: Bit #133 -> Bit #134;
pipeQ_deq s =
  let {
    pq = pipeQ s;
  } in if ((fvalid1 pq == 1) && (fvalid2 pq == 1))
        then bit1 1 <> mks (odds s) (squares s) (fmake 1 1 (fdata1 pq) 0 0)
        else if (fvalid1 pq == 1)
                then bit1 1 <> mks (odds s) (squares s) (fmake 1 0 0 0 0)
                else 0;

pipeQ_first :: Bit #133 -> Bit #32;
pipeQ_first s = fdata1 (pipeQ s);

pipeQ_first_ready :: Bit #133 -> Bit #1;
pipeQ_first_ready s = fvalid1 (pipeQ s);

--   rule produce
--     pipeQ.enq(odds)
--     odds <= odds + 2
produce :: Bit #133 -> Bit #134;
produce s = 
  let { 
    odds_value = odds_read s;
    ms1 = pipeQ_enq odds_value s;
    ms2 = odds_write (odds_value + 2) (state ms1);
  } in (valid ms1 & valid ms2) <> (state ms2);

--   rule consume
--     squares <= pipeQ.first() + squares
--     pipeQ.deq()
consume :: Bit #133 -> Bit #134;
consume s = 
  let {
    pipeQ_first_value = pipeQ_first s;
    squares_value = squares_read s;
    ms1 = squares_write (pipeQ_first_value + squares_value) s;
    ms2 = pipeQ_deq (state ms1);
  } in (pipeQ_first_ready s & (valid ms1 & valid ms2)) <> (state ms2);

-- Query a state under which produce and consume are not mutually exclusive.
not_mutually_exclusive :: Query (Answer (Bit #133));
not_mutually_exclusive = do {
  s <- free;
  assert ((valid (produce s) /= 0) && (valid (consume s) /= 0));
  query s;
};

-- Sequential composition of rules.
(<$>) :: (Bit #133 -> Bit #134)
      -> (Bit #133 -> Bit #134)
      -> (Bit #133 -> Bit #134);
(<$>) a b s = 
  let {
    ms1 = a s;
    ms2 = b (state ms1);
  } in (valid ms1 & valid ms2) <> (state ms2);

pc :: (Bit #133 -> Bit #134);
pc = produce <$> consume;

pcpc :: (Bit #133 -> Bit #134);
pcpc = pc <$> pc;

pcpcpc :: (Bit #133 -> Bit #134);
pcpcpc = pcpc <$> pc;

main :: Bit #134;
main = pcpcpc state_init;

}

