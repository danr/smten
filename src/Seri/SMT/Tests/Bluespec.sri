

module Seri.SMT.Tests.Bluespec where {

import Seri.Lib.Integer;
import Seri.Lib.Monad;
import Seri.SMT.SMT;

import Seri.SMT.Tests.FIFO;

-- The system state:
data TState = TState {
    a :: Integer,
    f :: FIFO2 Integer,
    b :: Integer
};

instance Eq TState where {
    (==) (TState a b c) (TState a' b' c')
        = (a == a') && ((b == b') && (c == c'));
    (/=) a b = not (a == b)
};

-- Rules:
-- p: f.enq(a+1)
p :: TState -> Maybe TState;
p (TState a f b) = do {
    f' <- enq f a ;
    return (TState a f' b);
};

-- c: b <= f.first() + b; f.deq();
-- TODO: Support let in a do statement in seri (?)
c :: TState -> Maybe TState;
c (TState a f b) = do {
    v <- first f;
    f' <- deq f;
    return (TState a f' (v + b));
};

-- A couple specific compositions:
ppc :: TState -> Maybe TState;
ppc s = do {
    s1 <- p s;
    s2 <- p s1;
    c s2;
};

pcp :: TState -> Maybe TState;
pcp s = do {
    s1 <- p s;
    s2 <- c s1;
    p s2;
};

(==>) :: Bool -> Bool -> Bool;
(==>) False _ = True;
(==>) True x = x;

-- Now for our query:
--  Are the two compositions "equivalent"?
--  That is, are they equivalent for all states s?
main1 :: Query (Answer ());
main1 = do {
    always (\s -> (f s == FIFO2_Empty) ==> (ppc s == pcp s));
    --always (\s -> ppc s == pcp s);
    query ();
};

main :: Query (Answer TState);
main = do {
    s <- free;
    assert (not ((f s == FIFO2_Empty) ==> (ppc s == pcp s)));
    query s;
};

}

