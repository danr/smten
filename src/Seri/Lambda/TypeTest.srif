
module Seri.Lambda.TypeTest where {

fst :: (a, b) -> a;
fst (x, _) = x;

snd :: (a, b) -> b;
snd (_, y) = y;

(&&) :: Bool -> Bool -> Bool;
(&&) True True = True;
(&&) _ _ = False;

class Num a where {
  (+) :: a -> a -> a;
  (*) :: a -> a -> a;
  (-) :: a -> a -> a;
  negate :: a -> a;
  abs :: a -> a;
  signum :: a -> a;
  fromInteger :: Integer -> a;
};

__prim_add_Integer :: Integer -> Integer -> Integer;
__prim_add_Integer = (@__prim_add_Integer :: Integer -> Integer -> Integer);

__prim_sub_Integer :: Integer -> Integer -> Integer;
__prim_sub_Integer = (@__prim_sub_Integer :: Integer -> Integer -> Integer);

__prim_mul_Integer :: Integer -> Integer -> Integer;
__prim_mul_Integer = (@__prim_mul_Integer :: Integer -> Integer -> Integer);

(<) :: Integer -> Integer -> Bool;
(<) = (@(<) :: Integer -> Integer -> Bool);

(>) :: Integer -> Integer -> Bool;
(>) = (@(>) :: Integer -> Integer -> Bool);

(==) :: Integer -> Integer -> Bool;
(==) = (@(==) :: Integer -> Integer -> Bool);

instance Num Integer where {
  (+) = (%__prim_add_Integer :: Integer -> Integer -> Integer);
  (-) = (%__prim_sub_Integer :: Integer -> Integer -> Integer);
  (*) = (%__prim_mul_Integer :: Integer -> Integer -> Integer);
};

head :: [a] -> a;
head (x:_) = x;

tail :: [a] -> [a];
tail (_:xs) = xs;

length :: [a] -> Integer;
length [] = 0;
length (x:xs) = 1 + length xs;

class Monad m where {
  (>>=) :: m a -> (a -> m b) -> m b;
  (>>) :: m a -> m b -> m b;
  return :: a -> m a;
  fail :: [Char] -> m a;
};

data Maybe a = Just a | Nothing;

instance Monad Maybe where {
    fail _ = Nothing;
    return = Just;
    (>>) a b = a >>= (\_ -> b);
    (>>=) m f = 
        case m of {
            Just x -> f x;
            Nothing -> Nothing;
            };
};

fromMaybe :: a -> Maybe a -> a;
fromMaybe _ (Just x) = x;
fromMaybe x Nothing = x

}

