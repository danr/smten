
-- vim: ft=haskell

foo1 :: Integer;
foo1 = (\x -> ((x*x)+(3*x))+2) 5;

foo2 :: Integer -> Integer;
foo2 x = ((x*x)+(3*x))+2;

rfact :: Integer -> Integer;
rfact x = if (x < 1) then 1 else x * rfact (x-1);

id :: forall a . a -> a;
id x = x;

data MaybeInteger = NoInteger | JustInteger Integer;

fromMaybeInteger :: Integer -> MaybeInteger -> Integer;
fromMaybeInteger def = \mi ->
    case mi of {
        JustInteger i -> i;
        NoInteger -> def;
    };

fromMaybeBool :: Bool -> Maybe Bool -> Bool;
fromMaybeBool def = \mb ->
    case mb of {
        Just b -> b;
        Nothing -> def;
    };

multiclause :: Integer -> Integer;
multiclause 2 = 10;
multiclause 3 = 20;
multiclause 4 = 30;
multiclause 5 = 40;
multiclause _ = 50;

tupleswap :: forall a b . (a, b) -> (b, a);
tupleswap (x, y) = (y, x);

listswaptop :: forall a . [a] -> [a];
listswaptop (x:xs) = (head xs) : (x : (tail xs));

listdifftop :: [Integer] -> Integer;
listdifftop (x:y:_) = x - y;

sum2 :: Integer -> Integer -> Integer;
sum2 a b = a + b;

sum3 :: Integer -> Integer -> Integer -> Integer;
sum3 a b c = (a + b) + c;

unary2int :: [()] -> Integer;
unary2int [] = 0;
unary2int (_:xs) = 1 + unary2int xs;

class Foo a where {
    foo :: a -> Integer;
};

instance Foo Bool where {
    foo _ = 1;
};

instance Foo Integer where {
    foo _ = 2;
};

foofun :: forall a . (Foo a) => a -> Integer;
foofun x = (((foo x)*(foo x)) + (3*(foo x))) + (foo True);

-- TODO: define this with a record constructor
data Apple = Apple Bool Integer;
isgreen :: Apple -> Bool;
isgreen (Apple b _) = b;
numseeds :: Apple -> Integer;
numseeds (Apple _ i) = i;

-- TODO: define this with a record constructor
data Wonderful a = Wonderful a Integer;
thething :: forall a . Wonderful a -> a;
thething (Wonderful x _) = x;
howgreat :: forall a . Wonderful a -> Integer;
howgreat (Wonderful _ x) = x;


class MultiFoo a b where {
    multifoo :: a -> b -> Integer;
};

instance MultiFoo Bool Bool where {
    multifoo _ _ = 1
};

instance MultiFoo Integer Integer where {
    multifoo _ _ = 2
};

instance MultiFoo Bool Integer where {
    multifoo _ _ = 3
};

instance MultiFoo Integer Bool where {
    multifoo _ _ = 4
};

unused :: forall a . a -> Integer;
unused x = 42;

multifoofun :: forall a b . (MultiFoo a b) => a -> b -> Integer;
multifoofun x y = (((multifoo x y) * (multifoo x y))
                    + (3 * (multifoo x y))) + (multifoo True False);

-- shadow x = 2*(x+1)
shadow :: Integer -> Integer;
shadow = \x -> (\x -> 2*x) (x+1);

thedo :: Maybe Bool -> Maybe Integer;
thedo m = do {
    b <- m;
    if b then return 5 else Nothing;
};

notand :: Bool;
notand = True && False;

testall :: Bool;
testall = (42 == ((\x -> (((x*x) + (3*x)) + 2)) 5))
       && ((42 == (foo1))
       && ((42 == (foo2 5))
       && ((True)
       && ((23 == (if 6 < 4 then 42 else 23 ))   
       && ((5 == ((id id) 5))
       && ((5 == (fromMaybeInteger 10 (JustInteger 5)))
       && ((10 == (fromMaybeInteger 10 NoInteger))
       && ((fromMaybeBool False (Just True))
       && ((30 == (case (1+3) of {
                    2 -> 10;
                    3 -> 20;
                    4 -> 30;
                    5 -> 40;
                    _ -> 50; }))
       && ((30 == (multiclause 4))
       && ((30 == (snd (tupleswap (30, 40))))
       && ((20 == (listdifftop (listswaptop [10, 30, 50, 0])))
       && ((12 == (sum2 5 7))
       && ((20 == (sum3 5 7 8))
       && ((3 == (unary2int [(), (), ()]))
       && ((1 == (foo True))
       && ((2 == (foo 42))
       && ((5 == (foofun False))
       && ((11 == (foofun 5))
       && ((11 == (numseeds (Apple True 11)))
       && ((11 == (thething (Wonderful 11 32)))
       && ((42 == (unused True))
       && ((19 == (multifoofun True 12))
       && ((8 == (shadow 3))
       && (3 == (length [1, 5, 2]))))))))))))))))))))))))));

