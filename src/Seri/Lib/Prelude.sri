
module Seri.Lib.Prelude where {

-- Return the integer value of a numeric type.
valueof :: #n -> Integer;

-- The single possible value for the given numeric type.
numeric :: #n;

-- Numeric type identity.
-- Checks dynamically if the two numeric types are the same. If so, acts as
-- the identity function, otherwise returns and error.
ntid :: #n -> #m;
ntid n = 
  let { m = numeric }
  in if valueof n == valueof m
        then m
        else error "ntid: numeric type mismatch";

class Eq a where {
   (==) :: a -> a -> Bool;
   (/=) :: a -> a -> Bool;
};

instance (Eq a) => Eq [a] where {
   (==) [] [] = True;
   (==) (x:xs) (y:ys) = (x == y) && (xs == ys);
   (==) _ _ = False;

   (/=) a b = not (a == b);
};

instance (Eq a, Eq b) => Eq (a, b) where {
   (==) a b = (fst a == fst b) && (snd a == snd b);
   (/=) a b = not (a == b);
};

class Num a where {
  (+) :: a -> a -> a;
  (*) :: a -> a -> a;
  (-) :: a -> a -> a;
  negate :: a -> a;
  abs :: a -> a;
  fromInteger :: Integer -> a;
};

class Monad m where {
  (>>=) :: m a -> (a -> m b) -> m b;
  (>>) :: m a -> m b -> m b;
  return :: a -> m a;
  fail :: [Char] -> m a;
};

id :: a -> a;
id x = x;

(.) :: (b -> c) -> (a -> b) -> a -> c;
(.) f g = \x -> f (g x);

($) :: (a -> b) -> a -> b;
($) f x = f x;

data Bool = False | True;

instance Eq Bool where {
    (==) True b = b;
    (==) False b = not b;

    (/=) a b = not (a == b);
};

(&&) :: Bool -> Bool -> Bool;
(&&) True x = x;
(&&) False _ = False;

(||) :: Bool -> Bool -> Bool;
(||) True _ = True;
(||) False x = x;

not :: Bool -> Bool;
not True = False;
not False = True;

data Maybe a = Nothing | Just a;

instance (Eq a) => Eq (Maybe a) where {
    (==) (Just x) (Just y) = (x == y);
    (==) Nothing Nothing = True;
    (==) _ _ = False;

    (/=) a b = not (a == b)
};

instance Monad Maybe where {
    fail _ = Nothing;
    return = Just;
    (>>) a b = a >>= (\_ -> b);
    (>>=) m f = 
        case m of {
            Just x -> f x;
            Nothing -> Nothing;
            }
};

instance Eq () where {
    (==) _ _ = True;
    (/=) _ _ = False;
};

__prim_eq_Char :: Char -> Char -> Bool;

instance Eq Char where {
    (==) = __prim_eq_Char;
    (/=) a b = not (a == b);
};

__prim_eq_Integer :: Integer -> Integer -> Bool;

instance Eq Integer where {
    (==) = __prim_eq_Integer;
    (/=) a b = not (a == b)
};
__prim_add_Integer :: Integer -> Integer -> Integer;
__prim_sub_Integer :: Integer -> Integer -> Integer;
__prim_mul_Integer :: Integer -> Integer -> Integer;

instance Num Integer where {
  (+) = __prim_add_Integer;
  (-) = __prim_sub_Integer;
  (*) = __prim_mul_Integer;
  negate x = 0 - x;
  abs x = if x < 0 then negate x else x;
  fromInteger x = x
};

(<) :: Integer -> Integer -> Bool;
(>) :: Integer -> Integer -> Bool;

(<=) :: Integer -> Integer -> Bool;
(<=) a b = (a == b) || (a < b);

(>=) :: Integer -> Integer -> Bool;
(>=) a b = (a == b) || (a > b);

fst :: (a, b) -> a;
fst (x, _) = x;

snd :: (a, b) -> b;
snd (_, y) = y;

error :: [Char] -> a;

undefined :: a;
undefined = error "Prelude.undefined";

-- Standard list functions

map :: (a -> b) -> [a] -> [b];
map f [] = [];
map f (x:xs) = f x : map f xs;

(++) :: [a] -> [a] -> [a];
(++) [] x = x;
(++) (x:xs) ys = x : (xs ++ ys);

filter :: (a -> Bool) -> [a] -> [a];
filter p [] = [];
filter p (x:xs) =
  if p x
    then (x : filter p xs)
    else filter p xs;

head :: [a] -> a;
head (x:_) = x;
head [] = error "Prelude.head: empty list";

tail :: [a] -> [a];
tail (_:xs) = xs;
tail [] = error "Prelude.tail: empty list";

null :: [a] -> Bool;
null [] = True;
null (_:_) = False;

length :: [a] -> Integer;
length [] = 0;
length (_:l) = 1 + length l;

(!!) :: [a] -> Integer -> a;
(!!) [] _ = error "Prelude.!!: index too large";
(!!) (x:[]) 0 = x;
(!!) (_:xs) n = xs !! (n-1);

foldr :: (a -> b -> b) -> b -> [a] -> b;
foldr f z [] = z;
foldr f z (x:xs) = f x (foldr f z xs);

replicate :: Integer -> a -> [a];
replicate 0 _ = [];
replicate n x = x : (replicate (n-1) x);

and :: [Bool] -> Bool;
and = foldr (&&) True;

or :: [Bool] -> Bool;
or = foldr (||) True;

any :: (a -> Bool) -> [a] -> Bool;
any p = or . map p;

all :: (a -> Bool) -> [a] -> Bool;
all p = and . map p;

elem :: (Eq a) => a -> [a] -> Bool;
elem x = any (\v -> v == x);

notElem :: (Eq a) => a -> [a] -> Bool;
notElem x = all (\v -> v /= x);

}

