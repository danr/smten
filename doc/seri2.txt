
vim: ft=txt

Sat Mar 24 08:21:35 EDT 2012

I want to give seri another shot, for the fun of it. But also as something
potentially useful. It's strange how I keep going around in full circles, and
I did a full circle away from seri and now back again.

But let me see if I can't make it rather cleaner this time around.

What's the goal?

We want the following:

- An intermediate representation for describing seri programs.
This will consist of expressions, types, perhaps modules.
My vision is to have an IR which is described in such a way that you can pick
and choose just the pieces you want to use, and it's extensible, so you can
add in things for where you want to use it. So it's not specific to my
language, but should, for example, work for a lambda calculus that Nirav wants
for SMT, work for BCL, for Structural Spec, and all seri all at once, but in a
clean way.

- C code generation of IR.
To separate things out, have a C IR for describing a C program in haskell. Or
C++ or both or something like that. Then have conversion from the seri IR to
that C ir, and have that C ir support pretty printing.

- BSV code generation of IR.
Analogous to the C code generation: we have a BSV IR we can translate to, then
pretty print to get working bluespec.

- Haskell code generation of IR.
Just convert to haskell's existing IR, and pretty print that.

- Haskell Interpreter for IR.
Aka: Static elaborator of IR.

- Clean front end.
This could be hard. What I want is this: I want to be able to describe
programs in haskell, using the full generality and abstractions haskell
provides. I want to generate from them a monomorphic, simple seri IR.

This might involve having a parser, or some translation to/from template
haskell. Important things: we want to leverage the abstractions of haskell. We
want to pass meaningful names into the IR from the front end. We want to have
types checked properly. It should not be messy yucky to write.


I think, perhaps, the first step would be to come up with a simple lambda IR.
Have booleans and integers and tuples, or whatever seri has.

Start writing the C or C++ and BSV IRs (which are completely separate modules
which can be reused elsewhere, which is really nice).

Once I have that baseline, then play with it to try and find good ways of
making the IR extensible and making the front end nice the way I really want
it to be.

Cool. This sounds like fun. Let me get started after breakfast.

Sat Mar 24 08:46:22 EDT 2012

First step: define my base language. My simple ir.

Types:
  Unit, Integer, Bool, Tuple, Function

Expressions:
  Unit, Integer, Boolean, Tuple,
  Add, Mul, Sub, Eq, Lt, If, Fst, Snd
  App, Lam, Fix

I'm not sure I like using Fix for recursive functions, but I can fix that
later. This will be enough of a start for factorial.

Sat Mar 24 08:57:49 EDT 2012

Okay, so I've defined my language.

The next thing to do is write a simple program in it.

Let's not start with a recursive program just yet.
In fact, let me get rid of Fix, because I don't want to start with a recursive
program.

First expression...

(\x -> x*x + 3*x + 2) 5

Sat Mar 24 09:26:00 EDT 2012

Nifty! It works.

What's the next step, do you think?

I think it would be nice to pretty print the expression. This is different
from Show.

Let me do that, then brainstorm what the next steps should be. I think it
probably makes sense to try and get all the parts of my goal in a nice way for
the simplest version of the IR, so I'm not rewriting so much code as I try
different things.

So, perhaps the first thing to get done are the basics:

+ pretty print seri
+ generate C from seri
x generate BSV from seri
+ generate Haskell from seri
- have a nice front end
- make seri extensible

The last two points will be hard, but very important. They are really the meat
of what I want to do. So work on them, see what I can come up with. Add more
to seri if I need to demonstrate the issues I'm worried about. And so on.

Okay, cool. I have something to work on now.

Sat Mar 24 10:14:10 EDT 2012

I did the printing. It works fine, it's just riddled with parentheses I'd like
to get rid of if I could.

The question is, what precedence do I want?

(\x -> x*x + 3*x + 2) 5

lam, +, *, app


Sat Mar 24 10:22:57 EDT 2012

Okay, That works well enough.

Next step?

Convert to haskell... done.

Next?

I think, either C or BSV back end?

The concern is how to do anonymous functions in those.
Perhaps, instead, I have to give each anonymous function a name?

Let me do a simple C ir. Just enough of what I need. Just to have something
more than haskell, something where types aren't inferred automatically. No
need to support bsv yet.

What do I need for C?

(\x = x*x + 3*x + 2) 5

Should become something like:

int l1(int x)
{
    return x*x + 3*x + 2;
}

l1(5)

So...

Dec = FunD Name [(Type Name)] Type [Stmt]
Stmt = ReturnS Exp
Exp = Int | Mul | Add

Let me stick to C for now. I don't anticipate needing C++ for my explorations.
    
Okay, last thing I need before playing with front end: the C code generation.

I'll want to use a monad, because an expression could return a bunch of
declarations as well.

Okay, good. That works.

Next step: a nice front end.

Sat Mar 24 11:21:46 EDT 2012

This part is going to take some thought, and experiment.

What are my requirements?

A. Assume user knows haskell
B. Haskell code should be easily incorporated into front end code for static
  elaboration.
C. Names used in front end should be preserved in the ir
D. It should be nice to write programs.
For example: writing in the IR is NOT nice. We want to use syntax.
E. Type checking must be done somewhere.
F. ? Error messages should be interpretable

Let's walk through some possible ideas, and evaluate them under the above
requirements.

Write in IR directly
--------------------
This is what I've been testing so far.
B. Good. We can easily generate code from haskell.
C. Good. Because the names are one and the same.
D. Terrible. Horrific.
E. We could add a step to check your types are consistent fairly easily,
right? A simple type check (not type inference).
F. We wouldn't have line numbers for type errors. Haskell will catch other
errors in its type system just fine.

Write a parser for the IR
-------------------------
B. Not good initially. Perhaps some extra work could let you inline haskell
fairly easily. This is worth looking into.
C. Good. Names transfer easily.
D. Good. We get just the syntax we want.
E. Don't know. How hard would type inference be? Perhaps we could require type
annotations? But that would make it more annoying to write programs in.
F. We could pass through line numbers, so this is fine.

Translate from Haskell using Template Haskell
---------------------------------------------
B. Good.
C. Good.
D. Okay. It's not clear how easy it will be to add custom primitives and such.
E. Haskell does the Type checking. We may need to infer types.
F. We wouldn't have line numbers.

Translate from Haskell using Quasi Quoting
------------------------------------------
This is like having our own parser, with haskell type checking.


So, there are some questions I think it's worth exploring before deciding on
theses.

1. How hard is it to write a type checker.
So, given a Seri Ir, just return whether or not it types correctly, and
ideally a nice message if it doesn't as to why it doesn't.

2. How hard is it to write type inference?
So, given a Seri Ir, assuming no type annotations, how hard to figure out what
the types should be?

If the primitives are all explicitly typed, that's fine. But what I suspect we
would want is overloading. So, given '+', how do we know what type to use for
it? Can that be inferred?

Do we support polymorphism? Or does every function have a concrete type? So
length of list of Integer is a different function than length of list of
Boolean, and so on?

3. How could we incorporate abstractions of haskell into the front end?
Can you have some sort of $ substitution, or something like that?


I'm afraid some of these depend on language features. They may be easy to do
now, but adding some language feature could suddenly make it much harder.

Anyway, let me investigate these questions and see what comes out of it.

Sat Mar 24 12:15:43 EDT 2012

Checking the types are consistent, given the types, is not hard.
If I had line number information, I could give pretty decent error messages
too I think.

What do I have to do for type inference?

Well, you have to give some types.

I wonder if SMT could do this for me. I just ask: does there exist a
consistent typing for this expression? If so, give me evidence. And then I
could ask if there were others as well. If there is exactly 1, then we are all
set. If less, it's not well typed. If more, it's ambiguous.

I don't think SMT will give me very good error messages though.

What would type inference look like for me?

The things you infer types for are:

Applications. Just take the return type of function.
Lambda - based on type of the variables and type of the expression
    The names could be inconsistent
Variables - based on the type of the lambda.

So you would need to give information about either the variables, or the
lambdas. Otherwise it could be ambiguous. We need to make sure all the uses of
the variable have the same type.

I feel like, if we don't have polymorphism, then it's easy. If we don't have
typeclass or overloading, then it's easy.

If I were to do this, I would want another kind of type. An Unknown type, or
some such, to distinguish between those types I know and those I don't.

I'm pretty confident I could do type checking of this simple IR. I think it
could get much more difficult when I make it a more realistic IR.

Let me skip now to question (3). I'll take an initial look, then think about
it over lunch.

How could we easily integrate haskell into the front end?

I need an example. A concrete example to work with...

Okay, so here's an example...

I wonder if my language is too simple right now.

What I want is something where you have a list of statements you want to
write, using haskell. Or, when you want to compute a number statically with a
haskell function. That's good. Let me start with that.

So I have some language, where say foo is in the IR, but bar is something we
want to evaluate statically. Either in haskell, or in the IR?

    foo x + (bar 24.5)

Here we don't know to do bar in haskell. The proposal then would be something
like:

    foo x + $(bar 24.5)

Says, evaluate $(e) as a haskell expression.

There are a couple of cases. First case: the haskell expression returns a
haskell value, and we require you have a way to convert that haskell value to
a seri value. Second case, which I guess is a special case, is that haskell
function returns a seri object directly.

So let me propose the general case first. We say any expression... or anything
really (?) in our front end can be described using $(...) which statically
evaluates haskell code, as long as that haskell code can be transformed into
the kind of object we are expecting.

I would love it if there were some way I could convert haskell template code
into a pure haskell object, then possibly translate that into my language.

This is perhaps doable. You could imagine something like:
   $($(toseri [e| \x -> x+2 |]))

Unfortunately the $() is being overloaded here. The outside is meant to be let
me do haskell, the inside one is meant to be template haskell's splice, where
toseri goes from template haskell Exp to a Q Exp which is of type Seri IR,
which can then trivially be converted to Seri IR. So that's something we could
do. Not sure how useful it would be.

I should consider too how I intend to parse and execute haskell code
statically.

The other thing I may want to do is manipulate seri constructs in haskell.

So, something like,
  Say x is a variable in Seri front end in scope, or whatever...

I guess what I'm saying, is I want a way to input a nice front end string, and
turn it into a haskell seri object, which I can then pass to a haskell
function, which gives me back a new haskell seri object, which I can then
splice into seri front end again.

So, I guess I need two things.

We have the notion of a front end context. Not sure how I want to do that just
yet. I'm leaning towards quasi quoting at this point.

1. Inside a front end context, I want a splice, which lets me run arbitrary
haskell code, if that code returns a value we can turn into a seri object.

2. I want a way to convert a front end context into haskell code, which can
then be passed to haskell functions.

For example, let's say this is pure haskell code. I could do things like:

----------
foo :: Seri.Exp
foo = [seri| (\x -> x*x + 3*x + 2) 5 |]

three :: Integer
three = 3

bar :: Seri.Exp
bar = [seri| (\x -> x*x + $(three)*x + 2) 5 |]

sludge :: Seri.Exp
sludge = [seri| (\x -> $(muln 2 [seri| x |]) + 3*2) 5|]
----------

And, I thus hypothesize this is all the integration I need to do all the nice
static elaboration I want. Though I'm not at all convinced of this. I think
the best way to test that is through practice and trying to write real
programs in Seri, leveraging haskell as much as I can.

Cool! So, let me have some lunch, come back, and understand if quasi quoting
will give me everything I want, and if so, how specifically it looks.

Sat Mar 24 13:13:39 EDT 2012

Oh boy. So this is exciting.

The concerns with this method, over say, BCL's front end, are:
1. How much work is it to do type checking and inference
2. How much work is it to write a parser
3. How hard is it to get reasonable error messages?

Let me look at quasiquoting now.

Hmm...

So I provide a quoter. Let's just look at the expression context for now.

I provide a function: String -> Q Exp.

Then, [s| ... |]  just calls the function to get back the Q Exp.

Now then, here's how this would work.

Let me define my own slice notation, to avoid confusion. In my seri language,
let's say a splice is... inside: @(...).

I implement a quasiquoter s. It parses the string, and returns a Q Exp, where
the Exp describes a Seri.Exp.

Now the examples look as follows:


----------
foo :: Seri.Exp
foo = $([s| (\x -> x*x + 3*x + 2) 5 |])

three :: Integer
three = 3

bar :: Seri.Exp
bar = $([s| (\x -> x*x + @(three)*x + 2) 5 |])

sludge :: Seri.Exp
sludge = $([s| (\x -> @(muln 2 $([s| x |]) + 3*2) 5|])
----------

Fine. The real question is, how do I do the @() splice? How do I implement it?

Well, I need a haskell expression parser. I parse the expression into a QExp
(I'm in the Q monad, so that's fine). Then I have an Exp in haskell, I wrap it
in, say, an AppE toseri foo, where foo is that expression. When the quote
returns, template haskell will evaluate that application, evaluate foo, do the
conversion, and give me the result. Here toseri has type a -> Seri.Exp, for
some haskell type a (we'll want a typeclass for haskell things you can lift
into Seri.Exp).

The other slight issue is nesting of [s|...|]. I'll have to add a way to
escape.

What type checking do we get? Your haskell code will be typechecked and run.
The seri code we'll have to type check.

Okay? 

I think quasiquoting is a better idea than parsing from strings, just because
it makes it that much easier to embed in haskell. We can still read from
files too, using the same thing. This way we get type checking of the haskell
code for free.

I'm not sure about line numbers, but I could certainly keep track of them
myself as I parse the string. So you get a line number relative to a slice,
and presumably haskell tells you the line of the slice that failed.

We don't use a DSEL, or the type checking we could get from that.

That's interesting. Perhaps we could have an intermediate DSEL, it gives us
the type info we want, still use quasiquoting, then we leverage haskell's type
system.

That's an idea. Let me try not doing that first, and reconsider it when type
inference starts causing me problems.

Cool. I'm going to take a walk, then start getting to the nitty gritty, to see
if I can make this work.

Sat Mar 24 14:01:36 EDT 2012

Here are the steps.

1. Write a parsec (3) parser for Seri.Exp.

parse :: String -> m Seri.Exp.

To test: parse the foo expression.

2. Implement lifting of Seri.Exp to TH.Exp

This should give me a quasiquoter for seri.

To test: write down foo as [s| ... |].

Not sure what this adds at this point...

3. Add support for slices in the front end.

This may require finding or implementing a haskell expression parser.

This is where using quasiquoting becomes important.

Try the bar test.

I don't imagine I'll get this far today, so let me stop the list there, and
start working.

First step, a parsec parser for Seri.Exp.

Sat Mar 24 15:02:04 EDT 2012

Okay! I have a parser. It's picky about whitespace, but it's enough of what I
want right now.

Sat Mar 24 16:16:35 EDT 2012

Next step: quasiquoting.

I can tell you at least one benefit of this. Maybe two.
1. Don't have to escape backsash.
2. vim will syntax highlight the contents of the string.
Now, admittedly it will use haskell syntax, but I could always add to vim an
escape to do specialized syntax highlighting for the quasiquote.

Little things, but let's see how it goes.

First step: lifting a Seri.Exp into TH.Exp. I wonder if there is a typeclass
for this already I could use?

Yes! There is. In Language.Haskell.TH.Syntax, called Lift.

Except... err... it would be Seri.Exp -> QExp. Is that okay?

Look, I can provide the pure version too. The lift instance will just be to
return that. Fine.

Sat Mar 24 16:30:15 EDT 2012

If what I'm doing will work, it will be much easier to lift into Q Exp than
Exp. Just wrap everything in th brackets. Let's see if it works.

How to test...

I suppose the way to test is to make a quoter, and see if it works.

Sat Mar 24 16:46:48 EDT 2012

It works! A slight difference than what I expected: the quoted thing returns
that thing directly, not a Q Exp. But that's fine with me.

Cool! Next step... slices.

Now then... how do I want to go about doing this?

I can parse everything between @(...) into a single string, with matched
parenthesis. Now I have a string.

How about I add an expression type to Seri (I wince a little at this thought,
but I'll clean things up later as needed), which is that Seri can have an
expression which is a THQExp.

Now all I need are two things.

1. Add that to the lift instance. Which is trivial, right?
2. Find a haskell parser to convert String into Q Exp.

The second point is just a little harder. Let's see what there is out there.

Looks like: Language.Haskell.Meta.QQ.Hs has hs quasiquoter for haskell, which
is just what I want.

So then, this should be simple.


1. Add Q Exp as a kind of seri expression.
2. Figure out how to parse the string @(...), with nested parens.
And also, probably want to escape |] at some point. But don't worry about that
now.
3. Use hs quasiquoter to convert String to Q Exp.
4. Implement lifting.

Or whatever. There's nothing big here. It should all work swell.

But! I should go eat dinner first.

Sat Mar 24 18:02:24 EDT 2012

It works! Haskell slices work just swell. That's awesome.

Currently the slice has to return a Seri.Exp. It might be nice if it can
return any arbitrary haskell value that can be converted to a Seri.Exp.

That should be simple to do. I just need to introduce a typeclass.

Cool.

Sat Mar 24 20:09:50 EDT 2012

Now then, what should I call this typeclass?

Seriable? Sounds too much like Serializable?
Seriable and seriize. Err...

Seriable seriate. Good.

Sat Mar 24 20:16:42 EDT 2012

That works nicely.

What remains to do now?

From my list above, I just want to try nested quotes. I think it will require
escape characters to make work.

Yup, nesting needs to be escaped.
I can escape it with...
Uh... "|~]" how about?


You know what? We don't need nested quotes. I can always say
 let x = [s| ... |]
 in [s| ... @(x) ... |]

And that's just fine with me. The issue is, we would run into double nesting
issues, triple nesting, and so on. It's just not worth the effort to deal
with.

Okay! Cool.

What's left?

The big thing missing now is just type inference. Because I really can't do
type inference in the parser. Can I? Can I just have explicit types?

Well, we would like some explicit types, and some type inference.

I think, give me type inference. And it can be sloppy. Infer types, then run
typecheck on the inferred types. Hopefully that's easier than trying to do it
all at once.

I'm a little worried about error messages and line numbers, but ... don't
worry about that just yet.

How can I do type inference?

I feel like I tried this before with drizzt, or whatever language I had. And
it was messy.

Let's assume no polymorphism for now.

Conceptually you can assign a type variable to each unknown type, and come up
with a bunch of constraints.

Can I use an SMT solver for this? That would certainly be cool...

Is it worth trying to do in yices manually?

For example, how would I typecheck qbar?

AppE A (LamE B "x" (AddE (AddE (MulE (VarE C "x")
(VarE D "x")) (MulE (IntegerE 4) (VarE E "x"))) (IntegerE 2)))
(IntegerE 5)
 

Variables: A, B, C, D, E.

Constraints:

B = ArrowT F G  -- function in apply must have ArrowT type
A = G           -- type of apply is return type of function
F = C           -- type of variable is same as input to lambda
F = D
F = E


Hmm... Maybe it makes sense to combine this with type check.

I come up with a set of constraints of these forms, introducing variables as
needed.

Then I ought to be able to use SMT or something to solve this, right?

Come up with a set of constraints, then try to solve.

Let me alter the typecheck function...

No, let me write another function, which given an expression, returns a set of
constraints. Where each constraint is of the form (Type, Type). And we add
VarT as a type. We'll have a state monad to collect constraints, and a counter
to keep track of free variable types.

I'll run this, print out what it gives for my expression, make sure it looks
right, then see if I can solve that with yices.

Err... I really hate to have to go to IO to do typecheck.
Could I not implement a constraint solver?

Well, let's see what I can do with the constraints.

Here are the constraints I generated for Q Sludge.
 
V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
ArrowT V5 V6 = V1
IntegerT = ,IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = ArrowT IntegerT IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

What do we see? Clearly I have my types wrong, because this is not
satisfiable. Let me go fix my bugs.

V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
ArrowT V5 V6 = V1
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

Now if I solve this by hand, I get...

V0 = V8
V1 = IntegerT V6
V2 = IntegerT
V3 = IntegerT
V4 = IntegerT
V5 = IntegerT
V6 = V8
V7 = IntegerT

Hm... We don't have all the info we need.

Let me print the expression out too.

(AppE (VarT 0) (LamE IntegerT "x" (AddE (AddE (MulE (VarE IntegerT "x") (VarE
IntegerT "x")) (MulE (IntegerE 3) (VarE IntegerT "x"))) (IntegerE 2)))
(IntegerE 5),

I'm missing a constraint. One that says the type of an application is the
output type of the function called?

Okay, I see what I missed. Now let's see.

(AppE (VarT 0) (LamE (VarT 1) "x" (AddE (AddE (MulE (VarE (VarT 2) "x") (VarE
(VarT 3) "x")) (MulE (IntegerE 3) (VarE (VarT 4) "x"))) (IntegerE 2)))
(IntegerE 5),

V7 = IntegerT
V8 = V0
ArrowT V7 V8 = V1
V4 = V5
V3 = V5
V2 = V5
V6 = IntegerT
ArrowT V5 V6 = V1
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = IntegerT
IntegerT = V4
IntegerT = IntegerT
IntegerT = V3
IntegerT = V2

If I solve it manually, I get:

V0 = IntegerT
V1 = ArrowT IntegerT IntegerT
V2 = IntegerT
V3 = IntegerT
V4 = IntegerT
V5 = IntegerT
V6 = IntegerT
V7 = IntegerT
V8 = IntegerT

Perfect. Just what we want.

Now, I think it would be good practice to try asking this question to the SMT
solver, yices. I'll do that tomorrow morning.

My question to you is, is there a systematic way to solve this system of
equations? Can I do variable elimination? In some order?

Perhaps I can eliminate constraints?

X = X  - drop the constraint, because it's trivial.
ArrowT X Y = ArrowT W Z  - replace with X = W, Y = Z
X = Y - If we can give priority to types, say smaller types have higher
priority than larger types, we could say, substitute every occurence of Y with
X, recording that Y is Y.

Repeat until we reach some sort of fixed point?

Let me try it.

V7 = IntegerT
V8 = V0
V1 = ArrowT IntegerT V0
V5 = V4
V4 = V3
V3 = V2
V6 = IntegerT
V2 = IntegerT
V0 = IntegerT

We make pretty good progress after one round, but now what? Another round
isn't going to help any.

Maybe I have to replace all of them?
Let me try that.

So we say the following: you may only replace a variable with a better known
variable. That should finish us. Let me try it.


V7 = IntegerT
V8 = IntegerT
V1 = ArrowT IntegerT IntegerT
V5 = IntegerT
V4 = IntegerT
V3 = IntegerT
V6 = IntegerT
V2 = IntegerT
V0 = IntegerT

Wow. Well, that works pretty well here.

Perhaps there is some fixed point thing or something. It would be nice to try
and prove in coq or some such.

The idea is this. We order expressions from best known to least known.

Whenever you encounter the constraint: X = Y, flip it so that whatever is on
the left is the last known. Call that X. Then, replace every other occurrence
of X in all other constraints with Y. You have just made things better known
overall.

Ignore constraints of the form X = X
Fail at constraints of the form X = Y where X and Y are known but don't match.
Reduce constraints of the form ArrowT A B = ArrowT C D to two simpler
constraints: A = C, B = D.

The hpothesis is, running this algorithm will leave you with an association
list mapping unknown types to known types. Just look up your type variable in
the list, it will tell you, as best it can, what the type of that is.

Well, it's late enough I need to call it a day.

Here's the plan for tomorrow.

+ Implement my proposed type constraint solving algorithm.
+ Combine that with the constraint generation to do type inference.
x Try using yices to solve the above constraint problem.
Mostly just for practice with yices. I don't actually want to use it in my
compiler because I don't want to have to go to IO. It will be good to have
confidence that I can use an SMT solver if things start getting messy though.

At this point, I should have a full front end, parser, type inference, type
checker (if not subsumed by type inference, it might be nice to have type
checker to make it easier to figure out type errors), elaborator, pretty
printer, haskell generator, c generator.

+ Reorganize code into something nice.
+ Write up HUnit test cases.
+ Expand Seri to support factorial function with fix operator.

This should give me a feel for things. At this point, I think I'll have enough
to go on to try and understand extensibility. I'd like to answer questions
such as:
* Can we augment the IR with unknown type just for parsing?
* Can we augment the IR with variable types just for type checking?
* Can we augment the IR with source pos info for parsing and type checking?
* Can we separate primitives out of IR in a nice way? 

If this is not enough to go on, then continue to expand the IR until it
supports everything I want for tibby. See if I can describe QR in my IR, how
nice it is, if it all works, and then try to compile to C, BSV, and Fiddler.

That's really the ultimate for this project. If I can do QR in those
languages, them I'm ready to roll.

Sun Mar 25 06:48:06 EDT 2012

First step: implement my type constraint solver.

Well, it seems to have worked on my simple example. We shall see if it works
in general.

Next step: make type inference much nicer.

Here's how it should work.

1. UnUnknown expression
2. Generate type constraints
3. Solve type constraints
4. apply solution

Let's allow the user to do typecheck separately from inference.
And we just say, well, inference may not return a correct result, so you
should probably check the solution it gets.

Sun Mar 25 07:37:56 EDT 2012

I don't feel much like playing with yices right now.

Let me instead move on to code cleanup.

I'll start by looking at the code, proposing a solution. Then I'll take a
break for breakfast, come back, and clean stuff up.

Proposed hierarchy:

C - ir, ppr
Seri - Seri.IR, Seri.Elaborate, Seri.Parser, Seri.Quoter, Seri.TypeCheck, Seri.TypeInfer
Seri.IR - ir, typeof, ppr
Seri.Elaborate elaborate
Seri.Parser parser
Seri.Quoter quoter, thlift
Seri.TypeCheck typecheck
Seri.TypeInfer typeinfer
Seri.Backend.C
Seri.Backend.Haskell

I think that will make for a nice structure, and clean sharing, and such like.

And we should have test cases for everything.
Let each module define its own tests? Yes, as HUnit.

Good. This will be nice to do.

Sun Mar 25 08:32:21 EDT 2012

Next step: switch to using HUnit for tests.

Sun Mar 25 09:11:23 EDT 2012

I want to see if I can simplify the code some. This will help for
understanding how I could do generic programming too.

The issue is, I feel like I implement recursion down the expression tree lots
and lots of times, repeating lots of the same stuff.

Can I make some generic expression traversals to make things easier?

Let's look at all the times I do this recursion, and see if I see any common
forms.

elaborate: 
    integer: does something
    adde: recurses to a, b, does something
    mule: recurses to a, b, does something
    appe: recurses to f, x, does something
    lame: does something (this is a leaf for elaborate)
    vare: does something

reduce: takes args
    integer: does something
    add,mul: recurse to a, b, does something
    app: recurse to f, x, does something
    lame: recurses to body, does something
    var: does something

typeof: does something for each. No recursion.

ppr: does the recursion like reduce

lift: does something for each. Nor recursion.
    
checkvars, typecheck use our common recursion
tereplace does, ununknown does, constrain does, constrainvs does

In summary, we do this recursion in the following places:

reduce, ppr, checkvars, typecheck, tereplace, ununknown, constrain, constrainvs

You would think I could factor out the common code.

Okay, so let me make a stab at a proposal for the traversal function.

At the high level, we want to produce a function of the form: Exp -> a
I want to provide the following:

Integer :: Integer -> a
AddE :: a -> a -> a, 
MulE :: a -> a -> a,
AppE :: Type -> a -> a -> a
LamE :: Type -> Name -> a -> a
VarE :: Type -> Name -> a

For example, reduce would be:
Integer :: IntegerE
AddE :: AddE
MulE :: MulE
AppE :: AppE
LamE :: \t ln b -> if ln /= n then LamE t ln b else (original LamE)
VarE :: \t vn -> if vn == n then v else VarE t vn

So maybe we also pass around the original expression, as an escape hatch if
you don't want to do the recursion completely.

How would you specify these? As arguments, or in a structure.

I think this is worth trying out at least. See if it cleans things up at all
or not. See if it works or not.

Sun Mar 25 09:45:48 EDT 2012

Well, there's less code written. But I'm not sure you can read the code and
understand how it works. Maybe that's not true. Maybe it actually captures the
heart of what you want to do?

Anyway, let's see how much work it is to use with elaborate.
Elaborate works fine.

ppr - doesn't exactly match form. I could rewrite it so it does, but let me
skip it for now.

typecheck - doesn't work so well, because of the monad. Perhaps I can have a
monadic traversal implementation? Let me skip this for now.

ununknown - another one which could take advantage of a monadic traversal.
constrain - same, monadic traversal would be nice
constrainvs - same.

And even the one I did which was monadic could take advantage of this.
Oh, no, actually checkvars doesn't work so well with monadic, because we have
a case where we don't want to apply the monadic part.

Sun Mar 25 11:07:31 EDT 2012

Okay, so that's maybe a little bit cleaner.

I don't know. It still feels a little irksome to me, but I don't know why.

Anyway, let me expand the language to support a factorial function. This will
be a bit of grunt work, but it will be valuable.

In particular, pay attention to what I need to do to add a new construct to
the IR. This is the kind of information I'll need an IR extender to write.
This is the kind of information we want to be component specific.

Fine. What's first?

What's the sum list of things I need?

Well, I want to write something like:

  let factorial = [s| !f \x -> if (x < 1) then 1 else x * f (n - 1)
  in [|s @(factorial) 5 |]

I need the following:
+ Subtract
+ Bool
+ Lt
+ If
+ fix operator

Start with subtract.

Things to add:

- IR construct for it: SubE
- Add syntax to parser: -
- TH lift (TODO: can't we automatic this in most cases?)
- traverseM
- ununknown
- constrain
- traverse
- elaborate
- reduce
- tereplace
- constrainvs
- typecheck
- checkvars

All that just to run the thing. This doesn't include pretty printing of
conversions to C or Haskell.

I do observe AddE, SubE, and MulE are all implemented in almost exactly the
same way.

Next: Bool. This is a type, so there will be some difference.
Really we want Bool.

Sun Mar 25 12:04:02 EDT 2012

I notice adding new constructs seems fairly straight forward.
SubE was just like AddE.
BoolT, BoolE were just like IntegerT, IntegerE.

It makes you wonder if you should have primitive types, or binary integral
functions, or some more general representations of things.

Anyway, on to Lt. This is another binary function, but it has a different type
than the previous ones.

Yup, adding that was pretty straight forward.

Next: If.

This one might be more interesting.

Sun Mar 25 12:32:07 EDT 2012

In all these things, the Parser is most fragile. Adding more stuff can break
it easily. That's not so much the case for anything else.

Sun Mar 25 12:41:01 EDT 2012

Next, and the last needed for factorial, though perhaps the one I need be most
careful about...

Let me wait to do 'fix' until after lunch.

Sun Mar 25 13:15:06 EDT 2012

Okay, so, how do I implement fix?

I think everything is straight forward except for elaboration.

FixE :: Type -> Name -> Exp -> Exp

How do I reduce this?

Well, the idea is, it's an expression, and we can construct the new expression
as ...

I need to be careful.

Let's say you have to fix a function, not just a value?

Ug. What I want to do, is, we have Exp -> Exp which unrolls the expression. We
just call haskell's fix point operator on that, then fix goes away, and it
becomes... what?

Well, it becomes a lambda.
The trouble is, if you try to print it out, for example, it will become an
infinite lambda. So, don't try to print this out.

I feel like what I could do, is say: the type of the Fix expression has to be
a function type. Then we only go to unroll it when we try to apply to it.

Okay, fine. Whatever. Let me just do it this way: to evaluate fix, use
haskell's fixed point. Haskell is lazy. As long as we don't try printing the
result, we should be fine.

So, to elaborate fix, I would do the following:

Okay, I think I got it. Let me try and see what happens.

Sun Mar 25 13:40:36 EDT 2012

Okay! So, we have a type error.

The expression is x.
The expected value is Integer. That's good.

The inferred type is:

---------
((IntegerT -> IntegerT -> V8)
    ->  (IntegerT -> IntegerT -> V8)
    -> V8)
-> ((IntegerT -> IntegerT -> V8) -> V8)
---------

That's very strange.

First note: I should print types in errors, not show them.

Oh, I had some bugs. Now it type checks.

Trouble though: elaboration doesn't complete.

That is, elaboration returns this big old expression.

Oh. I bet I just forgot to elaborate the result of the fix.

No. That wasn't it. Hmm...

I should be pretty printing the results, not showing them. Hmm...

Oh. I had a typo in the input. I used both n and x, but n was free, it wasn't
bound. That caused the problem.

Hey! Cool. Fix point works. Factorial works.

Sun Mar 25 14:10:21 EDT 2012

Next goal: Extensibility.

I'm pretty confident I could write a bunch of cool stuff, have a bunch of
features. But I want it to be clean. That is, I want each feature to be like a
library, and I just need to pull in whatever libraries I need for my
application.

Let me start with perhaps a simpler goal than I had before, but still a big
step towards extensibility.

Right now we have things broken up by phase: parse, quote, typeinfer,
typecheck, elaborate. What I really want, though, is to be broken up by
construct: Bool, Integer, Add, Sub, Mul, Fix, If.

Hum. This seems rather daunting. Perhaps I can put up some strawmen and see
how well they do.

Let me ignore the parser for now, because I think that's its own issue.

I have these functions: typeinfer, typecheck, elaborate, and friends.

What I want, in my vision, is that these will work on any kind of IR type that
has each function properly described. Thus, it would seem, typeclasses could
help us. I want each feature of the IR to be its own type, I implement the
right typeclass, and suddenly I can use the functions.

In particular, it would seem I'd like a way to put a bunch of features
together, so that given an IR and a Feature, I get back a new IR.

Okay, good, that all sounds good.

And I'm fine having a core IR with variables, lambdas, and applications, if
that helps to kick-start things.

Okay, now what? Um, let's say every IR has an Exp type and a Type type? I
don't know what I'm doing, let me just write things down and see where I end
up.

Ug.

Say a Feature involves some Type and Exp it adds.
For example, boolean might add: BoolT, BoolE.
We have a core IR with Type and Exp

I want a new IR with (Type, BoolT) (Exp, BoolE).

Err...

data Exp a = IntegerE
           | AddE (Exp a) (Exp a)
           | ...
           | a
           ;

This is an extensible expression type. To extend it, you just add expressions
as described by the 'a' type. So, this becomes a bit like stacking monad
transformers.

Now, I could fill that with a feature, right? And the Feature should be
extensible...

data Feature a = BoolE
               | a
               ;

No. It doesn't work, because the new features need access to all the old stuff
too.

hmm.. an IR augmented with a feature can be typechecked, for example, if the
IR can be typechecked, and the new feature can be typechecked.

Let me use If as the example, I think it will reveal more.

data CoreE t e = 
    AppE t e e
  | LamE t Name e
  | VarE t e e
   
        
data IfE t e = IfE t e e e

Okay, so we specify features like this, say. Parameterized by t and e.

Now, in order to instantiate our concrete IR, we would do something like:

data MyExp = Core (CoreE MyType MyExp)
           | If (IfE MyType MyExp)

Ooh. This looks like it has potential to me.

instance Typeof MyExp where
    typeof (Core x) = typeof x
    typeof (If x) = typeof x

And we could maybe even use generics to help us write these, but let's not
worry about that just now.

instance Traverse MyExp where   
    traverse... It should work.

I want to try this for a little example. Maybe, have the core be everything
now aside from fix. Then add Fix as a feature. That will be a good test.

I'll have type classes for all the phases. I'll implement Core to work the way
you would expect.

Um, things could get messy. I would recommend: don't worry about messing a
bunch of stuff up.

In fact, it may make sense to try and start from scratch with a simple core,
one bit at a time, copying code. Yes, I bet that will be easier than trying to
modify this whole thing.

Cool. I like this vision.

Sun Mar 25 15:45:34 EDT 2012

Slight change in plan. I'm going to try and adapt the existing code rather
than starting from scratch.

We'll say the parser is for my specific choice of combinations (what I have
currently).

I'll pull pieces out of Exp and Type a bit at a time.

First thing to pull out: Fix.

Pull it out, make type classes for each feature.
After that, I should be able to pull things out a piece at a time.

There is one issue I might run into. I'll probably run into. Let me deal with
it when I get there, but have it in my mind now. That's, some features depend
on others. Like, you can have If unless you have Bool. How will those compose
together? Hmm... worried. But let me try this anyhow and see how it goes.

Sun Mar 25 15:54:14 EDT 2012

Not sure how to deal with traversal. Can I come back to that later?

Things to pull fix out of:

elaborate.

Hmm... this seems to interact poorly with traversal...

Let me try typecheck, which doesn't have the traversal issue.

But that depends on checkvars, which has the traversal issue.

This traversal thing... doesn't seem to help.

Let me remove use of traversal from all of TypeCheck, then try to pull FixE_F
out of it.

Sun Mar 25 16:20:52 EDT 2012

I should figure out how they use generic programming in haskell to implement a
generic show. That way I can write a generic implementation for your concrete
IR, given the implementation for all the pieces.

Anyway, continuing on with extraction of FixE.

Sun Mar 25 16:38:51 EDT 2012

Trouble with the Elaborate class. We need to pass in the top level expression
container. Does that mean it needs to be part of the class?

It seems like a Fix point specific thing, because fix has to refer to itself.

Ug.

I think, maybe, I should take a break from this track, and look more closely
at generic programming? Perhaps that will give me ideas?

Erg...

Sun Mar 25 17:17:59 EDT 2012

I looked into generic programming a little bit. I think I can make use of it.

Let me try the following.

In TypeInfer, we have this function tereplace.

I bet that I can implement that in a generic way.
I fear this could be slightly problematic, if, for example, you want to have a
Type in your expression which you don't want substituted, but that seems
unlikely to me. So let me try this.

I'm going to make the replacement work for any typeable thing. And I'm going
to see recurse through the structure, and replace all types.

Wish me luck.

Well! It works.

That's no so bad actually, using everywhere and mkT.

And you know what this means? I don't need to implement that function for each
separate feature. That's nice.

Let me go see where else I can apply this.

Aha! It would seem ununknownt is a good candidate. Monadic this time.

Wow. that's really nice.

It means much less work for adding new features, that's for sure.

Sun Mar 25 17:46:29 EDT 2012

I'm not sure there are other really generic kinds of functions that I could
take advantage of Data.Generics for.

Hmm... So the real question is, could I use this to say something like:

We have a typeclass which says, given a constructor FixE, for example, and all
its fields, knows how to do, say, elaboration on it.

Then each feature is a constructor.

Hum hum... I feel like that's worth pursuing.

Let me think about this a bit.

Sun Mar 25 19:55:06 EDT 2012

Type classes could lead to trouble with generics. That is, you can't use a
typeclass to define your transformation function (a -> a) because we don't
know that every a you encounter will be an instance of that typeclass.

Sun Mar 25 20:06:37 EDT 2012

One thing I can do is ask for a constructor of a given object. I'm not sure
how that helps.

How about this. Let me not get caught up in Data.Generics. I know how it can
be used, how it can be useful, but that's enough. I'll use it where it makes
sense.

I think the original plan still holds. Try to pull Fix outside, into its own
file.

Sun Mar 25 20:23:56 EDT 2012

Perhaps it does make sense to try start from scratch after all?

I can make my parameterized core. Build it from the ground up?

I suppose it's worth a try.

First step: IR/Core:

AppE, LamE, VarE
ArrowT, UnknownT, VarT

Trouble is, I can't really do anything with that, can I?

I'll want, perhaps, also IR/Arithmetic:

IntegerE, AddE, SubE, MulE
IntegerT

I'm not sure this can work.

Okay, maybe I just need to think of myself as having type features as well as
expression features.

This could get messy.

I wonder... Could I make this cleaner?


For example, what we really want is to have some expression e.

That is, imagine an expression. And say,

data FixE = FixE ...

This is a kind of expression.

data LamE = ...

is a kind of expression.

Now, my functions work on expressions.

The question really is, how do you define what all types of sub expressions an
expression could have? Well... that's defined by what you import, right?

For example, we could define the following expressions:

data BoolE = BoolE Bool
data IntegerE = IntegerE Integer
data AddE where
    (Exp e1, e2) => e1 -> e2 -> AddE

I fear this is starting to look just a bit like GADTs... 

But let me keep looking.

Okay, fine... now how do I do, say, elaborate?

instance Elaborate IntegerE where
    elaborate e = e

instance Elaborate AddE where
    elaborate (AddE e1 e2) =
        case (elaborate a, elaborate b) of
            ... -> IntegerE
            ... -> AddE

Aha! Now we see the problem.

What's the return type of elaborate? In the case above, two branches have
different types! That's bad news.
            
Something about this feels nice though. Like, the dependency problem I was
worried about goes away or some such.

What if you defined some top level Exp type, which is the union of all the
kinds of expressions you want.

instance (ToE AddE, ToE IntegerE) => Elaborate AddE E where
    elaborate (AddE e1 e2) =
        case (elaborate a, elaborate b) of
            ... -> toE IntegerE
            ... -> toE AddE

So now we can build up a library of specific expressions. Then, when you want
to define you top level thing, all you need to do is define your top level
data type, and deriving ToE. That, perhaps, could also be automated with
template haskell or generics.

The real question is, is there any chance at all this could work?
How could I come up with a proof of concept?

Let's start with: Elaborate, IR. Using Core and Arithmetic.
Then add TypeCheck. If all goes well, expand it slowly.

Shall I take a quick stab at things?

We have a type level expression. We have a type level type.
LiftE, LiftT.

Let me try to get started. For now, treat all names as String. It will be
simpler.

Sun Mar 25 21:00:14 EDT 2012

Okay, we'll see if this is going to work or not.

Just try to get elaboration to work with core and integer.
That should show me lots of issues.

In fact, let me ignore types for now, because we don't need them for
elaboration. I can add them later.

Sun Mar 25 21:10:32 EDT 2012

Let's simplify even more for this first attempt. Forget core. Just be able to
do expressions like: 2 + 3 + 4...
    
Sun Mar 25 21:42:26 EDT 2012

Well, believe it or not, something works.
It's a little scary typewise.

There are a lot of places where we need explicit type info.

Sun Mar 25 21:56:47 EDT 2012

Okay, so I cleaned up a little.

It seems like I've ended up close to where I was headed towards in my last
attempt. The key idea is: have inject, and unject to be able to stuff an
expression into the top level expression and extract an expression from the
top level expression. That gives me the dependency stuff I need.

I believe this has some promise.

Let me figure out how to elaborate my favorite expression:
    (\x -> x*x + 3*x + 2) 5

That should help force the issues.

Once I can do that, add some type info, and move on to type checking.
From there move on to type inference.

Mon Mar 26 08:21:15 EDT 2012

Okay, so it seems robust to adding MulE. That's good.

And I think it should be relatively easy to automate the generate of the
Inject interface and the top level elaborate interfaces using template
haskell.

I feel like I should be able to do similar with generics, but I don't know how
to get around this typeclass issue. I feel like template haskell is safer,
because it does that extra type checking step.

Next step: application, var, and lambda.

Mon Mar 26 09:02:54 EDT 2012

Foo works!

Good. So I'm feeling pretty confident in the way things are going for
elaborate. I think now would be a good time to step back, think about what's
going on, and do some code cleanup.

Mon Mar 26 09:08:21 EDT 2012

Basically the idea is each expression can be boxed (injected) into the full
expression, and we can go back and forth. So it's like a dynamic typing sort
of thing.

The problems currently are:
- You have to specify lots of types explicitly, because any time you construct
  an expression, and especially if you then inject it, you have an ambiguous
  type. Perhaps there's some way to get rid of this, but nothing comes to mind
  immediately.

- boilerplate code for MyExp (the box) is really annoying, though simple.

- Have to deal with all these multi param type class, flexible instance and
  contexts, undecidable contexts and scoped type variables. That worries me a
  little. But we don't need GADTs, which I guess is nice.

So, next step is clear, I think. Automate the boiler plate code, because it's
only going to get more annoying.

After that... I think we have interesting enough constructs to try and flesh
out the whole stack, from parser down to... let's stick with elaboration for
now. No need to go to the backends just yet, because that's too hard to test.

First step. automation. I can do this with template haskell, I'm sure.
Can I do it easily with generics?

We want two things: an instance of Inject for each field.
   instance Inject Foo MyExp where
        inject = MyFoo
        unject (MyFoo x) = Just x
        unject _ = Nothing

An instance for Elaborate, which just applies the same functions to each
immediate sub constructor.

I feel like the elaborate instance should be ... It's like a query. So I
should be able to use generics, aside from this typeclass issue.

Ah, but we can have a default value, no?

I think it's worth a try. It would be much cleaner than template haskell.

No, I don't think I'll get it to work, because, again, of this typeclass
issue. Fundamentally I need to figure out how to do a transformation on
typeclasses, where ideally it would though a static error if you would ever
try to use it on an object that doesn't implement that type class. Or, in
other words, template haskell will give me just what I want.

So let me use template haskell.

First step: the instances of inject.

Mon Mar 26 10:18:36 EDT 2012

Template haskell and quotes seem so promising, but when you get into it,
little details make them, basically, unusuable. Like, not being able to splice
in patterns. Not being able to splice in non-top level declarations.

I almost feel like it would work better to use a haskell quasi quoter, where I
supposedly can do those things. That may be worth experimenting with.

Anyway, I have automatic generation of Inject now. Next I need elaborate.

Mon Mar 26 17:50:01 EDT 2012

Elaborate.

for each constructor
    elaborate (Foo x) = elaborate x
for each constructor
    reduce n v (Foo x) = reduce n v x

I don't believe template haskell quotes will work here, so let me not bother
with them.

Mon Mar 26 18:04:10 EDT 2012

Okay! So that wasn't too bad. We now automate self elaboration. Good. What's
next?

We have enough of the expressions. I'm confident I could keep adding more and
still have that work out for elaborate.

The real challenge next is...

Type checking. Adding and checking type information.

And note, we'll want the types to be extensible too.

What types do I need for type checking?

Assuming the are all known, for now it should be enough to have IntegerT and
ArrowT.

For each expression we need: typecheck, checkvars
We also need pretty printing of expressions and types.

I don't need any sort of traversal of types to do this, which is nice.

Okay, so, it's straight forward, right?

class (Eq t, Ppr t, Ppr e, Inject ) => TypeCheck t e...

One thing is we return the type in typecheck. We could just as easily use
typeof to get at the type, right? I honestly think that makes more sense.

Hmm... it's hard to figure out what I need to do.

Well, first step, let's say, is to add type parameters to Var, Lam, App.
See what all headaches that causes.

Here's an idea, maybe LamE should be a VarE and a body. That makes sense,
right? It does to me...

Mon Mar 26 18:27:34 EDT 2012

I'm getting this error:
    No instance for (Inject (LamE t MyExp) MyExp)
      arising from a use of `reduce'
    Possible fix:
      add an instance declaration for (Inject (LamE t MyExp) MyExp)
    In the expression: reduce n v x
    In an equation for `reduce': reduce n v (MyApp x) = reduce n v x
    In the instance declaration for `Elaborate MyExp MyExp'

I think the issue is, reduce requires you can inject any LamE t, but you can
only inject a LamE MyType. That is, t is determined by MyExp. So we need some
form of functional dependencies.

Well... we could have inject know about types, right?

But why doesn't VarT have that issue?

That's odd... AppE doesn't have the issue either. Did I implement something
wrong?

And now it works fine... okay, whatever.

So I added a type parameter. I just don't have any interesting types yet.

Let me define an interesting type: IntegerT, ArrowT.

Mon Mar 26 18:38:29 EDT 2012

Okay, now when I start to use different expressions, we have issues with the
types. That is, our boilerplate code defines instances for
Inject (AppE MyType MyExp) MyExp

It does not for
Inject (AppE IntegerT MyExp) MyExp.

Maybe I just need to do the injections of the types.

So I want a way to inject IntegerT into MyType.

Okay, I had a typeo. Remember, you have to lift everything up to MyType or
MyExp before passing it to a bigger expression or type. This is very annoying
when writing the IR code by hand, but hopefully the parse will have no trouble
at all with it.

And now, let me automate generate of instances for the types too. It should be
exactly the same. I'll add an argument to the ir function.

Cool, so that's all automated, and we have types inside of expressions.

Now let's see if typechecking is made any easier.

Let me start with checkvars, which is the simpler of the two things.

class TypeCheck t e | e -> t where
    checkvars :: Monad m => Name -> t -> e -> m ()

Say? Let me just dive into code, not really knowing what I'm doing, and see if
anything comes out of it other than a big mess.

Mon Mar 26 19:22:22 EDT 2012

checkvars works now. I feel like there was a bad test case that magically
fixed itself. Oh well.

Anyway, we have more boilerplate code to do away with.
Instance TypeCheck MyType MyExp.

Mon Mar 26 20:39:02 EDT 2012

Next step: the typecheck function.

Mon Mar 26 21:09:58 EDT 2012

Nifty, so that's done, and we have type checking!

The type errors are terrible to read though, because we don't have pretty
printing of expressions. That's something it would be very useful to have.

Well, it's safe if I use parenthesis, but otherwise, how do we deal with
operator precedence? Do we go the haskell route and just use parentheses
everywhere?

Well, anything is better than what show gives us, so I should think ppr would
be just fine.

I think, perhaps, I'm running a little low on steam just now, so let me call
it a day there.

What are the next steps?

+ pretty printing of expressions and types
- VarT, UnknownT
- type inference
- parser - good luck figuring this one out.
- quoter
- add to expressions until we can implement factorial.

Tue Mar 27 13:13:29 EDT 2012

Type inference will take a little bit of thought.

What are the assumptions about types we use?

Well, there's this thing called a VarT. I think type checking has to assume
that. Then we say a VarT is less known than any other type, and a VarT with
greater id is less known than a VarT with lesser id.

Is there ever a type which should be less known than VarT?
I don't think so.

The other issue is ArrowT. This is a type constructor. Somehow we need to know
it has fields ArrowT a b, so if comparing two of these things, the types of
the fields should be set to equal.

This is not specific to ArrowT. You could imagine ListT, VectorT, MaybeT, any
sort of type constructor could have some number of arguments, and these
arguments have to match.

One way we could capture this information is by specifying a function of the
form: t -> [t]. So, given a type, return all the list of component types. And
we just say all the component types have to be equal.

This is close, but not enough to do type replacement, so map every VarT X into
the corresponding thing in the association list. Perhaps what we want is some
generic way of doing traversals? Like the traversal mechanism I had before,
just made into a typeclass?

Err... what I want is, I give you a function, it should work on types
generically. You apply that function to all your subtypes, and do some
composition of the results, and give me that back?

For example, to collect the list of subtypes, I'd say something like:

traverse id (:)?
No, that's not a good example, because it isn't a recursive kind of search.

How about more specific cases?

Constrain. We have an expression. I want to say, apply some ...

You know what? I don't think this makes sense. You have to specify type
specific composition anyway, so may as well let the type specific recursion
happen in the same place.

The goal is just to somehow make it so you don't have to specify as much for
each expression or type. Like, can I extract all the information I need in
some generic way, then apply that, but I don't think that's the case.

Okay. Let me list all the functions I think I'll need from each expression and
type in order to do type inference, and we'll see how it looks.


-- replace all occurrence of a type with some other type in the given
-- expression.
typesubst :: [(t, t)] -> e -> e

-- replace all occurrences of UnknownT in e with a VarT with unique id.
ununknown :: e -> State Integer e

-- replace all occurrences of UnknownT in t with a VarT with unique id.
ununknownt :: t -> State Integer t

-- Generate type constraints for the given expression.
constrain :: e -> State (Integer, [(t, t)]) ()

-- add a constraint that every variable with the given name has the given type
-- in the given expression.
constrainvs :: Name -> t -> e -> State (Integer, [(t, t)]) ()

-- Given the constraint t == t, reduce it to a smaller constraint.
-- So, both t's should be of the same type, otherwise you can do nothing.
-- Then, if they are the same... this feels messy to me.
subconstrain :: t -> t -> State (Integer, [(t, t)]) ()

I wonder if you could do it slightly differently. What if we had the
following:

-- Given type, return its subtypes.
unconstruct :: t -> [t]

-- Given sub types, construct the type.
construct :: [t] -> t


Now, typesubst is something like:
    subs <- unconstruct
    construct (map typesubst subs)

Now, ununknown is something like:
    
well, if we could ask for all the expressions in it, we could map on those, if
we could ask for all the types in it, we could replace those.

In other words, I feel like it's worth trying to use generics for this. If
it's not efficient, we'll see that and we can deal with it later. But for now,
isn't it much easier?

I should try getting more practice with generics. Let me see if I can't
convert more of the functions in my old seri to use generics.

Tue Mar 27 14:02:36 EDT 2012

No, I had tried that before. There are some things which are just plain
specific. Like, don't descend into a LamT if it introduce a new name. That
sort of thing. The sort of thing I'd rather not hardcode. It should be up to
each expression how it wants to do things.

I don't know.

Wed Mar 28 10:05:38 EDT 2012

I want to think about, or investigate more, this idea of leveraging haskell's
type system to do inference. I think my type inference is fine for my simple
lambda calculus, but it would be good in general to be able to leverage
haskell's type system.

The idea is this: we want to make it so when you write an expression in a
quoter or what have you, it is automatically type checked. That is, we will
convert it into a TH.Exp which constructs the object for you, and makes it
type correctly by construction.

The first thing we need is some type safe way to construct expressions.
Let me work on the old version to try and figure this idea out.

For example, in what sorts of ways can we build up expressions improperly
typed?

Application. That's a good example.

AppE Type Exp Exp

The function needs type a -> b, the expression type a, the application type b.

This only works, I fear, if we can associate a haskell type with each
expression. That's something I personally rather would have avoided. Or at
least separate out into a different step...

Okay, let's say I have a type like this:

data TypedExp a = TypedExp Exp

Now Exp stays how it was, but TypedExp is associated with a haskell type.

Given a TypedExp, it's trivial to extract the Exp without that type
annotation. So we can get at the raw thing. Oh, I like this.

Now how do we do apply?

-----
appE :: TypedExp (a -> b) -> TypedExp a -> TypedExp b
appE (TypedExp f) (TypedExp x) = TypedExp (AppE t f x)
-----

That's fine. But how do we figure out what 't' is?
Can we just do:

----
t = (convtype :: b)
----

I fear that won't work (though it would be good to try out).

Cool. I like this solution. Then I implement a Quoter which uses the type safe
constructions (we'll have to merge Quoter and Parser together). And we can
know the primitive types.

What if I want to introduce a primitive name? Say, foo, and I want it to be
typed as Foo -> Bar. To do this we would need a primitive function foo, of
proper type, that we know about and can use to construct. Fine, just use the
name foo. Easy. All you have to do is define the primitive version, you don't
have to describe this yucky undefined haskell version.

The key thing is, for Quoters, you don't have to typecheck before parsing,
only after. That's definitely a better solution than template haskell gives.

I'm confident we can do the translation. And splicing in and out of haskell
too.

I should work up a proof of concept for this though, just to make sure.

If it works, and it's easier than type inference, perhaps I should ditch type
inference entirely? I don't know. We'll see.

But cool. Nifty. Let me work at this right now, see if I can get anywhere.

Wed Mar 28 11:15:38 EDT 2012

Wow. This is neat. So I have type safe constructors for expressions, and we
get all the type information constructed we need as we go. Exactly as I was
hoping for.

What's the next part?

I want a type safe quoter. So it will have to do parsing directly from String
to Q Exp. Or Exp if I prefer, but I suspect Q Exp will be easier.

Shall I just duplicate the parser?

Wed Mar 28 13:13:13 EDT 2012

It works! My typed quoter works. That's really cool.

Wed Mar 28 13:51:37 EDT 2012

So I say, ditch my typechecking and type inference. I don't need it anymore.

Talked to Nirav. He suggests the following would be good to have:

- higher order stuff. That is, be able to write the program
    (id id) 5
Where id can have two different types.

- Declarations

+ Better use of primitives.
Meaning, I suspect, instead of: AddE Exp Exp, we'll want something like
PrimE Type Name.

Then a primitive will be: "add", and we can elaborate based on that. Or, I
suppose, you could have a list of primitives (I think I like that better).

+ For SeriType class, have a -> Type, not TypedExp a -> Type. The way to make
  it work in haskell is, Nirav claims, something like:

constseri :: TypedExp a -> a
constseri _ = undefined

Then, (seritype r) should still work.

Okay? Good. I think I'll switch back to the specific version, and avoid this
generalization thing. With haskell for type inference, I think that becomes
easier. And perhaps if we let users define their own primitives, you can stuff
all the library stuff into primitives. That sounds better to me.

Wed Mar 28 14:22:59 EDT 2012

Cool, I like this.

I think the next step is fairly clear.

Add primitives.

So, for example, Add, Mul, Fix, True, False, Lt should all turn into
primitives.

What is PrimE?

I think it should be either a String, or a Primitive, which is just a union. I
think I prefer primitive, because it makes it much more clear what you do and
don't consider a primitive, and you can write functions in primitives. That
harder part is, perhaps, parsing primitives? Annotating the type of
primitives?

Let me start with that though. We'll want functions:

prim :: String -> Maybe Primitive
primtype :: Primitive -> TH.Type?

Wed Mar 28 15:59:11 EDT 2012

The primitives I'm using: +, -, *, etc... are special in that they are infix.
Let me deal with them specially for now. The real test should come when I turn
FixE into a primitive 'fix' function.

infix has two arguments, right? I could maybe use that to make things easier
parsing.

Wed Mar 28 16:29:11 EDT 2012

Okay, so parsing of infix primitives is clean now.

I'm a little annoyed out how clumsy it is to specify how to elaborate a
primitive expression. Perhaps that can be improved in time.

Last primitive to deal with: the 'fix' primitive.

First step: preserve my special syntax. Second step: dump the special syntax.

Wed Mar 28 16:39:06 EDT 2012

Actually, here's an idea. True and False should be made primitives. I can use
that to work out the naming thing. Then change the syntax for fix. Then try to
make fix a primitive. Let's see how that goes.

Wed Mar 28 17:24:31 EDT 2012

Fix is now a primitive.

So, where am I at?

I'm at a point where everything is wonderfully clean, especially now that we
have primitives. Everything, that is, except specifying how to do elaboration
of primitives. That parts rather annoying. Oh well.

It's good. I like it. Very much. What's next?

Well, I can try out Nirav's (id id) 5 thing. If I make id a primitive, I
suspect it will work fine. In fact, that's how fix works. Perhaps the real
question is, can I make (id id) 5 work even if id isn't a primitive. If id is
defined in the language.

So, that brings us to the next step, which I think is rather clear.

We want to have global declarations.

That is, I want to be able to write the code:

----
[st|
    factorial :: Integer -> Integer
    factorial = fix (\f -> \x -> if (x < 1) then 1 else x * f (x-1))

    main :: Integer
    main = factorial 5 
|]
----

Okay, fine, what have you.

Now, say we have this context. Now we want to run an expression within this
context. Perhaps we can have a main expression to evaluate? Or perhaps
elaboration takes place in this context, or...?

We could put primitives into the language naturally this way too. Just give it
an initial context.

Hmm... so that could cause problems with type inference... it would seem we
have to know the context ahead of time?

Perhaps we will?

Err... I don't know...

We could have declarations. Maybe the idea is this, when you declare a seri
function foo, it defines in a global scope: '__seri_foo',  which is an
implementation of the TypedExp for that function, annotated with the correct
type. Now, whenever I have a variable name when parsing, look it up in the
relevant context to figure out if it should be free or not (is that doable?),
then replace that with a call to '__seri_<name>'.

No. That's not what we want. What we want as to keep it as a variable, but
give it the right type, so we want something like:

----
varE :: a -> Name -> TypedExp a
----
Where the 'a' argument is used solely for typing, it is otherwise thrown away.
Now we get the name, we get the type, we have the source for the primitive.
That's perfect, no?

So, I think the next step is to try adding declarations of the form: name,
type, expression.

How about this. I'll have declarations, and I'll have them define this
'__seri_<name>' at the top level, and then I'll let the haskell user run it by
referring to '__seri_<name>'.

So, the test is this: have the declaration st brackets in a top level haskell
context implement factorial and foo. Then for my test, elaborate foo. Easy...?

One issue will be looking up global contexts in names. Well, let me work that
out when I come to it. I think the idea for now is clear.

Wed Mar 28 18:59:39 EDT 2012

I have a plan. Here it is.

We add a Dec type for declarations. The first kind of declaration we we'll
implement, and the only kind for now, is a declaration of the form Name, Type,
Exp.

When we generate code for declarations, we'll do it in a declaration context.
So declarations in the IR correspond do declarations of haskell functions.

The haskell declaration for foo with type t and expression e will be:

----
_seri__foo :: TypedExp t
_seri__foo = e
----

Um, that's a little imprecise. Basically we keep track of the top level
haskell type information for the expression.

The other thing we'll want, perhaps eventually, will be to have the notion of
a context. Hmm... this might be important. Hum...

Anyway, the idea is this. A context is just a list of declarations. Now I
don't know of any way to say: here is the context for every declaration we've
ever made. But what I can say is, here is all the context that is used by a
declaration. So for each declaration, we also generate the haskell
declaration:

----
_serictx_foo :: [Dec]
_serictx_foo = nub (_serictx_a ++ _serictx_b ++ ...)
----

Next question: how do I figure out which variables refer to things in the
context, and which are free variables? Can I figure it out while parsing?

You know? I think I could. Just add state to the parsers which is the set of
bound variables. If you encounter a variable, and it is not bound, you assume
it is declared. Then generate '__seri_xxx' for it. Simple.

Cool. This is nifty.

I guess we have another question. How to do elaboration? In order to do
elaboration, we have to have a context.

Fine. Just make elaboration take place in a given context. That is, you pass
an explicit context to the elaborate function.

Good. So, first test case: declare factorial. Declare some foo which is
factorial of 5. Then elaborate it in the context.

For the first step, let's not generate the context in the parser, I'll just
specify it manually. In the second step, I'll generate a context for each
declaration automatically.

Cool? Cool. Let me see what I can accomplish today, see how much I can get
done.

Wed Mar 28 19:11:40 EDT 2012

Oh! I just thought of something... Never mind. I was just thinking another
thing we could do is make the types more generic, have type constructors and
type application and such, but that can come later just fine. So, onward to
declarations.

Wed Mar 28 19:54:07 EDT 2012

Okay, so I now can parse declarations and define the '__seri_foo' thing.
The next step will be, I fear, a little trickier.

The goal is this: elaborate should take a list of declarations as input.

I suppose there are two parts. Perhaps the first is, we want to be able to
refer to existing declarations in other declarations.

so, I should be able to write:

[s| 
    fact5 :: Integer
    fact5 = factorial 5
|]

I suspect if I try that now it will fail, because it will say factorial is
undefined. Yes. That's exactly what happens.

Now I need to do the following: any name foo which is not already bound to
some other identifier (from a lambda) should be translated to '_seri__foo'.

No. That's wrong. That's not right.

What we really want is to translate it into a VarE, but a VarE which is
properly typed.

So, for example, tvarE :: TypeExp a -> Name -> TypedExp a, where the first
argument is a throwaway, just for type purposes. What we'll use for that
argument will be '_seri__foo'. Cool, eh?

First step: let me try to manually detect out of bounds names. The goal is to
find a name which isn't already bound.

You know what? This is cool, it's fun, a great next step. But I think the work
can wait until tomorrow.

Steps tomorrow:

+ throw a parse error if a name is not bound or primitive. Verify it throws
  errors where I expect the way I expect.
+ replace unbound names with tvarE '_seri__foo' 'foo'. Verify declarations
  compile, but elaboration gets stuck.
+ add [Dec] as an argument to elaboration. Construct a [Dec] manually and
  verify elaboration now works as desired.
+ automatically create '_serictx_foo', verify that now we don't have to
  manually construct the declarations.
+ Make 'fix' like any other name rather than having it be parsed specially.
  (It still needs to be a primitive, unfortunately, in order for elaboration
   to work)
+ Try out '(id id) 5', see if it works. I think it will, I just need to have a
  VarT kind of type.

Then I'll be in good shape. That might be a good time to update Nirav on the
status.

Thu Mar 29 08:57:30 EDT 2012

Names are bound by lambdas. So here's the strategy. We keep a set (list?) of
the names currently bound. When we get a lambda, we add to the list. 

Yes, let's have a list, which is really a stack. So we add to the head of the
list new names, we pop from the head of the list when we go out of scope. That
will handle shadowed variables correctly.

Now when I encounter a variable name, I can ask if it's in this list or not.

Thu Mar 29 09:33:32 EDT 2012

Now we want to automatically create '_serictx_foo'. So we need to add more
user state to the parser.

For every declaration we parse, I want a list of the variables used.
Now for each one, I create a ValD.

What do I need? Well, I can have a function

valD :: Name -> TypedExp a -> Dec
valD nm t = ValD nm (seritypeE) (typed t)

So all I need is the name.

Thu Mar 29 10:21:20 EDT 2012

Next step: having the parser not need to know about fix. I should be able to
do the same for True and False too. That is primitives (aside from infix,
which is special at this point) need not be known in the parser.

Just replace trueP and falseP and fixP with _seri__True _seri__False and
_seri__fix, and their corresponding contexts.

Thu Mar 29 10:30:12 EDT 2012

Turns out True and False were easy. The problem with fix is it requires
variable types. So, let me try to declare a polymorphic function (id), and add
what I need to make that work. Then I can pull out fix.

Thu Mar 29 10:35:59 EDT 2012

Hm... It says: not in scope, type variable 'a'. What am I doing wrong?
Err... do I need to say something like: forall a. a -> a?

Okay, step back. Now we have VarT, I should be able to do fix. Once I have
fix, use that as a template for the kind of code I have to generate. I think
it has to be something like: (SeriType a) => a -> a;

Thu Mar 29 10:58:29 EDT 2012

Okay, yes. So there are some rather unsatisfying things about making fix work.

First is, to extract the expression from _seri__fix, I need to give a dummy
type for fix. And it needs to be a SeriType dummy type. For example, I picked
the type as (Bool -> Bool -> Bool. But I hate making such an arbitrary
decision.

Here's an idea. What if we had some predefined concrete haskell types
corresponding to variable types? Like BCL does. So we define types:

data VarT_a = VarT_a
data VarT_b = VarT_b
data VarT_c = VarT_c
data VarT_d = VarT_d

And maybe 4 is enough, because really, how many do you need?

Then, when parsing a type, we only allow the type variables "a", "b", "c", and
"d". And they are parsed into these VarT_a, VarT_b, VarT_c, VarT_d.

We make each of those an instance of SeriType, which maps them to VarT "a",
VarT "b", VarT "c", VarT "d".

Now the dummy type I can use is VarT_a.

The next problem is one with elaboration. Specifically with regards to
primitives I suspect. I don't think this is related to the type issue.

But I have to understand what's going on. I think the thing is, we pattern
match on primitives, but what if they aren't applied directly as primitives,
but applied, like fix, as a function. So what I should really do is try to
elaborate them, see if they are primitives, if so, advance and elaborate
again, and so forth.

Let me try to fix the elaboration problem with the current state of 'fix'.
Then I'll consier adding VarT_a, etc...

Thu Mar 29 11:05:37 EDT 2012

Okay then. How to clean up elaboration of primitives?

Primitives take some number of arguments.

For example: TrueP, FalseP, take 0. FixP takes 1. AddP, MulP take 2.

Let's stick to the special case for now, which is the case assuming you can
elaborate away a primitive (with more than one argument) if all of its
arguments are ...

TrueP, FalseP - can't ever elaborate more.

Hmm... maybe that's an important observation. When we get a primitive, it's
primitive. There's no way you could elaborate it more, otherwise it wouldn't
be primitive.

The real thing we want to do, is in some cases we can have an expression
containing a primitive, and that lets us simplify the expression.

For example, I can reduce the expression
    if (TrueP) a b  to a.

This is like a reduction rule. Maybe I should read up on how Nirav did this,
and his references to how ghc does it.

I'll do that. I'll also spend a little time brainstorming first, to better
understand what I read.

So we say we have these reduction rules. If your expression has this form, we
can reduce it to this other form.

The problem is: I can perform a reduction in some local context, which makes
another reduction available in a more global context which I can't see from
the local context.

What we really want is, after reducing parts of an expression, try again to
see if we match any rules from before.

For example, consider AppE a b. Currently the way I elaborate it is by saying:
elaborate a, if it's a lambda, then I can do the substitution. But what I
should be saying is: elaborate it, if it's a lambda, then I can do the
substitution, otherwise, I can try to elaborate it again after the components
have been elaborated.

The fear is that I'll get stuck in an infinite loop.

So how about the following. Change elaborate from Exp -> Exp to Exp -> Maybe
Exp. It returns an elaborated expression, if that expression could be
elaborated.

Now how would this look?

IntegerE, PrimE = Nothing
AppE Lambda - do a reduction, elaborate the result.
AppE general - elaborate f, if it could be, then elaborate the expression. 
AppE AddP IntegerE IntegerE - do the reduction.

So, in other words, we only do the elaboration if it matches exactly. We let
AppE take care of elaborating components if needed.

I think this will be cleaner, simpler to specify, and more correct.

So, what do you say? Are you willing to try it?

Thu Mar 29 11:43:41 EDT 2012

Cool. It works. And it's a much nicer way of specifying elaboration, not only
for primitives, but also the other constructs.

Thu Mar 29 11:45:15 EDT 2012

Okay, now I can go back and try VarT_a, VarT_b, etc... Right?

First use it to make specifying _seri__fix much easier.
Then use it to try and make id work (but after understanding the code I have
to generate for it).

Thu Mar 29 11:49:52 EDT 2012

Okay, so, given a polymorphic function, what code do I need to generate for
it?

1. The polymorphic haskell TypedExp corresponding to it.
for example: _seri__id :: (SeriType a) => TypedExp (a -> a)
We need each variable type to be an instance of SeriType.

2. A concrete haskell TypedExp corresponding to it.
for example: _sericon_id :: TypedExp (VarT_a -> VarT_a)
             _sericon_id = _seri__id

3. A context based on the concrete version of it.
for example: _serictx_id = [valD "id" _sericon_id]

There's a question of whether or not the user would want to refer to (2). I
think they do.

So I propose a new naming convention, now that we have 3 haskell things
corresponding to each seri expression.

_seriP_<name>   The haskell polymorphic version of the function.
_seriC_<name>   The haskell concrete version of the function.
_seriD_<name>   The declarations for the function.

Furthermore, I propose every expression, both polymorphic and concrete, have
both polymorphic and concrete implementations. For concrete ones, you'll just
have that _seri_P_ and _seri_C_ are exactly the same. That's fine.

That's my proposal. Let me try it out after lunch. I believe this will work.
We just have to limit the number of type variables available to the user.

Thu Mar 29 12:48:25 EDT 2012

Okay, so what is it I want to do? I think we have the following steps:

1. Collect the set of all type variable's used in a type.
For current examples this will be empty. So, assert it's empty, and get the
thing to work with all current examples.

2+ Rename _seri__ to _seriP_ for the no type variable case.
Still assert the non-empty type variable case.

3+ Implement _seriC_ as _seriP_ for the no type variable case still.

4+ Rename _serictx_ as _seriD_.

5. Implement the non-empty type variable case.
 - Add Forall [typevars] t to signature of P
 - Substitute all TH.VarT x with VarT_x to produce the signature of C

And that should be it.

All of it is straight forward.
And then it should work, right? Yes. Then (id id) 5 should work just fine.

Thu Mar 29 14:37:43 EDT 2012

It works :).

Now what?

Thu Mar 29 14:52:39 EDT 2012

I think the next step is to start using the IR for things.

Use it for Tibby. Use it to do SMT queries. Use it for structural spec?

Because now it has everything. Now I'm confident it can have everything we
want, it's just a matter of using it now.

Thu Mar 29 16:34:25 EDT 2012

Okay, so the real question is, how can we use it as a library. How can we all
share the work each other does?

That is, we have different languages, with different constructs. There will be
a common core. How can we pull out the common parts into a library that
everyone can use, while letting everyone extend it in a reasonable way?

One idea is what I was trying before. Parameterize each construct by the IR
type and expression, as needed, and use template haskell to assemble the
constructs together into the type level IR type and expression. I believe this
will work, but it's messy.

Perhaps the question is, what things is it that you need to describe to add a
new construct in a reasonable way?

Perhaps the way to figure this out is to add some construct, and keep track of
everything I had to do for it.

I think you need to do the following:
 - add types
 - add expressions
 - add declarations
 - add pretty printing of all that
 - add rules for elaboration
 - add rules for properly typed construction
 - add a way to parse them.

Another idea I want to mention is using template haskell to collect together
features.

So, say each feature has some dummy type.

data IF = IF

Now that can be an instance of things.
So, for example, we need the form of its constructor.

cnstr :: IF -> Con
cnstr = NormalC "IfE" ["Type", "Exp", "Exp", "Exp"]

Or something to that effect. Then I can have these components, which assume
the names Type, Exp. I specify them in different places.

And for my type level IR, something like:

data IRSpec = IRType INTEGER BOOL ARROW VAR
            | IRPrim ADD SUB MUL ...
            | IRExp  INTEGERE PRIME APPE ...
'mkir ''IRSpec

And that can define everything we want for us.

Well, of course, that's silly. If you're going to do that, why not go all the
way and just define a language for specifying IRs and implement a quasiquoter
for it?

I don't know. I think, really, the question is what all work is involved in
extending the IR with the constructs I want. Until I understand that, it's a
little premature to try making it into a library, no?

How about this. Murali will work on extending it to Structural Spec. I'll work
on extending it to SMT, or Tibby, then we come back, compare the two, factor
out the common code, and thus we have the starting of a library.

Fine.

Fri Mar 30 10:21:05 EDT 2012

I want to clean up how types are done, make them more general.

Which means, I want to change ArrowT Type Type, to just ArrowT. And I want to
add AppT Type Type to do type application. Should be simple.

Fri Mar 30 10:32:15 EDT 2012

I'm not sure how far to take this. Do I need BoolT, ArrowT, IntegerT? Can I
just make those ConT "Bool", ConT "Arrow", ConT "Integer"? I don't know. That
worries me a little.

Perhaps you want it just like expressions, you want a PrimT, and it contains a
primitive type, and the primitive types are Arrow, Integer, Bool.

You know what, I don't want to worry with this until I have some compelling
reason to change. So let me leave it where it is for now.

Fri Mar 30 11:50:11 EDT 2012

I definitely want to make primitives easier to declare. So let me do that.

Let me go with template haskell on my first attempt. The question is, can I
have a context in a [t| ... |] quote?

Fri Mar 30 13:50:19 EDT 2012

The answer is yes! Thank goodness. I'll use that then.

The code will overlap with code in the Quoter. It would be good to share.

In particular: Looks like I'll want to do a type traversal to replace VarT "x"
with VarT_x for concrete version. That should simplify the parser.

Fri Mar 30 14:26:13 EDT 2012

Cool. It works. Works swell. I like it a lot. Good work.

Sun Apr  1 09:04:39 EDT 2012

I want to make it so you can have multiple declarations in a single quote. The
problem is, I can't figure out how to make the parser work for that. So I
added to a declaration a ';' character, which makes it obvious.

I'm not so happy with this solution, but it will serve until I can figure out
how to make the parser infer the semicolon.

Sun Apr  1 09:07:47 EDT 2012

Oh, look. If I pollute the parsing of an expression to include a notFollowedBy
'::', then it works. That's a little unsatisfying. Like, why should an
expression have to know about type declarations?

Oh well. I get what I want for the input, and if I can clean up later, then I
can clean up later.

Sun Apr  1 11:09:32 EDT 2012

Idea for how we can handle overloading.

So the issue is this. Currently seri is a subset of haskell, aside from the
@() slice. I'd like to keep it that way as much as possible, because it seems
like a nice thing to have.

The question is: how do we handle overloading? Typeclasses? I have two things
specifically in mind. First is monads and do notation. Second is overloading
of operators +, <, etc... which I expect to be common.

Well, here's my proposed solution. The question is, how generic do you want to
be? Do you want to allow polymorphic declarations in seri that have some
context? I say, perhaps, yes, you would want that. But what if you don't need
that? I think you can still get much of the behavior you want as follows:

For example, consider the primitive +. Currently the type signature is
something like:

_seriP_add :: TypedExp (Integer -> Integer -> Integer)

If I want it overloaded, change it to

_seriP_add :: (Num a) => (a -> a -> a)

Now, the concrete version _seriC_add will lack this requirement that a be an
instance of num, but the built up expressions will have that requirement.

Same could be done for return.

_seriP_return :: (Monad m) => (a -> m a)

assuming "m" was an allowed type variable (we could easily add it).

This works for monads of primitive type. I don't know how return would be
implemented for other types, but I don't know how we would do user defined
types yet either.

I don't know. Maybe it's a hack. Maybe it's useful or maybe not.

It almost makes you wonder if there's some easy way to do elaboration
leveraging haskell.

For example, could you convert a Seri expression to its corresponding haskell
type, evaluate it, then return it back?

That sounds very messy to me.

Anyway, things to think about.

Sun Apr  1 13:55:37 EDT 2012

I'm bored, so let me just spew out some thoughts.

Here's a question. Or rather, the question. About whether we can easily share
a core library and have each person extend it in his own way.

Let's say we have type ConT. So really, we only need the following kinds of
types: ConT Name, VarT Name, AppT. Then Integer, Bool, Arrow, Unit, they are
all just type names.

Now let's say a Primitive is really just a string. Just a name. So, primitives
are like: "add", "sub", "mul", etc...

Now for elaboration, we can provide a function for each primitive of the form
Exp -> Maybe Exp, which does some reduction.

And for each primitive, we declare its type separately.

Then my claim is, primitives can be all imported separately.

Then you can have a library. For example, an SMT library. Or a Tibby library.
Or a structural spec library.

Hmm... I have my doubts.

SMT works because you describe a query as a function. It doesn't add any new
sort of construct.

What if we wanted to have a new kind of type, an interface type? What about
parsing of special constructs?

For example, what if you want a module type? Can that be encoded as a monad
with some primitives?

What's my fear with using string names for primitive types and expressions
rather than a constructor of a data type?

There's only really one issue. Name conflicts. What if two people specify
primitives with the same name and want them to be different?

The other issue is documentation. How do you know what all primitives are
supported by a component? When you put them together, how do you know there
will be no clash?

I fear it will become like bcl.

And I'm not convinced having named primitives will suffice for all the sorts
of extensions we'll want to do.

I should put it to the test.

The other question is how to deal with infix operators. Because I guess,
currently, they are handled specially. But they need not be, I suppose.

Um, that sounds tricky. Let me not worry about infix things yet.

For SMT to work this way, we need user defined data types. Because, for
example, we want a type for Answer, which is an algebraic data type.

In other words, I'm not sure this will help. I'm not sure it's an improvement.
But it might be. It might be all we need to make the library extensible.

I just really hate the naming issue.

How about this. We agree that, for SMT to work this way, we at least need user
defined data types. That's something we'll need for any place we use this. How
about this. First implement user defined data types, then try doing this
primitive thing, and merge the two branches master and smt, and see if smt
becomes like a library component. One that can be pulled out and compiled
separately. One that treats the core as a library package itself.

That sounds reasonable to me.

Okay then. How to support algebraic data types?

Each algebraic data type has a list of constructors. Each constructor takes
some number of arguments of different types. A constructor is just a function.
The representation of the data type as an expression is just a constructor
function application.

For example, consider 

data Answer a = Unknown | Unsatisfiable | Satisfiable a

This defines 3 constructor functions:

Unknown :: Answer a
Unsatisfiable :: Answer a
Satisfiable :: a -> Answer a

To represent an Answer Integer of value Satisfiable 4, it would take the form
of an expression which looks like:

AppE (ConE "Satisfiable") (IntegerE 4)

This is all well and good. The real question is, how do you deconstruct a user
defined data type? Given some Answer a, how do I figure out if it is Unknown,
Unsatisfiable, or Satisfiable? And if it's Satisfiable, how do I access the
first argument?

It seems as if the answer is, much as I hate to say it, use pattern matching.

If I could specify a pattern, I could use that to give names to the parts.

So, we would have a case statement.

CaseE Type Exp [Clause]

where Clause has: Pattern Exp.

And Pattern is: wildcard, constructor, variable, application. That sort of
thing.

For example, I could have an expression:

CaseE _ myanswer 
    ConP "Unknown" -> ...
    ConP "Unsatisfiable" -> ...
    AppP (ConP "Satisfiable") (VarP x) -> ...

Okay. What would the elaboration rule look like for this? How do we reduce a
case statement?

We have to have some way to match a pattern against an expression.

match :: Pattern -> Exp -> Maybe [(Name, Exp)]
match (ConP pname) (ConE ename) | pname == ename = Just []
match (VarP vname) e = Just [(vname, e)]
match (AppP ap bp) (AppE ae be) = do
    anms <- match ap ae
    bnms <- match bp be
    return $ anms ++ bnms 

That all looks reasonable.

For now, let me just allow patterns at case statements.

Now the question is, how can we ensure a pattern is well typed? How can we
construct a pattern in a type safe way?

It seems like a pattern should be associated with a haskell type, no? And a
clause is associated with a haskell type.

mkClause :: Pattern a -> Exp b -> Clause a b
mkCase :: Exp a -> [Clause a b] -> Exp b

Okay, so say I want to have the pattern (Satisfiable x). How do I construct
that?

mkPattern (_seriTCP_Satisfiable) (varP "x")

Where _seriTCP_Satisfiable has type (Pattern Seri_Answer).

Which brings us now to the question, what all things should we generate for an
algebraic data type definition? Sounds like we want the following:

- A corresponding haskell type, for use with type checking.
data Seri_Answer a = Seri_Unknown | Seri_Unsatisfiable | Seri_Satisfiable a

- For each constructor, a constructor function
_seri_Satisfiable :: TypedExp (a -> Seri_Answer a)
_seri_Satisfiable = TypedExp $ ConE "Satisfiable"

- For each constructor, a pattern to match it.
_seriM_Satisfiable :: Pattern (Seri_Answer a)
_seriM_Satisfiable = ConP "Satisfiable"

You know what? That could actually work.

I worry about the fact that Answer is a type constructor based on 'a'. Clearly
that should come as a second step. The first step will be monomorphic user
defined algebraic data types.

Wow. That's... it could work.

What do you think? Should I try it out? Try implementing like...

data Bool = True | False

Or

data AnswerInteger = Unknown | Unsatisfiable | Satisfiable Integer

Or

data Rational = Rational Integer Integer

data Complex = Complex Integer Integer

Clearly polymorphic data types will be important.

Here's a concern. Can patterns be easily generated to backend code? Like C? or
Yices? Somehow I think yes. Because patterns are a higher level construct
than if/else and member extraction.

I think it's worth a try. Do it, see how I like it. Figure out how hard it
would be to make data types polymorphic.

First step? I think I need a dummy test case. 

data Foo = FooInt Integer
         | FooBool Boolean
         | FooIntBool Integer Boolean

foo :: Foo -> Integer
foo = \x -> case x of
                FooInt i = i
                FooBool b = if b then 1 else 0
                FooIntBool i b = if b then 1+i else i

Or something like that.

Or I could start with Booleans.

Sun Apr  1 15:03:23 EDT 2012

Okay, so what are all the steps I need here?

+ Switch to using ConT instead of IntegerT, BoolT, etc...
- Parse data type declaration
- Generate Seri_Foo haskell declaration
- Define pattern
- Add Case expression
- Parse case expression
- Add Data type declaration.
- Generate constructor functions
- Generate constructor patterns
- elaborate case expression

That's rather a bit to do. But I think I've gotten all the ideas worked out
well enough that I can try doing it all, then fixing issues as they arise.

Cool. Sounds like a plan.

Sun Apr  1 18:58:52 EDT 2012

This question came up. It seems like I'm just replicating everything in
haskell into seri. So why not just use haskell? Why not hack the ghc compiler?
Or use the template haskell IR?

What do we really want to have?

We want the following:
 - parsing
 - type inference
 - type checking 
 - access to source for everything

Hum. Or something like that anyway.

The problem with using monads in haskell is we don't have access to the
source. This is the problem with tibby. It's the problem with smt.

So I checked out the ghc source. It's complicated. We don't want to go there,
trust me.

But what about using the template haskell IR? Why can't we do that?

We can still write our own parsers.
We have all the features of haskell.
We can use haskell parsers.

Types map one to one between haskell and ... uh haskell.

It's complicated, but not nearly so much as ghc.

Oh. I know the problem. We don't get any type information in the template
haskell IR.

Well. That answers that question pretty well then, doesn't it. I should stick
with seri IR.

That's good to know at least.

Then let me get started on user defined data types.

Sun Apr  1 19:14:32 EDT 2012

How to parse a data type declaration...

We have the form:

data NAME = NAME TYPE1 TYPE2 ...
          | NAME TYPE1 TYPE2 ...
          ...

What do I want to parse it into? I could parse it into a data type declaration
I suppose. That would be logical, no?

Except, in the type I generate, I'll want to change names and such.

How about like this.

each constructor gives me a (Name, [Type]) list. Okay?

Or, does it make sense to parse it into a haskell declaration?

I think it does. Let me do that.

Actually, this is a good idea, because it means I have some function which
knows how to generate the declarations I want for a data type definition given
a TH definition. Or, in other words, I don't need to declare a data type
definition in [s|...|] brackets. I can just pass an existing defined type to
this function.

You know? I think I prefer that to get started.

So, don't change the parser yet. First we want to write a function which,
given a data type declaration, generates...

Well, we don't need haskell declarations if it's already been declared in
haskell. That's nice. Otherwise I could just include given declaration. Naming
issues... blah blah.

So, assuming the type is already a haskell type, I would want the following:

_seriM_Foo for each constructor.
_seriP_Foo, _seriC_Foo, _seriD_Foo for each constructor.
instance of SeriType

The P,C,D functions should be trivial by reusing what I have.

Let me start with those then.

Sun Apr  1 19:29:39 EDT 2012

This brings up an interesting question. Why use quasiquotes. Why not use
template haskell? I can do the same sort of type thing. The same sort of
conversions and declarations. It just already has the parser for everything we
could want to parse. No?

That's an interesting question.

Oh. I remember. Template haskell requires you to type check before as well as
after. We could use a haskell quasi quoter, which wouldn't have that problem.
I guess it's the same sort of interface?

It's certainly an interesting idea. What would things look like then?

Instead of String -> TH.Exp (TypedExp a)
we do String -> TH.Exp (a) -> (TypedExp a)

If it's doable, that actually sounds like a good idea to me.

Can I try that before trying data types? Sure, why not?

First step: let me change declval to take a TH.Dec as input.

Err... maybe I should start by treating this as a different input path.

I could make a HSQuoter. Start by just supporting expressions.

Sun Apr  1 19:56:19 EDT 2012

You know what? I think this actually could be much cleaner. All the parsing is
done for us. If you want to extend the syntax, write your own quasi quoter for
just the extend part. Well... that won't work for extending the expression
syntax. But I don't expect that to be an issue.

Sun Apr  1 20:15:46 EDT 2012

It seems to work...

What we don't get is slice, because parsing that hasn't been implemented yet
apparently.

Perhaps I can have a special function I recognize. Like, uh... _@?

Sun Apr  1 20:24:28 EDT 2012

You know what? This totally works. I'm very much sold on the idea.

Let me completely replace Quoter.

What I need next: handle declarations.

Sun Apr  1 20:50:13 EDT 2012

And now I have declarations. Let me just clean stuff up now.

It's all clean. That was easy.

Mon Apr  2 17:51:19 EDT 2012

Next step: I need patterns in order to handle pattern matching. So I propose
we add: ConP, VarP, and AppP. and maybe WildP. Let me compare with TH's
patterns and see if there is any similarity.

After patterns I can define patterns and constructors for each field in a data
declaration, as well as an instance of SeriType.

Then I implement case statement, and I have user defined algebraic data types.

+ Define pattern: ConP, VarP, AppP, WildP
- Generate constructor patterns, constructor functions, SeriType instance.
- Implement case statement

Looked at patterns in TH. They do it a little differently. They have ConP take
a list of patterns to match against the arguments instead of having AppP.

I suppose that makes sense. You don't want to have a pattern like: x a b,
where x stands for a constructor. Fine.

I think it's easier to implement if you have AppP, but I should be able to
achieve the same thing with ConP using folds and unfolds and what not and what
have you.

Cool. Let me write up patterns.

Done. Now constructor patterns, constructor functions, and seritype instance.

data MaybeInteger = NoInteger | JustInteger Integer

This should generate the following:

_seriM_NoInteger :: TypedPat (MaybeInteger)
_seriM_NoInteger = conP "NoInteger" []

_seriM_JustInteger :: TypedPat (Integer -> MaybeInteger)
_seriM_JustInteger = conP "JustInteger" ...

Um, trouble. I want the pattern to just represent the constructor, right?
So I guess, what we really need, is to take a list of patterns as input. Or...
a tuple of patterns of the right type?

So you see now why I wanted AppP? We can let the parser enforce the right
structure.  But if I have AppP, then I can do

_seriM_NoInteger :: TypedPat (MaybeInteger)
_seriM_NoInteger = conP "NoInteger"

_seriM_JustInteger :: TypedPat (Integer -> MaybeInteger)
_seriM_JustInteger = conP "JustInteger"

Now, if I have the pattern: JustInteger 4, I would construct it as:
    appP :: TypedPat (a -> b) -> TypedPat a -> TypedPat b

  appP _seriM_JustInteger (integerP 4)

And it would be a well typed pattern.

Okay, so let me go with this instead. Push through, see if it works or not.

Good. So I'm generating the following:

_seriM_NoInteger :: TypedPat (MaybeInteger)
_seriM_NoInteger = conP "NoInteger"

_seriM_JustInteger :: TypedPat (Integer -> MaybeInteger)
_seriM_JustInteger = conP "JustInteger"

_seriP_NoInteger :: TypedExp (MaybeInteger)
_seriP_NoInteger = conE "NoInteger"

_seriC_NoInteger :: TypedExp (MaybeInteger)
_seriC_NoInteger = _seriP_NoInteger

etc...

Mon Apr  2 18:18:22 EDT 2012

It seems to make more sense to implement CaseE first. More natural in terms of
test driven.

So, how do I build a caseE?

caseE :: TypedExp a -> [TypedClause a b] -> TypedExp b

Some observations:
    I want to define:
        data Clause = Clause Pat Exp
        Typed Pat, Typed Clause
       But a typed Clause takes two arguments. Or maybe I can just represent
       it's type as a function. Given an expression of type a, matches it and
       turns into an expression of type b. That sounds reasonable to me.

So I want Typed to be more generic. I can do that as a first step. It could be
messy.

Mon Apr  2 18:28:19 EDT 2012

I made Typed more generic. What's next?

+ Define Clause. Okay, call it Match instead.
+ define caseE.

That's all I have time for now. Next steps:
 + uncomment that test case
 + implement quoter conversion for CaseE
 - solve other issues as they arise by test.

Wed Apr  4 18:35:33 EDT 2012

Issue: patterns introduce bound names for VarP. So somehow I need to add the
bound name to the list of bound names for a match, then undo it when it's
undone.

So let's say a pattern adds to the bound names, and the match undoes those
after the expression is done.

I'm getting the error: Not in scope: 'i'...

So, a pattern binds a name. But we convert it to a seri pattern... I need a
lambda somewhere, like with lamE. Something to make sure the pattern variables
are bound with the right type expression in the body of the match.

For example, how would I construct the match:
  JustInteger i -> i

in a well typed manner?

The pattern has type MaybeInteger.
The variable I has type Integer, set when we form the pattern.

_seriM_JustInteger :: Typed Pat MaybeInteger
_seriM_JustInteger = conP "JustInteger"

appP (_seriM_JustInteger) (varP "i")

The type of the varP result is a Typed Pat Integer. Hmm... So what I really
would like, right, is to say we have a variable 'i' which is used in both the
pattern and the match. Can I do that? Something like:

\i -> match (appP (_seriM_JustInteger) i) (varE i)

uh... but what is the type of i? In the one hand it has type pattern, in the
other it has type expression. Maybe we need two inputs of the same type.

\ip ie -> match (appP (_seriM_JustInteger) ip) ie

Hmm... This sounds... worrysome. Let me think a bit about it more. Clearly
there is some fundamental stuff going on that needs be worked out.

Fri Apr  6 19:46:56 EDT 2012

This is right. This will work.

The idea is as follows.

1. Get the list of VarP names in the pattern.
There should be no duplicate names. If there are, it is an error.

2. Add the list of names to boundnames.
3. Translate the match to an expression.
VarE get's translated as normal.
VarP get's translated to the name prefixed with "p_" or some such convention.
4. Apply the names.
That is, call this mkmatch function

mkmatch :: Name -> (Typed Pat a -> Typed Exp a -> Typed Match b) -> Typed Match b
Where Name is the name, and function is a lambda: (\p_n n -> exp). This gives
you a new expression to use as the body for the next name. You'll have a
lambda for each name.

Simple.

So here's what I need.

mkmatch does the steps described above.
mkpat takes the set of names as input. It need not be state.
We need a ... lamM? or bindM? Or... varM? That is, a match with a variable
pattern? Sure.

Understood? Let me try it out and see what issues I run into.

Fri Apr  6 20:12:20 EDT 2012

Cool progress. I think I generate a good expression for case now.

The next thing I need is: add the data type.

In particular, first step is an instance of SeriType.

That's easy to do. Maybe I'll do it by hand just for now, then later automate
it.

That's all I needed to make it compile.
Next question is, can I run the test cases?

I need to generate _seriP_JustInteger. That is, the constructor function.

What does it look like? What is the constructor function? A ConE, right?

Yes. Let me have ConE, to keep it distinct from VarE. A ConE in elaboration
should not be looked up. It should be treated like a primitive, or something
irreducible.

So, I want

_seriP_Foo :: Typed Exp MyType
_seriP_Foo = conE MyType "Foo"

I can reuse declval for this.

Oh. But constructors can take arguments. So I should handle that
appropriately.

This is more than I feel like doing tonight. I'll do it later.

Sat Apr  7 07:59:04 EDT 2012

Later as arrived it would seem.

Say we have a constructor Foo with types A B ...

We want to define:

_seriP_Foo :: Typed Exp (A -> B -> ... -> MyType)
_seriP_Foo = conE "Foo"

So that's pretty easy. I just want to turn a list of types into a sequence of
applications of types.

I can use the declval function to generate the code for me.

This should actually be pretty easy. Let me try it out.

Sat Apr  7 08:16:22 EDT 2012

Good. Now we get to the elaboration phase.
I'll want to add elaboration of ConE, CaseE.

Okay, so the question is, what is the elaboration rule for CaseE?

Well... the idea is, we need to reduce the expression enough to check it
against each of the matches. But we have to check it against the matches in
order, and some of the matches may require more or less reduction of the
expression.

Perhaps better would be to start by trying to understand how to match
patterns?

ConP nm    matches   ConE nm
VarP nm    matches   *
AppP a b   matches   AppE ae be   when a matches ae and b matches be
WildP      matches   *

The goal of a match is to produce a mapping from variable name to expression.
Once we have that, we can do all the beta reductions, and that's our
reduction.

I think we'll want to distinguish between the case when a match outright fails
and when we don't know if that match fails or not, because the expression
isn't reduced enough.

We have to consider just the two cases: ConP and AppP.

ConP. Here are the cases:
 IntegerE - fail
 PrimE - unknown (because maybe it can be reduced more)
 IfE - unknown
 CaseE - unknown
 AppE - unknown
 LamE - fail
 ConE - succeed if name matches, fail otherwise
 VarE - unknown

That's pretty straight forward.

AppP now:
 IntegerE - fail 
 PrimE - unknown
 IfE - unknown
 CaseE - unknown
 AppE - try submatches and fail, unknown, or succeed based on result
 LamE - fail
 ConE - fail
 VarE - unknown

So my vote is the following. We have a function which attempts to do a match.
It returns: Fail | Unknown | Suceeded [(Name, Exp)]

The rule to do a case statement is then as follows.

Starting with the first match:
  - try the match and based on the result:
    fail - go on to the next match
    unknown - can't reduce
    suceeded - do beta reduction and return the expression

Good, huh? Then we'll probably want a helper function which takes the list of
matches and the expression to match and does this. I suppose...

Could we reduce a case expression to another case expression? Would that be
correct?

For example, say we have something like

 case e of
    NoArg -> foo
    JustArg SomeCon -> bar
    JustArg OtherCon -> sludge

And we have e is of the form: JustArg somevar

Can we then reduce the case to just:
 case e of 
    JustArg SomeCon -> bar
    JustArg OtherCon -> sludge

I feel like we should be able to do that. Then I should make that be my
reduction rule. That should be simple to code up.

Cool. So I need the following:
- function to do match: Exp -> Pat -> MatchResult
- case reduction rule.

Let me take a little break, then code it up. This is pretty exciting.

Sat Apr  7 09:40:11 EDT 2012

I coded it up. I must have a bug. Or something's going on.

Let's see, I want to reduce the following:

e = AppE (VarE "JustInteger") (IntegerE 5)
  Match (AppP (ConP "JustInteger") (VarP "i")) ->  ...
  Match (ConP NoInteger) ->  ...

My claim is this should be reduced, because.

Oh... We have VarE, we want ConE. Okay. I think I know the bug. It's the
quoter...

Wait. The issue is, where does VarE "JustInteger" come from?
It should go to (VarE _seriP_JustInteger), which is implemented as
ConE "JustInteger", right?

Sat Apr  7 09:48:01 EDT 2012

Cool! It seems to be working.

Except, now booleans are not primitive, but rather, ConT "True" and ConT
"False". That's fine with me I think. Let me fix that.

Sat Apr  7 10:01:59 EDT 2012

It works! Nifty.

Sat Apr  7 10:07:03 EDT 2012

So, what's the next step?

Well, I don't have data type declarations, so user defined data types are
incomplete in that sense. We would want to use those for generating back end
code. That should be fairly straight forward to add when I want to.

And certainly we'll want to allow polymorphic user defined data types. Like,
Maybe a = Just a | Nothing, for instance.

Once I have polymorphic user defined data types, I should be able to switch
primitives over to names, right? Then I can merge smt into the master branch,
separating the smt primitives off. That's really the high level goal.

We'll want some way of expressing monads too. Perhaps that can be done
primitively or some such.

Anyway. Let me summarize the steps to the next high level goal.

+ Support polymorphic user defined data types.
Test case: Maybe Integer instead of MaybeInteger.

+ Replace elaborate implementation with a list of reduction rules, so that
  different reduction rules can be specified in different files.

+ Replace primitives with String names, so that different primitives can be
  specified in different files.

+ Merge smt into master branch in a library like way.
So, SMT code should be completely separate, but it should still work just
swell like.

- Add user defined data type Dec to seri ir for backend code generation.

At this point I should be able to express SMT queries. I should also be able
to express Tibby, all in the same branch.

Cool.

Sat Apr  7 11:29:23 EDT 2012

Next step is polymorphic user defined data types. I'm not sure what all this
would involve, so I want to just start the thoughts flowing here while I think
about it.

We want to allow constructors with type variables.

data Maybe a = ...

This means we have a list of types variables. That's fine.

What has to change? The type for the generated _seriP expression has to
include a SeriType context like we have for polymorphic expressions. That's
not really anything new.

Is it just that easy? Let me take a hack at it, and if it is that easy, I'll
have it done, otherwise I'll know what challenges I need to think of.

Sat Apr  7 11:43:04 EDT 2012

Hmm... Here's a problem. It seems I can't have an instance of SeriType for
Maybe, because of the kind. So I'll want to define SeriType1 and SeriType2,
... as needed? Shall I try that?

Okay, I defined SeriType1 and SeriType2. That solved that issue.

Now I have the issue that I need to apply the type variables in my generation
of _seriP_...

Sat Apr  7 12:07:22 EDT 2012

Okay, so that fixed that. The issue now is... for some reason seritype is not
being defined in the instance?

Well, one issue is I need to give the right method name...
Gah. Must be a template haskell quoting issue.

Sat Apr  7 12:12:05 EDT 2012

There! It works. Nifty.

Wow. That was easier than I feared.

So let me take a walk, have some lunch. Then the next step will be making
primitives into strings, and separating out elaboration rules. Cool.

Sat Apr  7 13:43:19 EDT 2012

I changed primitives to strings. Next step is to separate out elaboration
rules. After that, I can pull out the arithmetic primitives, to put my
library idea to test.

Sat Apr  7 13:44:56 EDT 2012

Okay, so what's the plan.

We want to specify a list of elaboration rules. Reduction rules call them.
Then, given a list of these rules, we can do elaboration.

elaborate :: [Rule] -> [Dec] -> Exp -> Exp

But of course, one reduction rule is as good as a list, right?

elaborate :: Rule -> [Dec] -> Exp -> Exp

What is a rule?

type Rule = [Dec] -> Exp -> Maybe Exp

You need to have the declarations, for some of the rules.

Now you want something like: combine :: [Rule] -> Rule

So, given a list of rules, we can reduce it to a rule. And the behavior is
simple: try each rule in turn, for the first one that works.

Okay?

I should define these core things in elaborate.
Elaborate can also specify the core reduction rules. That is, the
non-primitives.

Then, when that works, pull primitives out into Arithmetic, and ditch fix,
because we really don't need that.

It might be nice to have a primitives directory. Seri.Primitives.Arithmetic,
that sort of thing. Just to keep clear what belongs to the core, and what is
really just an extension? I'm not sure.

Cool. Let me dive in.

Sat Apr  7 14:27:22 EDT 2012

Trouble. How do I recurse?

That is, I want to say, in my limited reduction rule, that I try to reduce the
predicate of an if statement.

But in order to do the full reduction, I need all the rules.

Well, I could take the reduction rules as input to each rule. It's a little
annoying, but it will work. Is there any other good way of doing it?

No. That should work fine.

Sat Apr  7 14:40:21 EDT 2012

Except, I have this cycle in my rule type synonym... I need a data type to
allow the recursion I think.

Sat Apr  7 14:48:10 EDT 2012

Okay, fixed that. It works now. It's a little messy. But not to bad?

We'll see what happens when I try to pull out Arith and do SMT.

Sat Apr  7 15:02:41 EDT 2012

Things I wish I could clean up somehow:
 - get rid of fix primitive
 - unit a primitive? UnitT a type constructor instead of built in?
 - general support for infix functions?

Sat Apr  7 17:09:31 EDT 2012

Okay, so I'll get to all those eventually. What I want to do now is get rid of
the SMT branch.

Let me first check on what work I did in the SMT branch that I want to pull
over.

Sat Apr  7 17:13:44 EDT 2012

SMT has the following:
 Types - Answer, Query 
 Primitives: free, assert, query, return, bind
 Expressions: FreeE
 Docs: smt.txt

Here's the question. How can we have FreeE not be part of the core?
Could we represent a free variable somehow in the language?

How about with a data type?

data Free a = Free Integer

Okay, so I can have a Free a, but somehow I need to get its value. Perhaps a
primitive?

realize :: Free a -> a

And what the primitive realize does, when translating to yices, is just turn
it into a variable name or something. What do you think of that?

I think it's worth trying, rather than mucking with the core.

Okay? So I'll see if I can make this work.

Sat Apr  7 18:12:46 EDT 2012

My work on SMT suggests I can have functions in haskell called _seriP_+,
_seriP_-, etc...

Let me check the language spec to verify, because that will make me feel
better. Then, I should use this to solve my infix parsing problem.

Convert infix applications just like normal, by name. Then declare the
primitives just like normal, with declprim.

But. After dinner.

Sat Apr  7 18:38:33 EDT 2012

The haskell report says an identifier _seriP_+ is not legal. Maybe ghc is
nice and I can get away with it.

Anyway, it should be easy to try out. So let me try it out and see what
happens.

So, it would seem I can't write down the name of the function, because it
doesn't pass in the lexer. But I can using template haskell to refer to it. Is
that okay?

I fear it could be troublesome, but let's see what happens.

Worst case, I could give non-symbolic names for all the operators too.

I fear this is going to be problematic, and I'll probably have to change it
back, because it's not good to not be able to refer to functions that have
been defined. Oh well. Let me deal with it then. At least it looks pretty.

Sat Apr  7 18:51:05 EDT 2012

Now what? The only thing left on the list from before is adding user defined
data type declarations to the seri ir for backend code generation.

Maybe I should try expressing Tibby? Or I could try starting the SMT path?

Okay, so if I really want to do something cool, I make tibby work, and I
implement software (via fiddler) generation and hardware (via bluespec)
generation.

Eh. All think about it.

Sun Apr  8 15:04:14 EDT 2012

I should allow all the canonical haskell stuff. Don't get used to writing in a
funny style.

Things like:

+ Allow function definitions
foo bar = sludge, as opposed to foo = \bar -> sludge.

+ Allow case matching of integers
case x of
    0 -> blah
    3 -> flub
    _ -> sludge

as opposed to
    if x == 0 then blah else if x == 3 then flub else sludge

+ Allow multiple function clauses
foo 0 = blah
foo 3 = flub
foo _ = sludge

as opposed to

foo x = case x of
            0 -> blah
            3 -> flub
            _ -> sludge

- allow patterns in lambdas
\(Foo bar) -> blah bar

as opposed to
\x -> case x of
          Foo bar -> blah 
          _ -> ???

- allow patterns in do bindings
Foo bar <- x

as opposed to

f <- x
case f of
    Foo bar -> ...

Anyway, I should always be able to write the haskell code I want to write. It
should all translate pretty nicely.

Sun Apr  8 16:32:25 EDT 2012

First, let me allow function definitions.
foo bar = sludge, as opposed to foo = \bar -> sludge.

Sun Apr  8 16:35:39 EDT 2012

The TH code generated is: FunD name clauses. I ought to be able to turn it
into a case statement easy.

And hey, that will simultaneously give me: function definitions, multiple
clauses, and pattern matching of arguments.

Sun Apr  8 17:08:37 EDT 2012

Cool. It works. The only issue is, it depends on tuples for multiple
arguments. So for multiple arguments to work, I'll need support for general
tuples.

Next on the list: integer patterns.

It should be straight forward.

Yup. Works now.

Next step: patterns in lambdas?
I mean, there are a bunch of things I could do. It's not really clear what
should get priority.

- patterns in lambdas
- patterns in do binding
- lists: type, expression, literal, pattern, comprehension
- tuples

Mon Apr  9 17:14:26 EDT 2012

I want to focus on lists and tuples, because I know I need those for tibby.

How to make it work?

Well, the real question is if I want these to be special cases or not. They
are special cases in TH.Exp. I think, though, there's no need for them to be
special cases, so let me not have them be special cases.

So, (a, b) is equivalent to Tuple2 a b.

The user of the language needs not care about the type name Tuple2, because
all that will be translated at the front end. The back end generation does
care, but it's like an any other type, so it shouldn't need any special
handling. I think that will make it much easier in the long run to get it to
work on different platforms.

And the same for list. There's nothing special about list. I just need a
constructor, and I can call it _seriP_:. And an empty list... call it
_seriP_[], if I may.

The only issue is, I can't use decltype to declare the constructor types and
matches and stuff. I'll have to do that manually.

Or... just have a special case in decltype to do it for me? It's worth a try I
suppose.

For that matter, we could name Tuple2 constructor ()? No, because that
conflicts.

Fine. I'll just do the constructor stuff manually, as annoying as that is.

First step: tuple 2.

Mon Apr  9 17:38:41 EDT 2012

It looks good. I define the Tuple2 constructor. I define the instance of
SeriType2 for (,). I define in seri fst and snd functions.

But elaboration isn't finishing. I'm getting:

AppE (VarE "snd") (AppE (AppE (ConE "Tuple2") (IntegerE 40)) (IntegerE 30))

Or...

snd (Tuple2 40 30)

Why don't we finish elaborating that?

I expect the first argument to be looked up in the context.
Is it not in decls? Let me list the declarations.

Oh. I forgot to include _seriD_snd. That's rather annoying. Oh well.

It works now. Cool. Simple. Nice. Clean. I like it.

Mon Apr  9 17:46:31 EDT 2012

So! What do you think? Will lists be as easy? I guess it's worth a try.

Mon Apr  9 17:55:56 EDT 2012

I need the following:
_seriP for: ':', head, tail.

Mon Apr  9 18:05:32 EDT 2012

List works! I'm not sure if the type name should be [] or List. I'll just go
with List for now, in an analogous kind of way to Tuple.

Mon Apr  9 18:06:57 EDT 2012

What now?

I feel like it would be good to separate out the library code from the core
code. That's something I could do.

Anyway, now that I have lists, I feel like I ought to be able to compile
Tibby.

The test won't pass, because I haven't defined declifc though. Maybe I can
steal that from when I defined it for my previous tibby attempt.

Reading through, I think I need to support the following before I can make it
work:

- declifc
- (a, b) <- blah 
- '.',  '$' functions
+ Tuple3
- [1..5]
- ttest

But otherwise, pretty close!

I do think I should have a Seri/Lib/ directory.

How would the thing be broken up?

src/Seri/Declarations.hs
src/Seri/Elaborate.hs
src/Seri/IR.hs
src/Seri/Ppr.hs
src/Seri/Quoter.hs
src/Seri/THUtils.hs
src/Seri/Typed.hs
src/Seri/Tests.hs
src/Seri/Lib/Arithmetic.hs
    -> src/Seri/Lib/Integer.hs
src/Seri/Lib/Primitives.hs
    -> src/Seri/Lib/Unit.hs
       src/Seri/Lib/Bool.hs
src/Seri/Lib/Prelude.hs
src/Seri/Lib/List.hs
src/Seri/Lib/Tuple.hs
src/Seri/Lib/SMT/SMT.hs
src/Seri/Lib/SMT/Tests.hs
src/Seri/Lib/Tibby/Tibby.hs
src/Seri/Lib/Tibby/Tests.hs

So, we keep core files separate from all the libraries.
You can import libraries just like you would in haskell.
We give a dir to SMT, and a dir to Tibby, because I expect each of those will
have its own specific collection of stuffs.

There. Nice, simple, easy to understand, modular.

I think the Seri core should be exported by Seri.hs at the top level. But that
shouldn't include any of the library primitives.

The libraries should import Seri. Then they will be collected and exported by
Seri.Lib.Prelude as appropriate.

Yes. I think this is good. This is what I should change next, the next time I
have time to change things.

Tue Apr 10 16:03:13 EDT 2012

I had some more ideas, just to note down.

- I can use (), (,), [], etc... instead of Unit, Tuple2 and List. I think it
  will be better to be consistent with haskll. Before I was thinking tuple2
  was represented with () and not (,), which was my motivation for using
  names, but I was mistaken.

- If I need to, and using these illegal names like _seriP_+ becomes an issue,
  it should be pretty simple to add a case to name_X to recognize operators
  and use a different prefix, maybe %%%%+ for those.

So, first thing I'm going to do: change the names of those constructors and
types and such.

Tue Apr 10 16:46:06 EDT 2012

I changed the name for list and tuple. I'd like to change unit now.

One concern that comes up is, what if I need to refer to the context
_seriD_()? I can't do it, because that's not lexically valid.

Maybe what I should do is, instead of having a seri expression quote generate
a plain expression, have it generate both the expression and the context
needed for the expression. Wouldn't that be better?

Something to think about.

Tue Apr 10 17:06:54 EDT 2012

Okay! So I reorganize the code as desired. I ended up not putting Tibby and
SMT under Lib, but rather in their own directories. I'm not sure why.

What next?

How about some grunt work, working towards a working tibby. Easiest to tackle:
three argument functions (3 element tuples).

Tue Apr 10 17:11:43 EDT 2012

Well, apparently I can't even do two argument functions yet, so let's figure
those out.

Specifically the issue is it gets translated into a multi argument lambda.
So, something of the form: \a b -> ...

What I want to do is turn this into:
    \a -> \b -> blah.
Should be simple.

Tue Apr 10 17:18:26 EDT 2012

Okay, I did that, and tuple3.

Next... '.' and '$'? Or patterns in lambdas?

I think both will be pretty easy. I hope.

Let me do '.' and '$' first.

how to test... uh... Well, '$' is easy to test, right?
Erg. I'd rather have these tested when I try to use them, and get the test
from that naturally.

So, let's do patterns first? Or am I far enough along, I should just try
running the Tibby test and see what issues that brings up?

Tue Apr 10 17:35:18 EDT 2012

Issue: If we try to use () in a type signature, we get the error:
  Data constructor `()' used as a type.

Why is that? This would be an issue with the type passed to declval, right?
Somehow we are doing... ConE instead of ConT? That makes no sense.

Maybe some special case having to do with the unit type?

I don't know. I'll come back and look at this later I guess, because I'm not
feeling in the mood just now.

What I should do is simplify the example to something boring:
    unit :: ()
    unit = ()

Then, print out the expression I get with that parsed, and see what type it
uses for unit. I would think it uses ConT "()", right? Maybe what I can do is
detect that, and replace all occurrence of ConT "()" with ConT ''()?

I dunno. Something like that.

Wed Apr 11 17:26:17 EDT 2012

Input type to declval is: ConT GHC.Unit.()
In output we have: ConT GHC.Unit.()

WORKS: Input Type: AppT (AppT (ConT Seri.Typed.Typed) (ConT Seri.IR.Exp)) (ConT GHC.Unit.())
FAILS: Input Type: AppT (AppT (ConT Seri.Typed.Typed) (ConT Seri.IR.Exp)) (ConT GHC.Unit.())
WORKS: Output: [SigD _seriP_unit (AppT (AppT (ConT Seri.Typed.Typed) (ConT Seri.IR.Exp)) (ConT GHC.Unit.())),FunD _seriP_unit [Clause [] (NormalB (AppE (VarE Seri.Typed.conE) (LitE (StringL "()")))) []],                              SigD _seriC_unit (AppT (AppT (ConT Seri.Typed.Typed) (ConT Seri.IR.Exp)) (ConT GHC.Unit.())),FunD _seriC_unit [Clause [] (NormalB (VarE _seriP_unit)) []],SigD _seriD_unit (AppT ListT (ConT Seri.IR.Dec)),FunD _seriD_unit [Clause [] (NormalB (AppE (VarE Seri.IR.nubdecl) (AppE (VarE GHC.List.concat) (ListE [ListE [AppE (AppE (VarE Seri.Typed.valD) (LitE (StringL "unit"))) (VarE _seriC_unit)]])))) []]]
FAILS: Output: [SigD _seriP_unit (AppT (AppT (ConT Seri.Typed.Typed) (ConT Seri.IR.Exp)) (ConT GHC.Unit.())),FunD _seriP_unit [Clause [] (NormalB (AppE (AppE (VarE Seri.Typed.conE_typed) (VarE _seriP_())) (LitE (StringL "()")))) []],SigD _seriC_unit (AppT (AppT (ConT Seri.Typed.Typed) (ConT Seri.IR.Exp)) (ConT GHC.Unit.())),FunD _seriC_unit [Clause [] (NormalB (VarE _seriP_unit)) []],SigD _seriD_unit (AppT ListT (ConT Seri.IR.Dec)),FunD _seriD_unit [Clause [] (NormalB (AppE (VarE Seri.IR.nubdecl) (AppE (VarE GHC.List.concat) (ListE [ListE [AppE (AppE (VarE Seri.Typed.valD) (LitE (StringL "unit"))) (VarE _seriC_unit)]])))) []]]

Aha! There is a difference.

The clause for the working one is:
  conE "()"

The clause for the failing one is:
  conE_typed _seriP_() "()"

But the error says something different.

Hmm... what's the difference? Could it be a bug in ghc?
That is, one is going into a template haskell thing, the other a quasiquoter.

Well, I should be able to test that, right? Try splicing in a () with
quasiquotes, then again with template haskell. In a very simple test case. See
if it's a problem there. If so, I can report it somewhere.

Wed Apr 11 17:52:03 EDT 2012

I've verified it's not specific to anything I'm doing. It works in template
haskell, it doesn't in quotes. So this is a quoter bug.

I have a simple test case. I should try it on the latest version of the
compiler, verify the same problem occurs. If not, then I should update to the
latest version of the compiler. If so, I should report the bug.

Sounds like a plan. So, for now... is there a workaround? Perhaps using type
synonyms? Like if I make a synonym: Unit for (), then refer to Unit, it should
be obvious, right? Let me try that.

Wed Apr 11 17:59:11 EDT 2012

Yes. That's a workaround. In every type I see, replace () with Unit, for a
type synonym Unit. Terribly annoying, but it will work, and I want to be able
to use Units. I'll mark it as a bug in haskell, and still check on ghc 7.4 and
submit a bug report. Otherwise, this should suffice.

Wed Apr 11 18:01:56 EDT 2012

Good news! I can replace GHC.Unit.() with "()" and that should fix it. That
will be much easier.

I'll make it a TH util.

Wed Apr 11 18:09:56 EDT 2012

Cool. That wasn't too bad to fix.

But now we run into other issues.

- You can have unused pattern variables. It's a little annoying, because you
  get a funny error about ambiguous types. It might be nice to fix that.

- My unary thing isn't elaborating as expected.

We have:

CaseE (AppE (AppE (ConE ":") (ConE  "()")) (AppE  (AppE  (ConE  ":") (ConE  "()")) (AppE  (AppE  (ConE  ":") (ConE  "()")) (ConE  "[]"))))
[
   Match (ConP "[]") (IntegerE 0),
   Match (AppP (AppP (ConP ":") WildP) (VarP "xs")) (AppE  (AppE  (PrimE  "+") (IntegerE 1)) (AppE  (VarE  "unary2int") (VarE  "xs")))
]

Oh... I think I know. We don't ever fail in the first case for fear we could
maybe elaborate the argument to the case more. Hum...

The question is... is the expression fully reduced.
That is, I should know that ConP fails to match AppE AppE ConE, which is fully
reduced. That is... I want to say AppE AppE ConE is fully reduced.

Well. Perhaps that's why haskell uses ConP Name [Pat] instead of this AppP
thing.

I dunno. I'm not sure what to do about this. Let me just take some time to
think about it.

Thu Apr 12 17:06:27 EDT 2012

Okay, so here's the deal. I have a function called iswhnf, which tells us if
an expression is in weak head normal form.

An expression is in weak head normal form if...
- it's an integer
- it's a lambda
- it's a ConE
- it's an application of a ConE with something, so AppE (AppE ... (ConE ...

There's a question about primitives...

Let me worry about that when it comes up. For now treat primitives as not weak
head normal form, because maybe some rule can reduce them to something else.

This should make the implementation of pattern matching easier too.

Okay? Shall I try it out? Sure. Let's see what happens.

Thu Apr 12 17:16:32 EDT 2012

Yup. It works now. And it simplifies the match code. Good.

Thu Apr 12 17:20:31 EDT 2012

Complaint from tibby: I want to decltype where we use record constructors.

What does this mean? Well, it means 2 things. It means I want to declare the
seritype, instance of SeriType, constructors. That's like normal.

The second thing I would like is, define the accessors functions.

Hmm... What about the record syntax for updates and patterns and such? Do I
want support for those?

I should, really. How about, start with one thing at a time. First thing, I
should be able to just extract the name and types of the constructor, and
ignore the field names. Then that will cause problems in tibby, so then I'll
add field accessors. At some point I'll try to use the field update thing, and
that will cause problems, so I can deal with that then. Maybe I can list that
in my todo file.

Sound like a plan? Yes. Good.

Thu Apr 12 17:29:31 EDT 2012

That was easy, but I ran into the accessor issue. So let me handle that.

What is it we want? For each accessor I want to know... its name and it's
type. Then I want to declare a value function for it.

Name: fieldname
Type: (SeriType a, ...) => TypedExp (Foo a ... -> fieldtype)
Expr: \(Foo _ ... _ x _ ...) -> x
Free: []

So I'll also need its position in the structure, and the total number of
fields.

You know? It kind of sounds like to me that I just want to have a special case
for RecC. I can share code between RecC and NormalC, but don't try to be so
general.

Okay?

That sounds relatively easy. Let me get to work.

Thu Apr 12 18:12:34 EDT 2012

Ug. This is a bit of a slog. Let me keep slogging.

The problem is, it's annoying to have to write the expressions for accessors,
which is a big pattern match. I'd love to be able to reuse the code in Quoter,
but I'm not sure how to organize things so that makes sense to do.

Thu Apr 12 18:16:48 EDT 2012

Okay, so the annoying part is generating the Th.Exp representing the SIR.Exp
of the form: \(Foo _ _ _ x _ _ ) -> x.

But! I know it's well typed, right? So I don't need to build up a nicely typed
sort of thing. So how would this look if I wrote the haskell code directly?

Well, it would be post desugar first of all, so
\d -> case d of
    (Foo _ _ _ x _ _ ) -> x.

And this is a ...

Hmm... maybe it makes sense to construct it typed after all, so we can infer
the proper types.

You know what? I'm not in the mood for this. Let me disallow record types for
now.

Ug ug! So, the reason I need to support record types is... because otherwise
we have to declare the field accessor both in haskell and in seri. I really
ought to just suck it up and implement the record type stuff.

Okay. So it's something like:

\d -> case d of
    (Foo _ _ _ x _ _ ) -> x.

Which will be...

lamE "d" (\d -> caseE d [lamM "x" (\xp xe -> match (appPs [
        conP "Foo", wildP, wildP, wildP, xp, wildP, wildP])
          xe])

Hey! You know what? I could maybe write this using a helper haskell function.

That would make it much easier. Then I just need an application of that
function. Oh... that sounds like a good idea.

How would that look?

-- selector dt i fields
-- Create a selector function for ith field of data type dt which has 'fields'
-- number of fields
selector :: Name -> Integer -> Integer -> Typed Exp (a -> b)
selector dt i 
 = lamE "d" (\d -> caseE d [lamM "x" (\xp xe -> match (pat xp) xe)])
    where pat :: Typed Pat a
          pat = wilds (fields - i - 1) (appP xp (wilds i (conP dt)))
        
          wilds :: Integer -> Typed Pat a -> Typed Pat b
          wilds n (Typed p) = Typed $ foldl AppP p (replicate n WildP)

There! I think that's it. Then I can implement that much in haskell (in
Typed.hs). Now implementing a selector function for the declaration is as easy
as: apply 'S.selector [string nm, integer i, integer fields].

Yes. That's totally what I'm going to do.

Let me try it real quick like, and see how far I can  get. Otherwise I'll just
come back to this later.

Well... it types, but I don't seem to have declared the thing I wanted to?

Oh! No. It actually worked! Wow. That's a type trip.

Cool. And now we get to other issues. But this is good for now.

Fri Apr 13 11:48:17 EDT 2012

Okay, so we've reached upon what I suspect will be a major next issue. But
maybe it won't be?

I want to have a typeclass, call it Foo. I want to supply a primitive function
foo which has Foo a in the context. Perhaps: foo :: Foo a => a -> Integer, or
something like that.

Currently this doesn't work, because the _seriC_ function is implemented as
  _seriC_foo = _seriP_foo, but _seriP_foo requires VarT_a be an instance of
Foo.

I ran into the same problem when using monads. My solution before was to just
make a VarT_m which was an instance of monad, but somehow that doesn't feel
like a very good solution.

And, moving forward, I suspect we'll want to define our own instances in seri
for classes. Like, be able to define a complex number type, or fixed point,
which is an instance of Num. Or, our own kinds of monads.

I'm seeing (admittedly fuzzily) three ideas.

1. Work around the issue: don't have _seriC_foo use _seriP_foo, but rather do
an inline like thing so we never have the context requirement for _seriC_foo,
so we won't get that compiler error.

2. Make VarT_x an instance of every class you could possibly want. That way we
won't get that compiler error.

3. Come up with a real, more general solution to the typeclass issue.

Let me think about this some more and get back to you.

Fri Apr 13 14:56:11 EDT 2012

I've thought a little bit about it. I think one thing is clear: I want haskell
to do the work of figuring out which functions to call.

In other words, typeclasses are really a way of having two different functions
with the same name, chosen based on type.

What we want in the built up seri expression is, whenever a function is
called, use the specific instance of it that should be used. So we want
a way to distinguish between different instances of a function.

So, let's assume we have some magical id which uniquely identifies a function
instance. Now when we write something like: "return x", it will compile to...

return_Query x, if it's in the Query monad, and return_Action x, if it's in
the action monad, and so on.

Thoughts on choice of id:
- It seems like it would be nice, for debugging, and maybe for backend code
  generation (though I'm not sure about this) for it to be clear when we use
  a function defined in a typeclass what the name of the typeclass method is.
  So, for example, for the above two instances, it should be clear they both
  refer to the "return" method of the Monad class. 

  This could be easily done by make a function name a pair of: (name, instance id)

- Type is not good to use for instance id.
  What we really want to do is associate a unique id for every different
  implementation of a given function. In the simple case, you could just use
  the type used in the instance declaration for the id, but some instance
  declarations will have contexts and be polymorphic and such.

  I think what you really want to use is the context and complete type used in
  the class instance declaration. So, maybe use the complete type.

Once we have this id, we can just make function identifiers the pair as I said
before, we have haskell tell us which is the right one, and that gives us what
we want, I think. At least, it gives us the first step. I don't know if other
steps will come up later (like, imagine what information we have to have to
generate backend haskell code for the instances).

But let me just focus on this first step.

The real question now is, how do we get haskell to tell us which instance to
use?

I need an example. Let me use '+', because I think that should be clear to
think about.

I should be careful though, because of the question of primitives. You can
imagine some type classes which have primitive instances, and some which
don't. I feel like primitive instances is a special case that I may want to
handle separately. So, for starters, can I assume we don't have to worry about
primitives?

I have an expression: foo + bar.
When quoted, this will turn into
    appE (appE _seriP_+ (varE "foo")) (varE "bar")

or something like that.

What is _seriP_+? Well, remember now, I'm saying + belongs to a typeclass, so
_seriP_+ should belong to a haskell type class.

Interesting. (does this look familiar to you from bcl?)

This typeclass is not the same as the haskell typeclass Num, because I'm
calling the function _seriP_+ and not (+), right?

Well, what type do I want for _seriP_+?

It should be:

class SeriType a => SeriOrd a where
    _seriP_+ :: Typed Exp (a -> a -> a)

And I probably want the declarations and such too.

_seriC_+ :: Typed Exp (VarT_a -> VarT_a -> VarT_a)

Hmm... This raises an interesting question.

Why is the type of _seriC_ a Typed expression?
Why not have something like:

_seriP_foo :: SeriType a => Typed Exp (a -> Integer)
_seriP_foo = ...

_seriC_foo :: Exp
_seriC_foo = typed $ _seriP_foo

Where do I use _seriC_foo?

I use it in the call to valD, so I can get the type information, where the
type information uses the variable type.

But don't I have that from the polymorphic type?

I guess the issue is, I want to convert the type from haskell to seri, which
means I want to call seritype, but to do that I need a concrete type to apply
it to. One way to get that concrete type would be to define _seriC_ with a
concrete type. Another way would be to use a type signature, in which case we
don't need _seriC_, and it doesn't matter anyway.

Fine. Whatever. Maybe I could get rid of _seriC_, but I still need a way to
represent a polymorphic type as a concrete haskell type.

What does this mean in the context of type classes? It means I want an
instance of the type class for the variable types. Then I can say:

_seriC_+ :: Typed Exp (VarT_a -> VarT_a -> VarT_a)
_seriC_+ = _seriP_+

And it will give me what I want. ??? Or will it? What should the instance
implementation be? I feel like each instance of the class will need it's own
_seriC_+?

Or maybe what we do is have an instD instead of valD?

Let me move on and worry about this later. Maybe it will become more clear.

So, we say we have our own typeclass:

class SeriType a => SeriOrd a where
    _seriP_+ :: Typed Exp (a -> a -> a)

Hmm... now this is interesting. Because consider, once I have this, having
primitive instances isn't too bad, right?

instance SeriOrd Integer where
    _seriP_+ = _seriP_prim_integer_+

where _seriP_prim_integer_+ is defined just like normal. So I think primitive
instances aren't something to be too troubled about.

Let's go back now to the main question. We have some expression:
  appE (appE _seriP_+ (varE "foo")) (varE "bar")

But what we really want to do is augment the IR with this id information for
the functions. That is... for the variables.

Let's say, then, that our identifier is some string. What if I change my class
as follows:

class SeriType a => SeriOrd a where
    _seriP_+ :: (ID, Typed Exp (a -> a -> a))

Does that work? No, that's not exactly what I want. I'm going to see an
unbound variable, assume it's from the top level, convert it to this typed
thing, so it contains within the expression the information about instance.

Wait a second. I'm a little confused. I think I got my thing wrong.

We actually get:
  appE (appE (varE_typed _seriP_+ "+") (varE "foo")) (varE "bar")

Now what I want to do is change varE_typed.

varE_typed :: (SeriType a) => (ID, Typed Exp a) -> Name -> Typed Exp a
varE_typed (id, _) = varE id

varE :: (SeriType a) => ID -> Name -> Typed Exp a
varE id nm = withtype $ \t -> Typed $ VarE t nm id

And now we associate this special id with each type, just as we want.

Cool. This is looking good to me. There's just one big issue I see remaining.

I don't know at time of quoting whether a function belongs to a typeclass or
not. So what do I do?

Well, that's not too hard. Change the type of _seriP_...

_seriP_foo :: (SeriType a) => (ID, Typed Exp (a -> Integer))
_seriP_foo = (nullid, ...)

Simple.

This is, unfortunately, a little complex. But I think I see a path.

The main points are:

- type classes and type instances should be declared in seri, so we can do the
  proper transformations.
We can have a declclass and a declinst kind of thing to make it easier to
integrate existing haskell classes and instance declarations. Uh... existing
classes will work, existing declarations will not, because we need the code
for the implementations. You'll have to write those yourself, but that
shouldn't be too hard.

For primitives, I can provide a way to declare a primitive instance, perhaps
by giving an association map or some such. Or you can just declare the
primitives as functions, and refer to those functions. I see no problem there.
In fact, that sounds very good to me.

I think this is it. I think this is the right solution to take.

We can define our own type classes. We can define our own instances. We can
automatically deduce seri type classes from existing haskell ones. We can
easily describe primitive instances of type classes. It's just what you want.

Representing a typeclass and instance declaration in the IR itself will come
later as needed.

I feel like I should start a document collecting all the haskell things we
define and how they correspond to seri things.

I also want to make a distinction between: writing declarations in seri, and
having a way to infer seri declarations from existing haskell declarations.
They are two paths which can share code, and both are useful for their own
purposes. It might be good to support the user defined data type all within
seri path, which I can use to clean up some code.

And finally, while I'm at it, and because I've thought of something like this
a few times, it may make sense, rather than have _seriP_, _seriC_, _seriD_,
..., especially because _seriP_ will no longer directly be a typed expression,
it might make sense to bundle it all into one. For example:

_seri_foo :: (SeriType a) => (ID, [Dec], Typed Exp (a -> Integer), Typed Exp (VarT_a -> Integer))
_seri_foo = (nillid, [ValD ...], ..., ...)

And have generic accessors. That is, ways to get the context, the concrete
expression, the generic expression, and so on. We could also have a similar
construct for just plain expressions, which includes the context so I can get
at the context when I use an expression quote.

Cool. Good. Lot's to think about. But I think the path is fairly clear, and
not so terribly unpleasant.

Fri Apr 13 17:28:01 EDT 2012

Okay, here's the plan.

1. Support type declarations in quotes.
This should be easy. Just call decltype'.

2. Define a Declaration type which holds for each expression, information
about its haskell type, seri type, seri implementation, and context.

3. Add support for type classes.
As described above. So, add ID to Declaration. Implement declaration of seri
type classes and type instances. To test it, I can make up my own simple
classes. Maybe converting a type to an arbitrary integer.
 
Okay? Ready?

Let's me get started and see how it goes.

Fri Apr 13 17:51:58 EDT 2012

1 is done. It was pretty easier. The hardest part was dealing with this
FixUnit bug thing.

Next step, number 2. This one will take some preparation.

The question is, what information do I want from declared expressions and
local expressions?

Local: 
 - the seri expression :: Exp
 - the seri context needed to evaluate :: [Dec]
 - the haskell type of the expression
     For example, for use in SMT.runQuery to make sure you pass in the right
     type expression.

Global:
 - the seri expression :: Exp
 - the seri context needed to evaluate :: [Dec]
     This includes the concrete type of the value being defined.
 - the haskell type of the expression (for type checking)

And hey! Look. Both are the same.

I propose the following abstract data type:

Declaration a = ...

value :: Declaration a -> Exp
tvalue :: Declaration a -> Typed Exp a
context :: Declaration a -> [Dec]

Hmm... one wonders. Could I reused Typed here?
Like, for instance, isn't what I really want the following:

data Declaration = Declaration Exp [Dec]
 (and now I should think about a different name)

And then the quote will return, and _seri_blah will be of type:

Typed Declaration a.

Yes. That, I think, is a better way to go.

What am I doing then? That is, what name should I use instead of Declaration?

I'm tracking info... 
    the value
    the context
    in the future: the id for a function name

It's like, an annotated expression. Or, Info about an expression.

Info is a short name. What if I used that?

data Info = Info Exp [Dec]

What does info include? It includes the implementation, and the context, and
in the future the class instance id. Then [s|...|] in the expression context
gives you (typed) information about the expression.

You know what? I feel a little uneasy about that choice of name, but I like
it, so let me go with it.

So there we have it.

I don't know what all I'll need to change to make this work. How about, let me
dive in, solve problems as they arise, then see where I end up.

In summary:

- Expression quotes return a Typed Info, where Info is the expression and
context.
- Declaration quotes for a function generate haskell declarations of the form:
_seri_foo :: (SeriType a) => Typed Info a

Here I go.

Fri Apr 13 18:18:18 EDT 2012

Here's a question. How should I be specifying types?

Because currently I assume you pass a type like:
    (SeriType a) => Typed Exp (a -> Integer)

But the information I think you really want to specify is:
    a -> Integer,
or
    (Monad m) => m a -> Integer

for example.

And I'm going to want to map this internally to something like:
    (SeriType1 m, Monad m) => Typed Info (m a -> Integer)

Yup. That's what I should do.

Do you think that would be a good first step to take? Rather than clumping it
with other changes? I think so. Let me do that.

Fri Apr 13 18:44:39 EDT 2012

Good! I'm liking this change very much. Specifying types for primitives and
such becomes much simpler, and we can share common code that was being
duplicated between declarations and quoter.

One issue though. decltype doesn't seem to be working.

decltype ''Maybe is trying to give me something of the wrong type, and I can't
seem to track it down in the code.

It's for a constructor. So what type do I specify to declval for the
constructor? For example, Just. The type should be: forall a . a -> Maybe a.

I found the bug. An extra call to declize. Fixed that.

Fri Apr 13 18:52:48 EDT 2012

Another problem. We don't just want to blindly make the  variables instances
of SeriType, because they could be, for instance, the type 'm', which should
require in the context SeriType1, not SeriType.

Is there a way I can figure out which variables should get which? Does it need
to be a special case? Can I have some naming convention?

I think for now, just have a special case.

Fri Apr 13 19:01:59 EDT 2012

I put the special case in. This will probably come back to haunt me later, but
I don't know of a good solution yet.

But this is a good change. I like it. I'm glad I did it. It should make the
next transformation much easier, and the code is much nicer.

Fri Apr 13 19:04:28 EDT 2012

Now. On to the Info thing.

Fri Apr 13 19:28:39 EDT 2012

Implementing declval will be a bit of a slog, but I think it will be worth it.
And I already have most of everything in place.

One thing, though, is I'd like also to have another function, which is a
helper function. The function the quoter will use when it generates an
expression. That is, exactly like what I want declval to do, only without
including the declaration. Just returning the (Typed Info a) expression.

You know what? I think I should make that a separate step. First step, handle
declarations. Second step, have seri quoted expressions return these info
things. That will make my life much easier I feel.

So, back to the slog.

Fri Apr 13 20:10:27 EDT 2012

Okay, so it wasn't so bad. I've updated Declarations to where I think it will
work. What else has to change?

It's just the quoter, right? Instead of _seri_foo, it should do 
(typedas _seri_foo (Typed exp _seri_foo)). Or, in other words, I want a texp
function, then it's texp _seri_foo.

Okay. So I fixed that... what's left will be the test cases.

Fri Apr 13 20:50:46 EDT 2012

Started working out the bugs. I'll finish working out the bugs tomorrow. I
think the meat of it is all there.

Sat Apr 14 07:07:39 EDT 2012

Yet again I run into this fixunit problem. What I ought to do is switch to
using generics. Say everywhere, change ConT n where n looks like unit into
ConT "()".

But I think that should be a separate step. The next step. For now I'll just
add let declarations and expressions to my FixUnit.

Sat Apr 14 07:14:26 EDT 2012

Issue: I'm doing env (typed _seri_tail), for example, which apparently doesn't
have enough type info. I need a concrete type for _seri_incr to use.

That sucks. The concrete type I want is the concretized version, but I can't
get at that info just from the name.

Bugger. This is fairly serious. It shouldn't matter what type I use, but a
need some valid type, and I don't know anything about the type of the free
variable... Or do I?

What if I made that an input? Do I have that information?

No. That comes after type check...

Bugger.

That's a big bugger.

That means we have to have separate top level haskell declarations for the
polymorphic type and concrete type. Any attempt to put them together, and
whenever we want to get concrete information, we have to cast it to concrete
type, which just doesn't make sense.

In other words... I should dump all the changes I just made, because they
won't work.

Sat Apr 14 07:26:00 EDT 2012

Oh well. At least it's good to know the way I've done it is valid. And I'm not
sure this change I wanted to make is so much of an improvement. I mostly
wanted to reduce the top level namespace clutter, but that doesn't matter.

And a bunch of the changes I made I can keep.

In an attempt to keep my partial changes, I'm getting:

AppE  (AppE  (VarE  "+") (AppE  (AppE  (VarE  "+") (AppE  (AppE  (VarE  "*") (IntegerE 5)) (IntegerE 5))) (AppE  (AppE  (VarE  "*") (IntegerE 3)) (IntegerE 5)))) (IntegerE 2)

Which is:
+ (+ (* 5 5) (* 3 5)) 2

Why is this not elaborating?
I don't have '+' in the context. Why wasn't I running into this bug before?

I don't know. I think there's a bug in the quoter I'm relying on, and when I
tried to fix it, it lead to problems.

Anyway, here's what I want to do next.

1. Commit what few changes I have. Mostly additions to fixUnit.
2. Rewrite fixUnit to use generics, verify it works.
3. Have the seri [s|...|] expression quotes return an expression and a
context.
4. Fix that supposed issue in the Quoter.
5. Reconsider the next step needed moving forward.

