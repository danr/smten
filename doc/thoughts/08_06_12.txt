
Mon Aug  6 10:06:29 EDT 2012

Plan for today:

1. Update version of yices, see if that bug was fixed.
2. finish implementing the free cache thing.
3. Fix whatever needs to be fixed for heap elaborator:
- should work on all tests (include array test) 
- should work when used as elaborator in SMT.Yices
- should work when used as full elaborator in yices target
- See what sorts of savings we get on performance, sharing for BCL3 with 17
  queries.

If that works, probably want to start on bit vectors, to try and get Jacob's
ATS dump running in seri (though I'm not sure what I can do with it...)

Here I go.

Mon Aug  6 10:19:00 EDT 2012

(1): bug was fixed. Good. Cool. One less thing to worry about. Now back to my
elaborator implementation.

Mon Aug  6 10:22:19 EDT 2012

Okay, I have the code for constructing the cache implemented... Now I just
need to add it to: 
 - argument to reduce
 - from there, argument to whoever calls reduce (LamEH)
 - from there, whoever constructs LamEH (heapify)
 - from there, whoever calls heapify: HeapifyEH.

And I think we're all set then.

Mon Aug  6 10:32:54 EDT 2012

Err... I'm worried.
Can we ever substute in something with a free variable?
I think we can, we we do full elaboration, in which case, we need to do alpha
renaming, don't we?

Ug. Let me worry about that when it comes up.

Mon Aug  6 11:45:24 EDT 2012

Nirav says the optimization isn't worth it. I should not attempt to share
between different beta reductions of the same function. Anyway, we simplify
the function before doing the beta reduction? Well... we don't go inside the
lambda to simplify it. Perhaps we should? I don't know. Erg.

Anyway, makes sense to make things work before worrying about this
optimization. Skip the reduction check, no need for the free cache. I'll see
how bad performance is after that.

But first, Nirav wants a bit vector library, with some examples working
through yices. Make bit vectors primitive. I should be able to do that fairly
reasonably. And also, shouldn't be hard to simplify and roll back the beta
reduction optimization.

Perhaps just use the simple optimization: if after reduction the result is
unchanged, don't return a new reference, just return the old one. Assume
HExpifies need reduction done to them. Or... I suppose, as a first step, I
could just call reducableE on those to check, and if that's too slow, then
change the implementation of reducableE to be true.

Cool. Sounds like a plan.

Mon Aug  6 12:16:43 EDT 2012

Note: we still don't pass the array update test or the array smt tests. They
get stuck in infinite loops. I'll look at those again later, after
implementing Bit vector support.

Anyway, good news is, without checking for reducable, it's much faster. Like,
an order of magnitude. So I'll leave it there for now, work on bit vectors (in
the original elaborator?) and then come back to this.

Mon Aug  6 12:21:04 EDT 2012

Oh, I should note, the problem with the Array smt test is not from the heap
elaborator, because we don't use the heap elaborator for it.

I could try switching to the heap elaborator entirely, but I have a feel it
won't work right for full elaboration because of the need for alpha renaming,
and I don't want to deal with that right now, so for now, leave it buggy? It
works on BCL3, which is what those people care about.

Mon Aug  6 12:22:34 EDT 2012

Fine, so... bit vector library. I can implement some tests and such. Get the
ball rolling.

First thing to try out?
- *, +, -, concat...

I don't know.

We can represent a bit vector in the elaborator as:
(fromInteger i), of the right type.

Let me come up with a test case. How about this, make a 3 bit vector,
increment it so it loops around, count how many increments that takes.

Also, I can have an SMT test for it: create a couple bit vectors, assert
something about their and and or, then see what we get for them.

Cool. Sounds like a plan to me. Let me get started.

Mon Aug  6 12:54:22 EDT 2012

Okay, so now I have to figure out how to implement bits in haskell. This will
be useful both for the haskell target library and for the elaborators.

First thing I need:
- a Bit data type, whose type includes the width.
- equality, add, sub, mul, fromInteger.

In the elaborator, we don't need a data type for it, we can just use
fromInteger. So perhaps what I want are just the raw bitvector operations,
done to integers.

And maybe they can take the width as input?

equality is just integer equality (assuming I always keep the integer properly
truncated).

add would be something like:

Bit.add :: Integer -> Integer -> Integer -> Integer

Where the first argument is the width of the addition.

The way it works? Um... how do we deal with negative numbers?

Shouldn't it just be: have a function that, given an integer, truncates it to
a given bit width. Deal with negative integers and such appropriately.

Then all the operations are: do the integer operation and truncate the result.

Sounds good to me.

Mon Aug  6 13:05:28 EDT 2012

I double checked. Doesn't look like there is already a suitable library in
haskell for bit vectors that supports arithmetic.

I should note, though, Integer is an instance of Bits...

I could define something which is an instance of bits. That may actually be
easier than always having to pass stuff around.

Okay, how about a non-statically typed bit vector library:

Bit = Bit { width :: Integer, value :: Integer }

I make it an instance of Bits, and we are all set. I can use that as the
target library and so on. Sounds good to me.

Mon Aug  6 13:27:26 EDT 2012

Okay, so I have my sample target library. Now I should be able to do this.

Mon Aug  6 13:49:48 EDT 2012

I added *, +, -, == to the elaborator. It's messy, but I think it works.

Next step: add it to the haskell target.



