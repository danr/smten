
Tue Jul 31 09:04:34 EDT 2012

Plan for today: try to improve the >>= stats on the profile.

I think we're being overly lazy. So try to find that and get rid of it.

Plan:
1. Try making the Compilation strict in its fields, under the hypothesis that
we have a bunch of unevaluated thunks retaining lots of copies of this, which
is eating up memory, causing the allocator to have to do lots more work, which
is taking up a lot of time (and memory).

2. Read through the rest of the yices target, looking for weird stuff. In
particular, things like depat.

Wish me luck.

Tue Jul 31 09:13:09 EDT 2012

(1) didn't help any.

Tue Jul 31 09:18:40 EDT 2012

Looks like we are leaking Compilation objects, when I expect we shouldn't be.
We should only ever need just one. So let me focus on this.

First step, figure out who is retaining the Compilation objects.

The retainer profile says >>=, which really isn't so helpful. Let me
investigate by hand.

Things which have compilation objects:
 - SMTQuerier - we should check if this is being leaked.
 - call to runCompilation not evaluated? might hold onto ys.
    in both yicest and yicese.

In yices target:
 - modify may hold onto it if it's lazy.
    A strict modify would be useful.
 - gets call to get the commands (or anything) may hold onto it if gets is lazy.
    Perhaps a strict gets would be useful?

SMTQuerier is not being leaked. Good. It shows what we want to see the
Compilation look like: just one throughout.

Tue Jul 31 09:36:20 EDT 2012

Okay, so let me try everywhere to avoid leaking Compilation objects.

Tue Jul 31 09:49:35 EDT 2012

So all I could find to do was use getsS and modifyS everywhere.

Tue Jul 31 09:53:03 EDT 2012

Nope. Still leaking...

Tue Jul 31 10:00:19 EDT 2012

Got it! Not that it helped a whole lot, but at least it's clear >>= isn't a
major issue anymore.

But what was the change I made? I feel like I made a couple.

1. Use Control.Monad.State.Strict instead of Control.Monad.State.
2. Clear the cmds list before running instead of after running.

let me go back to Control.Monad.State. That is, let me start undoing changes I
made until I figure out the important difference.

Tue Jul 31 10:10:50 EDT 2012

You know what it looks like? It looks like we really didn't fix anything?
Hmm... I don't understand. The profile says we didn't improve anything... But
I swear we are leaking less, right?

But depending on how I implement addcmds, it either gets the cost of
performance and memory allocation, or >>= gets the cost.

Tue Jul 31 10:17:47 EDT 2012

Okay, so I definitely fixed the space leak, and using
Control.Monad.State.Strict has something to do with it, though I don't
entirely understand what's going on.

The profiling info, however, doesn't seem to reflect that. Perhaps it wasn't
costing us so much anyway. I don't know, but I think I should check this in
anyway.

Tue Jul 31 10:21:28 EDT 2012

Now what?

Our profile now has:
50% check
9% addcmds (35% alloc)
8% treplace (17% alloc)
8% ==

All at the top.

Tue Jul 31 10:23:12 EDT 2012

ytype is taking some amount of time. We could probably switch to using the
specific type interfaces for that instead of pretty printing. It's called a
lot, so it would be good to make it fast.

lookupDataConType could be made faster leveraging the hash table.

addcmds is getting lots of time an memory assigned to it. Why?

Monomorphic takes some time. I still feel like we should be able to reduce a
lot of work here by allowing incremental monomorphization. Perhaps it will
work better now that I've fixed this space leak, and I can make sure I don't
have the same space leak problem.

We could see if we are leaking MS from monomorphic. I don't see it as a huge
problem at this point.

Try to not use ytermbystr? It seems like pretty printing has more overhead
than I would expect.

In elaborate, beta reduction is the primary culprit. I feel like we could do
simultaneous reductions for case matches to speed things up.

Type inference takes a ton of time. Why is that?
It's mostly in the solver, in type replacement. Perhaps I can figure out a
better way to do that? Reduce the number of times it's called? Be lazy about
the replacement? Can I have smaller systems somehow?

For example, what if I did a pre-pass to simplify as many constraints as
possible, like the trivial constraints? Are there many of those?

So, we have a number of small things to look into. I think just do each at a
time, squeeze out more performance, in a cleanish kind of way if I can.

Tue Jul 31 10:43:24 EDT 2012

First goal: tackle addcmds.

What could the cost be coming from?
Well, 
 - ys_cmds forces ys?
 - lots and lots of repeated concatenation? (Which we don't need to do at all.

Oh... Look. We are appending commands.
That explains it. We have this whole big long list of commands, and we append
a couple to the back.

The answer? Use a reverse list. Prepend the commands. Then, always reverse
them when they are returned. Easy.

So this should be simple. Let me try it.

Tue Jul 31 10:53:52 EDT 2012

Yup! That was it. That helped a good deal.

