
Wed Jun 20 10:40:46 EDT 2012

I have a hypothesis as to what the bug is.

When we have an application, we split it into two constraints and solve them
directly. But that means we don't substitute the result of the first
constraint into the second.

This may not be the bug I'm seeing, but it's certainly a bug, and it has an
easy fix, so let me fix it and see what happens.

Wed Jun 20 10:44:14 EDT 2012

That wasn't the problem I'm seeing.

Let me go through a step at a time, see what happens and if it makes sense to
me or not. Again, going through the solution process, not the constraint
process.

Wed Jun 20 10:48:30 EDT 2012

Erg... Apparently there's a problem with the build system. That's bad.
Probably something to do with out the copy from build to source is done.

And thus, the bug I thought was the problem turns out to really be the problem
it would seem.

Wed Jun 20 10:58:02 EDT 2012

Next problem: head types aren't inferred correctly at all. Let's see if I can
figure out what's going on.

Aha, so, recursive constraints it would seem.
Can I solve this?

|| constraints: ~6: ~6
|| ~2: ~3
|| ~4: ~6
|| [~7]: ~5
|| ~7: ~4
|| ~7 -> [~7] -> [~7]: ~3
|| ~1: ~2
|| [a] -> a: ~1 -> ~6


~1: [a]
~2: [a]
~3: [a]
~4: a
~5: [a]
~6: a
~7: a
~3: a -> [a] -> [a]

Well, it's solvable. I can solve it. But apparently it's not solvable via the
method I have.

Oh. Maybe it isn't solvable:

|| e': (\(a :: ~1) ->
||    case (.a :: ~2) of {
||      ((:) :: ~3) (x :: ~4) (_ :: ~5) ->
||        (x :: ~6);
||    })

|| ~6: ~6       -- from case consistency
|| ~2: ~3       -- wrong! Should be: ~2: ~3 ~4 ~5
|| ~4: ~6       -- from variable x
|| [~7]: ~5     -- from definition of :
|| ~7: ~4       -- from definition of :
|| ~7 -> [~7] -> [~7]: ~3   -- from definition of :
|| ~1: ~2       -- from variable a
|| [a] -> a: ~1 -> ~6       -- from top level definition.

We have a bad constraint.

Looks like an error in asserting the case expression has the same type as the
pattern. The type of the pattern is bad.

Oh, it's more subtle than that. Because we don't know the type of :, we think
it's type is ~3, and not that ~3 is a -> b -> c, and that we should return the
type c instead of the type ~3.

Well, maybe this is a good reason to change the meaning of the type for a
ConP? Is there some other way to work this out?

If we have the type for the constructed thing for ConP, it's easy to figure
out the type of the pattern: its just the type. And it's easy to figure out
the type of the constructor involved: arrows of the args to the result. So I
think that could do it fine.

It just disturbs me that we put the Type and Name together, but the type
doesn't refer to the type of the name.

Perhaps I should change ConP to be: ConP Type Name [Pat]. Then it's more clear
that Type is the type of the ConP and not the type of Name.

Sounds good to me. Let me make the change next.

Wed Jun 20 12:00:40 EDT 2012

Question: do I want a different syntax for ConP now?

Really we want the type to be on the pattern, but I fear an ambiguity. Let's
not worry about this for now.

Wed Jun 20 12:09:07 EDT 2012

Trouble with serif: conP. Maybe I can assume the type is fully known, just use
last $ unarrowsT. Okay?

Actually, no, I needn't do that. I can always just return the type of the
pattern.

Wed Jun 20 12:14:17 EDT 2012

That did it. Cool. No major problems making it work.

I should bring the haskell target back up to date when I can, by the way.

Wed Jun 20 12:21:46 EDT 2012

Next problem: lookupVarType fails for a variable with UnknownVI. We use it for
the variable (+).

Well... what about varizing before type inference? Does it rely on type
inference any?

Err, well, yes, it could. But I haven't done it yet. Hmm... Except, the var
type lookup doesn't need to know. So let me just add the case for that which
looks for the class if there is one.

Wed Jun 20 12:27:44 EDT 2012

No. What I should really do is figure out how I really want to deal with
instances correctly.

First observation: we only need the class type when we call lookupVarType.

So here's the proposal. Do varize first. Bound we can get. Declared we can
get. The instances we can get, we just don't know which instance, so instead,
make new variable types for the types in the class. Now we've gotten rid of
all the unknown, the variable types are in place.

Then ...

You know what I'm asking myself now? Why include VarInfo in the IR at all?

We know a bound type is bound based on the scope.
We know a declared type is declared based on looking up in the environment.
We know an instance is an instance based on lookup up in the environment.

Compilers will have to keep track of bound variables, or assume any variable
which is not declared or an instance is bound. That's fine withe me. We
provide a function: Env Name -> Failable VarInfo to look up the VarInfo based
on this. Or something like that.

Now we don't need to annotate var info (we do need to annotate primitives).

Okay, and there's also a clean way of transitioning the code over to this.

1. Perform all type inference ignoring VarInfo. I shouldn't need to read any
of the VarInfo.

2. Post type inference, do varize, making use of my lookupVarInfo function.

If I can make that work, then it seems likely we can get away without var
info.

Good. I like this idea. I think it makes things cleaner and easier. First
step: Get rid of any reference to VarInfo in the type inference.

Wed Jun 20 12:55:26 EDT 2012

Good. Now we get to lookupVarInfo which isn't declared.

Okay, so, how do I implement this?

First we want to find it in a class.
Then we want to, based on the type given, figure out the variable type
assignments. Then we want to do the substitution of those in the class
signature.

Wed Jun 20 13:11:32 EDT 2012

Err... build system bugs again?

We are running into a TODO error: get t for infermethod.

Okay, maybe that was just something not being triggered before that is now.
Anyway, it didn't fix the problem. It looks like another problem with the type
constraints:

|| e': (\(a :: ~1) ->
||    case (.a :: ~2) of {
||      ([] :: ~3) ->
||        0;
||      ((:) :: ~4) (x :: ~5) (xs :: ~6) ->
||        ((+) :: ~7) 1 ((length :: ~8) (xs :: ~9));
||    })
|| constraints:
|| Integer: ~7          ?? this is wrong! Where's it from?
|| Integer: Integer
...
Looks like a bug in lookupVarType?
Wed Jun 20 13:26:11 EDT 2012

lookupVarType is fine. How about retype?

Wed Jun 20 13:29:44 EDT 2012

Oh... I bet it's the same kind of problem I had before. Using outputT to
figure out the output type of an application.

Yup! That's the problem. Tricky...

Problem is... typeof doesn't work unless it's well typed.

Well, AppE is the only one that has this problem, and I can handle that right
by introducing some more variables and constraints.

Err. can I?

Problem is I'm calling typeof match, or something like that, which calls
typeof in the expression, which refers to the original expression, not the
added constraints I have.

Well, I can think of a couple of solutions.
1. Don't use typeof in type inference. Instead return the type of the
expression myself.

2. Add more type information to typeof.

But, I feel like, typeof should be able to assume a correct type. So let me do
the former.

