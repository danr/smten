
Wed Jun 27 08:36:24 EDT 2012

1. Declare Foo-Error constructor for every data defined type.
2. Box integer in a user defined data type.
3. Return Foo-Error as the default case value in case expressions.

Here I go with (1).

(1) is done.

Here I go with (2).

What I need to do...
- Each integer literal must be wrapped in a call to the constructor.
That's easy.
- The primitive integer functions need to extract the integer, and return an
  error if there is an error.
That's slightly tedious, but easy.
- We need to declare the data type for integer.
But we want to only do it once. This is a little tricky.

I feel like a nice way to do it would be to have a DataD declaration in
prelude for integer. Then I can just special case that in the compiler.

data Integer = ;

That's reasonable, right?

The thing is, it means I'll want to special case it in the haskell target too.

How about this. I may be able to get away with not supporting the integer
error for my test cases. So I could skip to (3). Get that to work. Understand
if there are other issues I need to be aware of.

Then, overhaul the haskell target. Using a compiler like the yices target. Fix
the primitives declarations issue. Define haskell primitives like I do in
yices, based on the PrimD. Stop handling Bool specially.

Then, add Integer and Char as primitive data type declarations. Then box
Integer for the yices target.

I think that makes sense to do.

Okay, let me fix the case statement generation now then. Remember, we expect
polymorphic. So every type is ConT "foo" that isn't a function type.

Wed Jun 27 09:05:06 EDT 2012

Well... so much for thinking it would work without defining Integer__...

How about this. As a hack, I can declare the integer data type first...
no. Don't hack.

Let me save this. Do the haskell thing, then come back to fix this.

Wed Jun 27 09:07:19 EDT 2012

Okay, haskell target.

Replace "Builtins" with "Compiler".
Let's keep includes in place for now.
Otherwise make it look just like yices, with the partial compiler thing.

Wed Jun 27 10:44:08 EDT 2012

Ug. So, not surprisingly, I'm running into annoying issues.

If you really want to do replacement for haskell, you want to replace patterns
too. And have includes. And ... ug.

I think I can hack around it by just a little bit of tedium for now, but it
might be worth reconsidering this distributed compiler thing in the future.
It's starting to look a lot like inheritance, which I don't much like.

Wed Jun 27 10:52:36 EDT 2012

Ug. This is really annoying. Having to write complex expressions in template
haskell abstract syntax. It should be a library. But whenever I try to do the
library, I run into the dependency issue.

Wed Jun 27 10:57:37 EDT 2012

Well, I'm pretty close. Just need show now...

Wed Jun 27 11:06:13 EDT 2012

I hacked something together for the haskell thing. Enough, hopefully, to let
me keep going. Back to the yices issue.

What I'm going to do:
1. define Integer as a data type in prelude.
2. use that in yices to generate the boxed Integer type.

It's as easy as that, no?

Wed Jun 27 13:16:10 EDT 2012

Integer is defined as a data type in prelude.
Let me, in the yices compiler, generate the boxed type for it.

Wed Jun 27 13:40:07 EDT 2012

Well, so, here's an interesting question... does it work? Does it do what we
want? What do we want it to do?

Currently we treat Error as a different value. But what should happen if we
assert an error? I don't know. Maybe I'll leave that for later. Currently I
treat it as false. I could do other things with it too I suppose.

Good. Everything's up and runnning again.

Err... but now we have another problem.

Your free variables could be errors. In which case, everything will return
error?

This is certainly not satisfactory. Perhaps I should assert that none of the
free variables are errors?

Ug. This gets messier and messier. I should ask for other people's opinions. I
think I know the issues now.

I don't know what to do. I don't know if I can check in my changes. This is
going to need some thought and discussion.

