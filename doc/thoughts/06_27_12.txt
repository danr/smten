
Wed Jun 27 08:36:24 EDT 2012

1. Declare Foo-Error constructor for every data defined type.
2. Box integer in a user defined data type.
3. Return Foo-Error as the default case value in case expressions.

Here I go with (1).

(1) is done.

Here I go with (2).

What I need to do...
- Each integer literal must be wrapped in a call to the constructor.
That's easy.
- The primitive integer functions need to extract the integer, and return an
  error if there is an error.
That's slightly tedious, but easy.
- We need to declare the data type for integer.
But we want to only do it once. This is a little tricky.

I feel like a nice way to do it would be to have a DataD declaration in
prelude for integer. Then I can just special case that in the compiler.

data Integer = ;

That's reasonable, right?

The thing is, it means I'll want to special case it in the haskell target too.

How about this. I may be able to get away with not supporting the integer
error for my test cases. So I could skip to (3). Get that to work. Understand
if there are other issues I need to be aware of.

Then, overhaul the haskell target. Using a compiler like the yices target. Fix
the primitives declarations issue. Define haskell primitives like I do in
yices, based on the PrimD. Stop handling Bool specially.

Then, add Integer and Char as primitive data type declarations. Then box
Integer for the yices target.

I think that makes sense to do.

Okay, let me fix the case statement generation now then. Remember, we expect
polymorphic. So every type is ConT "foo" that isn't a function type.

Wed Jun 27 09:05:06 EDT 2012

Well... so much for thinking it would work without defining Integer__...

How about this. As a hack, I can declare the integer data type first...
no. Don't hack.

Let me save this. Do the haskell thing, then come back to fix this.

Wed Jun 27 09:07:19 EDT 2012

Okay, haskell target.

Replace "Builtins" with "Compiler".
Let's keep includes in place for now.
Otherwise make it look just like yices, with the partial compiler thing.

Wed Jun 27 10:44:08 EDT 2012

Ug. So, not surprisingly, I'm running into annoying issues.

If you really want to do replacement for haskell, you want to replace patterns
too. And have includes. And ... ug.

I think I can hack around it by just a little bit of tedium for now, but it
might be worth reconsidering this distributed compiler thing in the future.
It's starting to look a lot like inheritance, which I don't much like.

Wed Jun 27 10:52:36 EDT 2012

Ug. This is really annoying. Having to write complex expressions in template
haskell abstract syntax. It should be a library. But whenever I try to do the
library, I run into the dependency issue.

Wed Jun 27 10:57:37 EDT 2012

Well, I'm pretty close. Just need show now...

