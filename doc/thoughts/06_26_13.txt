
Wed Jun 26 13:35:30 EDT 2013

I defined Syntax and Ppr.

The next step of proposed cleanup was to clean up names, but it seems to me I
don't need to clean up names to dive into the next real technical challenge.

So let me instead dive into the next real technical challenge: requalify all
the names to Smten.Lib.

* The module name should be "Smten.Lib.*"
* Imports should be "Smten.Lib.*"
* Qualified names should be "Smten.Lib.*"

There's a question of how we want to represent imports. I think as strings
already qualified.

Let me make that change, then dive in.

Wed Jun 26 13:48:17 EDT 2013

Issues:
* don't prefix unqualified names with Smten.Lib
    done.
* I need to provide the base package for Smten.Lib....

How should I go about providing the base package gor Smten.Lib?

I could try to generate it automatically, or I could try to write it by hand.

The benefits of automatic generation:
 - I let the plugin do all the work
 - It uses the same names as the compiler generates

The benefits of writing it by hand:
 - it probably has a lot of stuff the plugin won't support
    including recursive modules.

I think, for practical purposes, it makes sense to start by writing the
library by hand.

Where should I define it?
How about smten-runtime?

Sounds reasonable to me. Let me get started:

Smten.Lib.GHC.Tuple
Smten.Lib.GHC.Types
Smten.Lib.GHC.Prim
Smten.Lib.GHC.Base
Smten.Lib.GHC.Err

Smten.Lib.GHC.Enum
Smten.Lib.GHC.List
Smten.Lib.GHC.Integer.Type
Smten.Lib.GHC.Num
Smten.Lib.GHC.CString
Smten.Lib.GHC.Classes
Smten.Lib.Data.Maybe
Smten.Lib.Data.Tuple
Smten.Lib.System.IO
Smten.Lib.Control.Exception.Base

Oh... it's going to be tricky. Because a lot of this I will certainly NOT want
to implement manually.

I think I'll have to implement some manually, but some I should be able to
generate code for.

What I really want to create is a cabal package:
    smten-base

which has all the things we want. Regardless of how the smten-base package is
built.

And in practice, some of these will be automatically generated if possible. (I
fear compiling Data.Maybe, for example, when that's already part of base).
Others will be manually generated.

I'll have to stew about how I want to handle this.

It might be nice to run a test: let me try compiling Data.Maybe with my plugin
and see what happens.

Worst case, we can probably rename the packages and have some name
transformation to indicate the desired target.

Looks like I can compile individual things, like Data.Maybe. That's good to
know.

I'll stew now.

Wed Jun 26 16:49:11 EDT 2013

Here's the plan. It's fairly straight forward.

smten-base/smten-base.cabal
           Setup.hs
           LICENSE
           Smten/Lib/Foo.hs   <-- for manually implemented things
           src/Bar.hs         <-- for auto generated things

Build process:

1. copy template to build directory.
2. compile all autogenerated things into build directory.
3. cabal install the package

Wed Jun 26 17:12:37 EDT 2013

Next issue to work out:
 I need a way to specify the output directory for generated code.
 How about just the current directory for now?

Or... use -outputdir flag. See if I can figure out some way to read that. I
think that would be good.

Wed Jun 26 17:34:31 EDT 2013

Use: -odir
getDynFlags to get the flags in CoreM
objectDir gives us the name of the object dir.

That's easy enough.

