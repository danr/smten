
- add layout support
- support negative literals?
- deriving Eq would be nice.
- default methods in classes?

- line numbers for non-syntactic errors would be nice.

- Test type inference and type checking
** Verify we check for the instance or context for every method call
** Verify we check for too many arguments in a ConP, or too few
** Verify we check for undefined variables
** Verify we can't over apply a type, for example: Maybe Integer Bool.
** Verify we can't declare the same variable twice.
** Verify all clauses have to have the same number of args.
** Verify recursive lets aren't allowed
** Verify recursive definitions in lets aren't allowed (self recursion)

- Reimplement TypeCheck to make use of constraint generation from TypeInfer?

- Understand all the conflicts in the parser.
I suspect many of the reduce/reduce are from:
    foo :: (Foo a) -> Sludge
vs. foo :: (Foo a) => Sludge

- String literals
    For example: fail "deq on empty fifo"

- Allow arbitrary patterns in lambda expression arguments.
    example: \(Foo x) -> x+1

- Add support for list sequences
    example: [1..5]

- support for pattern guards?
- support for pattern bindings: x@(...)

- have common option parsing for serie, serih, seriq, serim, serit?
- what happens if we realize a free integer variable which is a dont-care?

- functions with clauses in let would be nice.

- array comprehension.
- pattern guards would be nice.

- move TypeInfer, TypeCheck and TypeSolve into a Type/ folder?
This might make a lot more sense after moving stuff in Types to Prelude.hs.

- link Yices and Yices2 somehow so they can borrow code from each other more
  easily?

- interpret function evidence
- interpret char evidence (?)

- modularity support
- give a better message if a declaration is multiply defined.
Rather than: "this doesn't exist".
I think it's a problem in the type checker? Check for my lookupVar calls and
make sure I report the failing message.

- document the executables much better.

- give an instance of Eq to Char
- deriving Eq would be very nice.

- give a nice message if there's a type ambiguity?
That is, anything with ~?

- pretty printer parser problems:
** don't print out builtin prelude?
** in data constructors: a type (Foo -> Bar) doesn't get parenthesis
** in data constructors: a type (Foo Bar) doesn't get parenthesis
** do notation <- doesn't work with explicit type (parser bug?)
** Foo Bar -> Sludge fails to parse.
** ppr can generate recursive lets, which we don't parse.
** contexts need commas: (Eq a, Eq b), not (Eq a Eq b)
** parser doesn't parse foo :: (Foo Bar) -> ...
Conflicts with (Foo Bar) => ... ?

