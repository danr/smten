Major Performance::
* understand poor arch-extract performance
* Loss of sharing for Int and Char (sketch performance bug)
    symapp of int and char looses sharing, leads to exponential blowup.
    memoization solves the specific case, but hurts concrete performance
    fairly significantly.

Release to Public::
* write up tutorials (github #3)
    T5-BitVectors
      Requires Enum instance for Bit. (github #10)
      Requires GHC.Enum.Enum instance for Bit??
    T6-Datatypes
    T7-SMTMonad
    T8-Profiling
* put smten on hackage (after tutorials are posted nicely?)
* SMT.Bit.Large fails for yices1 for some strange reason (github #7)

Runtime::
* handle error and infinity correctly.
 ** andF doesn't need to be lazy in first argument
        That is, _|_ andF falseF can be _|_
 ** iteF doesn't need to be lazy in the first argument
        That is, if _|_ then a else b can be _|_
 ** orF doesn't need to exist. No one calls it.
 ** Overall performance:
    - shampi: - Concrete evaluation dominates
    - nqueens: - Assert dominates
    - sudoku: - Check dominates
    - sketch: - trouble with <= and == for Int type.
                
 ** Many possible optimizations removed to get decent implementation
    - Model.cache - split into multiple caches based on type?
    - SPECIALIZE pragmas for
        ** symapp of int,
        ** use, unary, binary of Runtime.Assert
    - Don't call sat solver for assert False
    - Don't call sat solver for assert True
    - a & b & b & b   ====>  a & b
    - Track mzero explicitly?
        to take advantage of the high-level knowledge we have that the value
        is unreachable (we don't need an SMT solver to tell us that) That is,
        there is a difference between Unreachable _|_ and general _|_, and it
        would be nice if we tracked that mzero is the Unreachable kind.
    - Track mzero explicitly for IntegerF rather than introducing spurious
      dummy values.

Cleanup::
* Naming conventions are all over the place for formulas. Fix it please.
* (let {} in x  ====>  x)    in haskell output syntax 
* Does smten-base.cabal really need to expose all modules?
* Support symbolic IO?
    Q: Or is it okay because it can't ever appear in an assertion?
    A: It is not okay, because we might want to realize a symbolic IO.
* Why is bv_extract primitive? Why not just shift right and truncate?

Smten Executable::
* Generate code into temp directory instead of current directory?
* Remove generated code after generating it?
* Add a flag for generating a cabal package?

Concrete Performance::
* Special case pattern matching on concrete objects with a tag?
    Except, this doesn't improve symbolic performance any, which is sad.
* Enable -O on all smten files
 - Report FastString string-table reinitializeGlobal bug to ghc
 - ite0 doesn't support types of kind # (needed for Smten.Data.Char)
 - emptycase doesn't support types of kind #  (needed for Smten.Data.Char)
 - Support unboxed tuple. (needed for Smten.Data.List,
                                      Smten.Data.Array)
    Both the type constructor (#, #),
    And data constructor (for case expressions)
      we may need a special case for this as concrete, if it, indeed, is
      concrete...
* optimize primitives as needed (see int_add for example)
* generate INLINE pragmas for bindings annotated as inline?
    (see inlinePragInfo in ghc api)

Symbolic Performance::
* for yices1: having a shl_n function, which shifts by a constant amount,
    could lead to a decent performance improvement in that case.
* make <, >, >= primitives?
* implement or_bool on all the solvers rather than falling back to the default

Front End::
* Auto-derive Show, Eq, Ord, Ix
  maybe look into possibility of using Eq, Ord, etc... from ghc for this

Documentation
* Generated code should have a comment saying it was automatically generated.
* Make it so generated haddock documentation for smten-base is nice
* Make it so generated haddock documentation for smten-lib is nice

Known Bugs::
* nqueens -s yices1 -e Bit 55  seg faults
* yices1 seg faults on arch-extract isCF for rules 2, 4
* generate code for  (case x of { __DEFAULT -> ...}) 
    when 'x' is not an algebraic data type
    (For example: try adding strict fields to Data.Map)
* see problems with -O optimization above
* symapp for variable bit-vector
    Implement it like we implement symapp for Integer
* add support for integers to minisat.
* add support for integers to 'smten' solver.

Suspected Bugs::
* I suspect problems with using a function called 'main' as a normal function
  exported to another module instead of just as a top level main function.
* DEFAULT branches should use strict pattern matching?
* Enum for Bit doesn't let you go up to maxBound. ex: [5 .. 7] with 3 bits
            
other::
* TODO's inlined in the code
* Do a code review of all of Smten, figure out what can be cleaned up and how.

