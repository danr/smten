
Haskell Features::
* support negative literals?
* default methods in classes?
* allow arbitrary patterns in lambda expression arguments.
    example: \(Foo x) -> x+1
* add support for list sequences
    example: [1..5]
* list comprehension.
* support for pattern guards?
* support for pattern bindings: x@(...)
* Variable operators: `foo`.
* pattern matching in do bind notation.
* pattern matching against bit vectors
* support type synonyms? 
* auto derive Show
* recursive let blocks
* modularity support
* automatically import Prelude
* supply operator precedence as expected for default operators

Test Type Checking::
* Verify we check for the instance or context for every method call
* Verify we check for too many arguments in a ConP, or too few
* Verify we check for undefined variables
* Verify we can't over apply a type, for example: Maybe Integer Bool.
* Verify we can't declare the same variable twice.
* Verify all clauses have to have the same number of args.
* Verify recursive definitions in lets aren't allowed (self recursion)
* Verify ambiguous types aren't allowed
* Verify a type constructor used has been declared somewhere.
* Verify a free variable in an expression is not allowed.
* Verify all methods have been defined for a class instance.
* Verify you can't refer to a nonexistent type
* Verify we can't use a made up data constructor: ex: Answer True
* Verify we can't use a data constructor where a type constructor is expected

Type System::
* give a nice message if there's a type ambiguity?
    That is, anything with ~?
* Reimplement TypeCheck to make use of constraint generation from TypeInfer?
* Make numeric types happy
* Implement enough math somewhere to know that
  Bit #3  -> Bit #4 -> Bit #7 is a valid subtype of
  Bit #m  -> Bit #n -> Bit #(m+n)

  Because otherwise bitvector concatentation is really annoying to use.

Front End::
* line numbers for non-syntactic errors would be nice.
* Understand all the conflicts in the parser.
I suspect many of the reduce/reduce are from:
    foo :: (Foo a) -> Sludge
vs. foo :: (Foo a) => Sludge
* support parser-error layout rule.
    For example: (let foo = bar in foo x)
* Report an error if module name doesn't match source file name.
* allow multiply specified imports

Pretty Printer::
* Make pretty again.
* Make it so I can compile pretty printed code?
* Maybe dump the Doc approach and take my SMT concrete approach?

Performance::
* Play with GHC Sparks and non-strict state monads
* Add speculative elaboration to elaborator
* Compile seri to Haskell
* Add support for sharing in generated queries (?)
* Use the yices1 native interface where possible (everywhere?)

Solvers::
* Figure out how to test all the different solvers more completely
* Add minisat as a solver (requires CNF)
* Add Z3 as a solver

Static Analysis::
* Add static check for exhaustive case statements
* Add static check for concreteness of queries

SMT Syntax::
* Remove bv-zero-extend from SMT syntax, use SMTLIB2 alternative

Dealing with Free Things::
* what happens if we realize a free integer variable which is a dont-care?
* interpret function evidence
* interpret char evidence (?)
* Figure out how to give an instance of Free for just those function types
  that we support
* Don't allow deriving of Free for recursive data types
* Get rid of the __prim_free primitive
* Define SMT theory classes and add a solver phantom type to free and Query.
* Don't ask for the value of a free variable from an SMT solver unless it
  shows up in a query.

Bugs::
* seriq2 for SquaresRaw... result differs from yices1 and yices2. Why?
  seriq1 seg faults on that same example randomly
    (in GC evacuate at end of prog)
* Detect recursive functions in SNF elaboration and report an error about
  them.
* Report an error for an unknown primitive encountered in SMT Translation
* I suspect shadowed variables won't work in STP queries because of a bug in
  how let expressions are implemented. (Can that ever happen?)
* de_stringEH doesn't work without full elaboration of the argument I don't
  think. So if a test case fails, it doesn't do "error", it says unknown
  query.

Build System::
* Don't require yices1 and yices2 to be installed to build or use seri
    If a solver isn't installed, just give a runtime error when you try to
    use it. (As per request of Nirav)
* don't hardcode build/test output directory into SMT tests
* clean up tclmk script: maybe separate into init, build, and test sections.

Seri Library::
* Have the sudoku solver use IO to read the input board

Elaborator::
* Perhaps case statements should consider all constructors at once instead of
  one at a time?
* Don't elaborate an expression which has already been elaborated
* Figure out how to cheaply concretize free variables in expressions, ideally
  without forcing re-elaboration after concretization. Can I make use of HOAS
  somehow with this so I elaborate the right way from the start?
* Have common abstraction for evaluating an argument, used for case arguments
  and primitive arguments
* Propagate the error primitive up instead of calling error.
* Can I remove the distinction between SNF and WHNF elaboration? Can they be
  the same?
* Look over results of elaboration, especially SNF, to see if anything pops
  out, and make sure things aren't blown up too big.
* Have common abstraction for manipulating the yv part of a case expression.
* Consider more general concretization propagation?
* Share loading of top level declarations.
* Leverage let statements when doing function pushing to capture
  sharing
* Implement the 'update' primitive in the elaborator, or remove it from
  smt_array.
* Test out free_enum, see if it generate SAT (it may not...)

Haskell Backend::
* Push the compiler into one function, don't break it up the silly way it has
  been.
* Figure out how to avoid warnings about overlapping case alternatives

Other::
* Have name sugar for arrowN, tupleN, de_tupleN, unitN, etc...
* Review desugared expressions to see if they make sense or could be cleaned
  up.
* Get rid of Elaborate.ExpH. Those utilities should be in ExpH.Utils or some
  such.

