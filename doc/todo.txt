
- add layout support
- list literal patterns.
- support negative literals?
- deriving Eq would be nice.
- default methods in classes?

- line numbers for non-syntactic errors would be nice.

- Test type inference and type checking
** Verify we check for the instance or context for every method call
** Verify we check for too many arguments in a ConP, or too few
** Verify we check for undefined variables
** Verify we can't over apply a type, for example: Maybe Integer Bool.
** Verify we can't declare the same variable twice.
** Verify all clauses have to have the same number of args.
** Verify recursive lets aren't allowed
** Verify recursive definitions in lets aren't allowed (self recursion)

- Reimplement TypeCheck to make use of constraint generation from TypeInfer?

- Understand all the conflicts in the parser.
I suspect many of the reduce/reduce are from:
    foo :: (Foo a) -> Sludge
vs. foo :: (Foo a) => Sludge

- String literals
    For example: fail "deq on empty fifo"

- Allow arbitrary patterns in lambda expression arguments.
    example: \(Foo x) -> x+1

- Add support for list sequences
    example: [1..5]

- support for pattern guards?
- support for pattern bindings: x@(...)

- modules shouldn't automatically export everything they import.

- have common option parsing for serie, serih, seriq, serim, serit?
- what happens if we realize a free integer variable which is a dont-care?

- apply inlining, simplification to yices1?
- fix case arg duplication issue in yices1 like it was for yices2?

- I still see a segfault sometimes when running seriq2.

- functions with clauses in let would be nice.

- string literals.
- array comprehension.
- error primitive.
- pattern guards would be nice.

- split Parser into: Grammar.y, Lexer.hs, Monad.hs
Because it's getting way to big.

- make LitE which has IntegerL and CharL.

