
- add layout support
- support negative literals?
- default methods in classes?

- line numbers for non-syntactic errors would be nice.

- Test type inference and type checking
** Verify we check for the instance or context for every method call
** Verify we check for too many arguments in a ConP, or too few
** Verify we check for undefined variables
** Verify we can't over apply a type, for example: Maybe Integer Bool.
** Verify we can't declare the same variable twice.
** Verify all clauses have to have the same number of args.
** Verify recursive lets aren't allowed
** Verify recursive definitions in lets aren't allowed (self recursion)
** Verify ambiguous types aren't allowed
** Verify a type constructor used has been declared somewhere.
** Verify a free variable in an expression is not allowed.
** Verify all methods have been defined for a class instance.

- Reimplement TypeCheck to make use of constraint generation from TypeInfer?

- Understand all the conflicts in the parser.
I suspect many of the reduce/reduce are from:
    foo :: (Foo a) -> Sludge
vs. foo :: (Foo a) => Sludge

- Allow arbitrary patterns in lambda expression arguments.
    example: \(Foo x) -> x+1

- Add support for list sequences
    example: [1..5]

- support for pattern guards?
- support for pattern bindings: x@(...)

- have common option parsing for serie, serih, seriq, serim, serit?
- what happens if we realize a free integer variable which is a dont-care?

- functions with clauses in let would be nice.

- array comprehension.
- pattern guards would be nice.

- move TypeInfer, TypeCheck and TypeSolve into a Type/ folder?
This might make a lot more sense after moving stuff in Types to Prelude.hs.

- interpret function evidence
- interpret char evidence (?)

- modularity support

- document the executables much better.

- give a nice message if there's a type ambiguity?
That is, anything with ~?

- pretty printer parser problems:
** don't print out builtin prelude?
** do notation <- doesn't work with explicit type (parser bug?)

- somewhere it would be nice to have a convenience function for:
    load, flatten, infer, typecheck all at once into an environment.

- Figure out how to re-enable sharing for SMT queries.
There's an annoyance with sharing across commands I have to work out.

- Variable operators: `foo`.
- pattern matching in do bind notation.

- Implement enough math somewhere to know that
  Bit #3  -> Bit #4 -> Bit #7 is a valid subtype of
  Bit #m  -> Bit #n -> Bit #(m+n)

  Because otherwise bitvector concatentation is really annoying to use.

- yices generates duplicate Bit$__hash32 definitions for SquaresRaw, so we
  can't run the debug code. Bad.
- seriq2 for SquaresRaw... result differs from yices1 and yices2. Why?
- bv_extract should be a primitive.

