Focus::
* Catch-up: Locations for type errors
* Look-ahead: Fix issues with _|_ so semantics are correctly implemented

Recent::
* I should be able to implement bv_zero_extend a as bv_concat 0 a
    Fix type system so that works.
* bit vector support for:
    signExtend, arithmetic right shift, XOR, signLT, signGT.
* Don't pretty print numeric type 16 in haskellf as
    2*2*2*2*(1+0) ??
    depends if you want detailed type info or not.
* Finish cleaning up type check
* varTs should return a list of TyVar, not (Name, Kind)
* Bug: foo :: Integer
       fop = 3
    Is accepted, and 'fop' is treated like 'foo'.
    I should give an error here.
* What if you forget a type signature, does it error, or blow up?
* Add support for semicolon error parsing rule in parser
* If default implementation is missing for an instance, generate a default
  of the form: error "Implementation of /= for Blah not defined"
* Have flags in smten exe to call ghc appropriately.

Haskell Features::
* Allow parens in InstD: instance (Foo Bar) where...
* default methods in classes?
* auto derive Ord, Ix
* recursive let blocks
* modularity support
** ability to re-export modules 
    (So we can include Smten.SMT instead of Smten.SMT.SMT, for example)
* labeled pattern matching.

Documentation::
* Write a user guide

Type System::
* give a nice message if there's a type ambiguity?
    That is, anything with ~?
* Reimplement TypeCheck to make use of constraint generation from TypeInfer?
* Implement enough math somewhere to know that
  Bit #3  -> Bit #4 -> Bit #7 is a valid subtype of
  Bit #m  -> Bit #n -> Bit #(m+n)

  Because otherwise bitvector concatentation is really annoying to use.

Front End::
* line numbers for non-syntactic errors would be nice.
* support parser-error layout rule.
    For example: (let foo = bar in foo x)
* Report an error if module name doesn't match source file name.
* Review desugared expressions to see if they make sense or could be cleaned
  up.
* Don't allow deriving of Free for recursive data types
* The code for handling stand-alone deriving feels very messy to me. Can we
  clean up how that works somehow?
* derived instance of Show should handle record type constructors
  appropriately.
* Better type errors
** give location of type error more specific than top level declaration.
** use type synonyms in errors.
** report an error for use of a type that isn't defined
* show string as "foobar" instead of ['f','o', 'o', 'b', 'a', 'r']

Pretty Printer::
* Make pretty again:
** Don't print types of patterns?
** Recognize if statements.
** Recognize do statements.
** Recognize multi-let statements?
** Recognize clauses:
    foo a b = blah  instead of  foo = \a b -> blah
** Print: Foo Bool b, not Foo (Bool) (b)
    When pretty printing data declarations
* Make it so I can compile pretty printed code?
* Maybe dump the Doc approach and take my SMT concrete approach?

Performance::
* Play with GHC Sparks and non-strict state monads

Sharing::
* Don't share trivially things.
    Maybe need a thunk' function to create unshared thunks?
* Why do we sometimes share "free~12"?? For example, in Datatype test.

Primitives::
* Concretize the rest of the haskellf primitives

SMT::
* Remove bv-zero-extend from SMT syntax, use SMTLIB2 alternative
* Add minisat as a solver (requires CNF)
* Add Z3 as a solver

Query::
* Figure out how to deal with debugging properly
* Don't ask for the value of a free variable from an SMT solver unless it
  shows up in a query.
* Deal with errors in queries correctly.
* Use value inference on assertion predicate to solve trivial predicates, then
  don't even send them to the SMT solver (?)

Query Optimizations::
* Perform case analysis to avoid inserting unnecessary error conditions
  automatically.
* Simplify (= x x) to True

Specialization::
* put it back in

HaskellF::
* Translate a module at a time instead of one big blob
* Perhaps use TH to make defining the HaskellF prelude easier?

Build System::
* Don't require yices1 and yices2 to be installed to build or use smten
    If a solver isn't installed, just give a runtime error when you try to
    use it. (As per request of Nirav)
* don't hardcode build/test output directory into SMT tests
* clean up tclmk script: maybe separate into init, build, and test sections.


Bugs::
* BadKind, DupInst, DupVar maltype tests
* Error tests
* where shadow test (in Concrete)
* tambig test (in State)
* STP bug (in Nest)
* STP bug (in Bit)
* Report an error for an unknown primitive encountered in SMT Translation
* It's possible to use a symbolic thing in a different context than it was
  defined, in which case bad stuff will happen.
            

Other::
* Have name sugar for arrowN, tupleN, de_tupleN, unitN, etc...
* Update LICENCE files to include 2013 copyright.
* TODO's inlined in the code
* Do a code review of all of Smten, figure out what can be cleaned up and how.
* Switch to n-ary "and" to help in debugging of SMT queries?

