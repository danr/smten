
Highly Desirable::
* StateT monad
* Arrays with bit-vector indices.

Haskell Features::
* Allow parens in InstD: instance (Foo Bar) where...
* default methods in classes?
* auto derive Ord
* recursive let blocks
* modularity support
** ability to re-export modules 
    (So we can include Seri.SMT instead of Seri.SMT.SMT, for example)
* labeled pattern matching.

Test Type Checking::
* Verify we check for the instance or context for every method call
* Verify we check for too many arguments in a ConP, or too few
* Verify we check for undefined variables
* Verify we can't over apply a type, for example: Maybe Integer Bool.
* Verify we can't declare the same variable twice.
* Verify all clauses have to have the same number of args.
* Verify recursive definitions in lets aren't allowed (self recursion)
* Verify ambiguous types aren't allowed
* Verify a type constructor used has been declared somewhere.
* Verify a free variable in an expression is not allowed.
* Verify all methods have been defined for a class instance.
* Verify you can't refer to a nonexistent type
* Verify we can't use a made up data constructor: ex: Answer True
* Verify we can't use a data constructor where a type constructor is expected

Type System::
* give a nice message if there's a type ambiguity?
    That is, anything with ~?
* Reimplement TypeCheck to make use of constraint generation from TypeInfer?
* Make numeric types happy
** Share VarT and AppT between regular and numeric types
* Implement enough math somewhere to know that
  Bit #3  -> Bit #4 -> Bit #7 is a valid subtype of
  Bit #m  -> Bit #n -> Bit #(m+n)

  Because otherwise bitvector concatentation is really annoying to use.

Front End::
* line numbers for non-syntactic errors would be nice.
* support parser-error layout rule.
    For example: (let foo = bar in foo x)
* Report an error if module name doesn't match source file name.
* Review desugared expressions to see if they make sense or could be cleaned
  up.
* Don't allow deriving of Free for recursive data types
* Add static check for concreteness of queries (?)
* The code for handling stand-alone deriving feels very messy to me. Can we
  clean up how that works somehow?

Pretty Printer::
* Make pretty again:
** Don't print types of patterns?
** Know about associativity for types:
    a -> Foo b  instead of a -> (Foo b)
** Recognize if statements.
** Recognize do statements.
** Recognize clauses:
    foo a b = blah  instead of  foo = \a b -> blah
* Make it so I can compile pretty printed code?
* Maybe dump the Doc approach and take my SMT concrete approach?

Performance::
* Play with GHC Sparks and non-strict state monads
* Concretize the rest of the haskellf primitives

Sharing::
* Why do we sometimes share "free~12"?? For example, in Datatype test.
* case desugaring still loses sharing of 'n' in a number of places?

ExpH::
* Perhaps case statements should consider all constructors at once instead of
  one at a time?

Primitives::
* Implement the 'update' primitive, or remove it from smt_array.
* Get rid of the __prim_free primitive
* Associate concrete haskell function with Prim to avoid duplication in Prim
  and concretized haskellf primitives.

SMT::
* Remove bv-zero-extend from SMT syntax, use SMTLIB2 alternative
* Add minisat as a solver (requires CNF)
* Add Z3 as a solver

Query::
* Figure out how to deal with debugging properly
* Don't ask for the value of a free variable from an SMT solver unless it
  shows up in a query.
* Deal with errors in queries correctly.
* Use value inference on assertion predicate to solve trivial predicates, then
  don't even send them to the SMT solver (?)

Query Optimizations::
* Perform case analysis to avoid inserting unnecessary error conditions
  automatically.

Specialization::
* put it back in

HaskellF::
* Translate a module at a time instead of one big blob
* derive more efficient de_seriS than just the default.
* Provide instances of SeriS for the tuples
* Perhaps use TH to make defining the HaskellF prelude easier?

Distribution::
* Move everything but the SMT solvers from seri-smt to seri.

Build System::
* Don't require yices1 and yices2 to be installed to build or use seri
    If a solver isn't installed, just give a runtime error when you try to
    use it. (As per request of Nirav)
* don't hardcode build/test output directory into SMT tests
* clean up tclmk script: maybe separate into init, build, and test sections.


Applications::
* HCP - get it working on the larger test cases
* TCP - Implement it
* SAT - implement MAXSAT
* SKETCH - port some of their gallery to seri

Bugs::
* seriq2 for SquaresRaw... result differs from yices1 and yices2. Why?
  seriq1 seg faults on that same example randomly
    (in GC evacuate at end of prog)
* Detect recursive functions in elaboration and report an error about
  them.
* Report an error for an unknown primitive encountered in SMT Translation
* I suspect shadowed variables won't work in STP queries because of a bug in
  how let expressions are implemented. (Can that ever happen?)
* do a where clause's bindings shadow the default case?
    ex:   let z = 3
          in case z of
                p | p /= 3 -> z
                  where z = p+1
                _ -> z
   does this return 3 or 4?
            

Other::
* Have name sugar for arrowN, tupleN, de_tupleN, unitN, etc...

