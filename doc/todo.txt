Major Performance::
* Understand sketch performance bug
* Finite formulas can grow infinitely (SMT.Opt.InfiniteFormula, SMT.Opt.PlusBottomBool)
    they should be bounded in size somehow to allow for incremental queries

Release to Public::
* write up tutorials (github #3)
    T5-BitVectors
      Requires Enum instance for Bit. (github #10)
      Requires GHC.Enum.Enum instance for Bit??
    T6-Datatypes
    T7-SMTMonad
    T8-Profiling
* put smten on hackage (after tutorials are posted nicely?)
* SMT.Bit.Large fails for yices1 for some strange reason (github #7)

Runtime::
* handle error and infinity correctly.
 ** andF doesn't need to be lazy in first argument
        That is, _|_ andF falseF can be _|_
 ** Overall performance:
    - shampi: - Concrete evaluation dominates
    - nqueens: - Assert dominates
    - sudoku: - Check dominates
    - sketch: - trouble with <= and == for Int type.
                
 ** Many possible optimizations removed to get decent implementation
    - Model.cache - split into multiple caches based on type?
    - SPECIALIZE pragmas for
        ** symapp of int,
        ** use, unary, binary of Runtime.Assert
    - Don't call sat solver for assert False
       except that it's nice to have for debugging.
    - Don't call sat solver for assert True
       except that it's nice to have for debugging.
    - a & b & b & b   ====>  a & b

Cleanup::
* Naming conventions are all over the place for formulas. Fix it please.
    Typically we combine an operation (ite, add, etc...) with a type (BitF,
    BitFF, IntegerF, ...). Functions must start lower, constructors upper, but
    I want the type always to be upper. So I propose the following:
        op_Type   for a function
        Op_Type   for a constructor.
    But note: the _Type is only needed if it is not clear from op.
* (let {} in x  ====>  x)    in haskell output syntax 
* Does smten-base.cabal really need to expose all modules?
* Why is bv_extract primitive? Why not just shift right and truncate?

Smten Executable::
* Generate code into temp directory instead of current directory?
* Remove generated code after generating it?
* Add a flag for generating a cabal package?

Concrete Performance::
* Special case pattern matching on concrete objects with a tag?
    Except, this doesn't improve symbolic performance any, which is sad.
* Enable -O on all smten files
 - Report FastString string-table reinitializeGlobal bug to ghc
 - ite0 doesn't support types of kind # (needed for Smten.Data.Char)
 - emptycase doesn't support types of kind #  (needed for Smten.Data.Char)
 - Support unboxed tuple. (needed for Smten.Data.List,
                                      Smten.Data.Array)
    Both the type constructor (#, #),
    And data constructor (for case expressions)
      we may need a special case for this as concrete, if it, indeed, is
      concrete...
* optimize primitives as needed (see int_add for example)
* generate INLINE pragmas for bindings annotated as inline?
    (see inlinePragInfo in ghc api)

Symbolic Performance::
* Get rid of hashtable for assert traversal.
    What I want is: each Formula object has a pointer to, say, (Int, Dynamic),
    where Int says which query number we are on, and Dynamic contains the
    generated formula. If this is a new query, we regenerate the Dynamic,
    otherwise we re-use the Dynamic. Checking for sharing turns into a
    constant time operation now.

    To do this... things get slightly messy, and will require unsafeIO, with
    issues of referential transparency: when is the IORef share, and when
    duplicated? We want it associated with the stablename of the constructor.

* for yices1: having a shl_n function, which shifts by a constant amount,
    could lead to a decent performance improvement in that case.
* make <, >, >= primitives?
* implement or_bool on all the solvers rather than falling back to the default

Front End::
* Auto-derive Show, Eq, Ord, Ix
  maybe look into possibility of using Eq, Ord, etc... from ghc for this

Documentation
* Generated code should have a comment saying it was automatically generated.
* Make it so generated haddock documentation for smten-base is nice
* Make it so generated haddock documentation for smten-lib is nice

Known Bugs::
* nqueens -s yices1 -e Bit 55  seg faults
* yices1 seg faults on arch-extract
* trouble with bit blasting (try minisat on arch-extract to see)
* see problems with -O optimization above
* symapp for variable bit-vector
    Implement it like we implement symapp for Integer
* add support for integers to minisat.
* add support for integers to 'smten' solver.

Suspected Bugs::
* I suspect problems with using a function called 'main' as a normal function
  exported to another module instead of just as a top level main function.
* DEFAULT branches should use strict pattern matching?
* Enum for Bit doesn't let you go up to maxBound. ex: [5 .. 7] with 3 bits
            
other::
* TODO's inlined in the code
* Do a code review of all of Smten, figure out what can be cleaned up and how.

