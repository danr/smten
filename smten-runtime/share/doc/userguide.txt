Smten User Guide
================
Richard Uhler <ruhler@csail.mit.edu>
June 06, 2013

Installing Smten
----------------
Smten is distributed as a cabal package.

To install the smten package, you must first install the yices1, yices2, and
STP solvers. Note that yices1 requires special installation procedures to work
correctly with Smten, as described below.

Installing Yices 1 and Yices 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Smten requires both yices1 and yices2 be installed on the system. It looks
for a yices1 library called "yices1" and a yices2 library called "yices2".
Because the yices libraries are both shipped as "yices", you will need to
rename them or provide a link to "yices1" and "yices2".

In order to use both yices1 and yices2 libraries in a single executable, smten
assumes the symbols in the yices1 library have been renamed so that prefixes
yices_ are now yices1_. The rename map is included in the doc directory.

For example, if you have libyices.a for yices1 and libyices.so.2.1.0 for
yices2 installed, to create the "yices1" and "yices2" libraries suitable for
use with smten, run the commands:

   objcopy --redefine-syms=doc/yicse1rename.txt libyices.a libyices1.a
   ln -s libyices.so.2.1.0 libyices2.so
   ln -s libyices.so.2.1.0 libyices.so.2.0 

Installing the Smten Package
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
After yices1, yices2, and STP have all been installed, the smten
packages can be installed as a normal cabal package. For example:

  cabal install smten

See the cabal-install manual for more information on how to install cabal
packages on your system.

The Smten Language
------------------
The Smten language is a Haskell-like programming language with support for
symbolic computations. Smten source files have the .smtn extension.

Haskell vs Smten
~~~~~~~~~~~~~~~~
Aside from support symbolic computations, the Smten language has the same
syntax and features as Haskell. In practice not all Haskell features have been
implemented yet in the Smten compiler. More specifically:

* Primitives types available in Smten include Integer and Char, but do not
  include fixed width integers or floating point numbers.
* Module support is limited.
* Newtype declarations are not supported.
* Top level variable declarations must have explicit types.
* Various other minor features of Haskell are not yet supported.
* Most haskell libraries have not yet been ported to Smten.

Smten makes a few extensions to Haskell:

* There is a primitive Bit vector type.
* There is limited support for numeric (size) types.
* Smten allows importing of Haskell code using the foreign function interface
  with a new calling convention "hs".
* Smten includes primitive Symbolic and SMT monads for manipulating symbolic
  computations and SMT queries.

The Symbolic Monad
~~~~~~~~~~~~~~~~~~
Smten includes a Symbolic monad for manipulating symbolic computations. The
Symbolic monad is defined in the Smten.Symbolic module. Its API is as
follows:

----------------
data Symbolic a = ...

instance Monad Symbolic
    return :: a -> Symbolic a
    return x = ...

    (>>=) :: Symbolic a -> (a -> Symbolic b) -> Symbolic b
    (>>=) x f = ...

class Free a where
    free :: Symbolic a

instance Free Integer
instance Free Bool
instance Free (Bit #n)

fail_symbolic :: Symbolic ()

data Solver = Yices1 | Yices2 | STP | Debug FilePath Solver
    deriving (Eq, Show)

run_symbolic :: Solver -> Symbolic a -> IO (Maybe a)
-----------------------

The type 'Symbolic a' represents a (possibly infinite) set of values of type
'a'. It is very similar to the list monad in haskell.

free:: The set of all possible values of the corresponding type. Primitive
instances of 'free' are provided for Integer, Bool, and Bit. Instance of
'free' for bounded algebraic data types can be automatically derived using
Haskell's deriving mechanism.

fail_symbolic:: Represents the empty set.

return:: The return primitive creates a 'Symbolic a' with its argument as the
single value.

>>=:: The second argument to bind is applied to each value in the first
argument to bind, and the union of the results is returned.

run_symbolic:: Run a symbolic computation using the given SMT solver. The
symbolic computation nondeterministically returns one of the elements of the
set, or Nothing if the set is empty.

For example, the following program uses the Symbolic monad with the Yices2 SMT
solver to test whether there exist any integers which satisfy the predicates
'f' and 'g':

------------
import Smten.Symbolic

f :: Integer -> Bool 
f = ...

g :: Integer -> Bool
g = ...

main :: IO ()
main = do
  result <- run_symbolic (Debug "query.dbg" Yices2) $ do
     x <- free
     if (f x && g x)
        then return x
        else fail_symbolic
  case result of
    Just v -> putStrLn $ "The Integer " ++ show v ++ " satisfies f and g"
    Nothing -> putStrLn $ "No Integer satisfies both predicates f and g"
-------------

The Smten Compiler
~~~~~~~~~~~~~~~~~~
The Smten compiler compiles smten code to Haskell. This is done using the
'smten' command.

For example, to compile "foo.smtn" and run the executable:

    smten --haskellf -f foo.smtn --hsdir build
    ghc -o foo -ibuild -main-is Smten.Lib.Main.__main build/Smten/Lib/Main/Main.hs
    ./foo

For more detail on the options available to the 'smten' command, run:

    smten --help

