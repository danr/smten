
module Prelude where

class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b

  (>>) :: m a -> m b -> m b
  (>>) a b = a >>= const b

  return :: a -> m a

  fail :: String -> m a
  fail s = error s

sequence :: Monad m => [m a] -> m [a]
sequence [] = return []
sequence (x:xs) = do
    v <- x
    vs <- sequence xs
    return (v:vs)

mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f as = sequence (map f as)

mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f as = mapM f as >> return ()

id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

($) :: (a -> b) -> a -> b
($) f x = f x

data Bool = False | True

(&&) :: Bool -> Bool -> Bool
(&&) True x = x
(&&) _ _ = False

(||) :: Bool -> Bool -> Bool
(||) True _ = True
(||) _ x = x

not :: Bool -> Bool
not True = False
not _ = True

otherwise :: Bool
otherwise = True

type String = [Char]

foreign import hs "Prelude.error"
    error :: String -> a

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

(++) :: [a] -> [a] -> [a]
(++) [] x = x
(++) (x:xs) ys = x : (xs ++ ys)



-- Primitive IO monad
data IO a = 

-- The IO monad primitives
foreign import hs "Prelude.return" 
    return_io :: a -> IO a

foreign import hs "Prelude.>>="
    bind_io :: IO a -> (a -> IO b) -> IO b

instance Monad IO where
  return = return_io
  (>>=) = bind_io

-- Print a character to stdout.
foreign import hs "Prelude.putChar"
    putChar :: Char -> IO ()

-- Print a string to stdout.
putStr :: String -> IO ()
putStr = mapM_ putChar

-- Print a line to stdout.
putStrLn :: String -> IO ()
putStrLn str = do
  putStr str
  putStr "\n"

