
module Prelude where

class Eq a where
   (==) :: a -> a -> Bool
   (==) a b = not (a /= b)

   (/=) :: a -> a -> Bool
   (/=) a b = not (a == b)

deriving instance Eq ()
deriving instance (Eq a, Eq b) => Eq (a, b)

class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b

  (>>) :: m a -> m b -> m b
  (>>) a b = a >>= const b

  return :: a -> m a

  fail :: String -> m a
  fail s = error s

sequence :: Monad m => [m a] -> m [a]
sequence [] = return []
sequence (x:xs) = do
    v <- x
    vs <- sequence xs
    return (v:vs)

mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f as = sequence (map f as)

mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f as = mapM f as >> return ()

id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

($) :: (a -> b) -> a -> b
($) f x = f x

data Bool = False | True
    deriving (Eq, Show)

(&&) :: Bool -> Bool -> Bool
(&&) True x = x
(&&) _ _ = False

(||) :: Bool -> Bool -> Bool
(||) True _ = True
(||) _ x = x

not :: Bool -> Bool
not True = False
not _ = True

otherwise :: Bool
otherwise = True

type String = [Char]

data Maybe a = Nothing | Just a
  deriving (Eq, Show)

instance Monad Maybe where
    fail _ = Nothing
    return = Just
    (>>=) m f = 
        case m of
            Just x -> f x
            Nothing -> Nothing

foreign import hs "Prelude.error"
    error :: String -> a

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

(++) :: [a] -> [a] -> [a]
(++) [] x = x
(++) (x:xs) ys = x : (xs ++ ys)

foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f z (x:xs) = foldl f (f z x) xs
foldl f z _ = z

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z (x:xs) = f x (foldr f z xs)
foldr f z _ = z

foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 f [x] = x
foldr1 f (x:xs) = f x (foldr1 f xs)
foldr1 _ [] = error "Prelude.foldr1: empty list"

and :: [Bool] -> Bool
and = foldr (&&) True

or :: [Bool] -> Bool
or = foldr (||) False

class Show a where
    show :: a -> String

instance Show Char where
    show c = ['\'', c, '\'']

deriving instance (Show a) => Show [a]

__show_helper :: [String] -> String
__show_helper [] = ""
__show_helper [x] = x
__show_helper xs = "(" ++ __show_helper2 xs ++ ")"

__show_helper2 :: [String] -> String
__show_helper2 [] = ""
__show_helper2 [x] = x
__show_helper2 (x:xs) = x ++ " " ++ __show_helper2 xs

-- Primitive IO monad
data IO a = 

-- The IO monad primitives
foreign import hs "Prelude.return" 
    return_io :: a -> IO a

foreign import hs "Prelude.>>="
    bind_io :: IO a -> (a -> IO b) -> IO b

class Num a where
  (+) :: a -> a -> a
  (*) :: a -> a -> a
  (-) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  fromInteger :: Integer -> a

instance Monad IO where
  return = return_io
  (>>=) = bind_io

foreign import hs "Smten.eq_Integer"
    __prim_eq_Integer :: Integer -> Integer -> Bool

instance Eq Integer where
    (==) = __prim_eq_Integer

instance Num Integer where
  (+) = __prim_add_Integer
  negate x = 0 - x
  fromInteger x = x

foreign import hs "Smten.add_Integer"
    __prim_add_Integer :: Integer -> Integer -> Integer


-- Print a character to stdout.
foreign import hs "Prelude.putChar"
    putChar :: Char -> IO ()

-- Print a string to stdout.
putStr :: String -> IO ()
putStr = mapM_ putChar

-- Print a line to stdout.
putStrLn :: String -> IO ()
putStrLn str = do
  putStr str
  putStr "\n"

type FilePath = String

