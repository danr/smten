
module Prelude where

-- Return the integer value of a numeric type.
valueof :: #n -> Integer

-- The single possible value for the given numeric type.
numeric :: #n

class Eq a where
   (==) :: a -> a -> Bool
   (==) a b = not (a /= b)

   (/=) :: a -> a -> Bool
   (/=) a b = not (a == b)

instance (Eq a) => Eq [a] where
   (==) [] [] = True
   (==) (x:xs) (y:ys) = (x == y) && (xs == ys)
   (==) _ _ = False

instance (Eq a, Eq b) => Eq (a, b) where
   (==) a b = (fst a == fst b) && (snd a == snd b)

instance (Eq a, Eq b, Eq c) => Eq (a, b, c) where
   (==) (a1, a2, a3) (b1, b2, b3) = and [a1 == b1,  a2 == b2, a3 == b3]

-- TODO: turn these into enum class methods.
enumFromTo :: Integer -> Integer -> [Integer]
enumFromTo a b =
  if a > b
    then []
    else a : enumFromTo (a+1) b

enumFrom :: Integer -> [Integer]
enumFrom i = i : enumFrom (i+1)

enumFromThen :: Integer -> Integer -> [Integer]
enumFromThen a b = a : enumFromThen b (b + b - a)

enumFromThenTo :: Integer -> Integer -> Integer -> [Integer]
enumFromThenTo a b c =
  if a > c
     then []
     else a : enumFromThenTo b (b + b - a) c

class Num a where
  (+) :: a -> a -> a
  (*) :: a -> a -> a
  (-) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  fromInteger :: Integer -> a

class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b

  (>>) :: m a -> m b -> m b
  (>>) a b = a >>= const b

  return :: a -> m a

  fail :: String -> m a
  fail s = error s

sequence :: Monad m => [m a] -> m [a]
sequence [] = return []
sequence (x:xs) = do
    v <- x
    vs <- sequence xs
    return (v:vs)

mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f as = sequence (map f as)

mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f as = mapM f as >>= (\_ -> return ())


id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

($) :: (a -> b) -> a -> b
($) f x = f x

data Bool = False | True
    deriving (Show)

instance Eq Bool where
    (==) a b = if a then b else not b
    (/=) a b = if a then not b else b

(&&) :: Bool -> Bool -> Bool
(&&) True x = x
(&&) _ _ = False

(||) :: Bool -> Bool -> Bool
(||) True _ = True
(||) _ x = x

not :: Bool -> Bool
not True = False
not _ = True

otherwise :: Bool
otherwise = True

type String = [Char]

data Maybe a = Nothing | Just a
  deriving (Eq, Show)

instance Monad Maybe where
    fail _ = Nothing
    return = Just
    (>>=) m f = 
        case m of
            Just x -> f x
            Nothing -> Nothing

instance Eq () where
    (==) () () = True

__prim_toInteger_Char :: Char -> Integer
__prim_fromInteger_Char :: Integer -> Char

instance Eq Char where
    (==) a b = __prim_toInteger_Char a == __prim_toInteger_Char b

__prim_eq_Integer :: Integer -> Integer -> Bool

instance Eq Integer where
    (==) = __prim_eq_Integer

__prim_add_Integer :: Integer -> Integer -> Integer
__prim_sub_Integer :: Integer -> Integer -> Integer
__prim_mul_Integer :: Integer -> Integer -> Integer

instance Num Integer where
  (+) = __prim_add_Integer
  (-) = __prim_sub_Integer
  (*) = __prim_mul_Integer
  negate x = 0 - x
  abs x = if x < 0 then negate x else x
  fromInteger x = x

data Ordering = LT | EQ | GT
    deriving (Eq)

__lexmerge :: Ordering -> Ordering -> Ordering
__lexmerge EQ x = x
__lexmerge x _ = x

__lexorder :: [Ordering] -> Ordering
__lexorder = foldr __lexmerge EQ


class (Eq a) => Ord a where
    compare :: a -> a -> Ordering
    compare x y
      | x == y = EQ
      | x <= y = LT
      | otherwise = GT

    (<) :: a -> a -> Bool
    (<) a b = compare a b == LT

    (>) :: a -> a -> Bool
    (>) a b = compare a b == GT

    (<=) :: a -> a -> Bool
    (<=) a b = compare a b /= GT

    (>=) :: a -> a -> Bool
    (>=) a b = compare a b /= LT

    max :: a -> a -> a
    max x y
        | x <= y = y
        | otherwise = x

    min :: a -> a -> a
    min x y
        | x <= y = x
        | otherwise = y


__prim_lt_Integer :: Integer -> Integer -> Bool
__prim_gt_Integer :: Integer -> Integer -> Bool
__prim_leq_Integer :: Integer -> Integer -> Bool
__prim_geq_Integer :: Integer -> Integer -> Bool

instance Ord Integer where
    (<) = __prim_lt_Integer
    (>) = __prim_gt_Integer
    (<=) = __prim_leq_Integer
    (>=) = __prim_geq_Integer


instance Ord Char where
    (<) a b = __prim_toInteger_Char a < __prim_toInteger_Char b
    (>) a b = __prim_toInteger_Char a > __prim_toInteger_Char b
    (<=) a b = __prim_toInteger_Char a <= __prim_toInteger_Char b
    (>=) a b = __prim_toInteger_Char a >= __prim_toInteger_Char b
    compare a b = compare (__prim_toInteger_Char a) (__prim_toInteger_Char b)

instance (Ord a) => Ord [a] where
    compare [] [] = EQ
    compare [] _ = LT
    compare (x:xs) [] = GT
    compare (x:xs) (y:ys) = __lexorder [compare x y, compare xs ys]

instance (Ord a, Ord b) => Ord (a, b) where
    compare (a, b) (c, d) = __lexorder [compare a c, compare b d]

instance (Ord a, Ord b, Ord c) => Ord (a, b, c) where
    compare (a, b, c) (d, e, f)
      = __lexorder [ compare a d, compare b e, compare c f]

fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y

curry :: ((a, b) -> c) -> a -> b -> c
curry f a b = f (a, b)

error :: String -> a

undefined :: a
undefined = error "Prelude.undefined"

-- Standard list functions

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

(++) :: [a] -> [a] -> [a]
(++) [] x = x
(++) (x:xs) ys = x : (xs ++ ys)

filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs) =
  if p x
    then (x : filter p xs)
    else filter p xs

concat :: [[a]] -> [a]
concat xss = foldr (++) [] xss

concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f =
  let g [] = []
      g (x:xs) = f x ++ g xs
  in g

head :: [a] -> a
head (x:_) = x
head [] = error "Prelude.head: empty list"

tail :: [a] -> [a]
tail (_:xs) = xs
tail [] = error "Prelude.tail: empty list"

init :: [a] -> [a]
init [x] = []
init (x:xs) = x : init xs
init [] = error "Prelude.init: empty list"

null :: [a] -> Bool
null [] = True
null _ = False

length :: [a] -> Integer
length [] = 0
length (_:l) = 1 + length l

(!!) :: [a] -> Integer -> a
(!!) [] _ = error "Prelude.!!: index too large"
(!!) (x:_) 0 = x
(!!) (_:xs) n = xs !! (n-1)

foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f z (x:xs) = foldl f (f z x) xs
foldl f z _ = z

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z (x:xs) = f x (foldr f z xs)
foldr f z _ = z

replicate :: Integer -> a -> [a]
replicate 0 _ = []
replicate n x = x : (replicate (n-1) x)

take :: Integer -> [a] -> [a]
take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n-1) xs

drop :: Integer -> [a] -> [a]
drop 0 xs = xs
drop _ [] = []
drop n (_:xs) = drop (n-1) xs

splitAt :: Integer -> [a] -> ([a],[a])
splitAt n xs = (take n xs, drop n xs)

dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile p [] = []
dropWhile p (x:xs) =
  if p x 
     then dropWhile p xs
     else x:xs

span :: (a -> Bool) -> [a] -> ([a], [a])
span p [] = ([], [])
span p (x:xs) =
  if p x
    then let (ys, zs) = span p xs
         in (x:ys, zs)
    else ([], x:xs)

break :: (a -> Bool) -> [a] -> ([a], [a])
break p = span (not . p)

isSpace :: Char -> Bool
isSpace ' ' = True
isSpace '\n' = True
isSpace _ = False

lines :: String -> [String]
lines [] = []
lines s =
  let (l, s') = break ((==) '\n') s
  in l : (case s' of
            [] -> []
            (_:s'') -> lines s''
         )

words :: String -> [String]
words s =
  case dropWhile isSpace s of
    [] -> []
    s' -> let (w, s'') = break isSpace s'
          in w : words s''

unlines :: [String] -> String
unlines = concatMap (flip (++) "\n")

reverse :: [a] -> [a]
reverse =  foldl (flip (:)) []

and :: [Bool] -> Bool
and = foldr (&&) True

or :: [Bool] -> Bool
or = foldr (||) False

any :: (a -> Bool) -> [a] -> Bool
any p = or . map p

all :: (a -> Bool) -> [a] -> Bool
all p = and . map p

elem :: (Eq a) => a -> [a] -> Bool
elem x = any (\v -> v == x)

notElem :: (Eq a) => a -> [a] -> Bool
notElem x = all (\v -> v /= x)

lookup :: (Eq a) => a -> [(a, b)] -> Maybe b
lookup _ [] = Nothing
lookup k ((x, y):xs) =
  if k == x
     then Just y
     else lookup k xs

zip :: [a] -> [b] -> [(a,b)]
zip = zipWith (,)

zipWith :: (a->b->c) -> [a] -> [b] -> [c]
zipWith z (a:as) (b:bs) = z a b : zipWith z as bs
zipWith _ _ _ = []

class Show a where
    show :: a -> String

__show_helper :: [String] -> String
__show_helper [] = ""
__show_helper [x] = x
__show_helper xs = "(" ++ __show_helper2 xs ++ ")"

__show_helper2 :: [String] -> String
__show_helper2 [] = ""
__show_helper2 [x] = x
__show_helper2 (x:xs) = x ++ " " ++ __show_helper2 xs

__prim_show_Integer :: Integer -> String

instance Show Integer where
    show = __prim_show_Integer

instance Show Char where
    show c = ['\'', c, '\'']

instance Show () where
    show () = "()"

instance (Show a, Show b) => Show (a, b) where
    show (x, y) = concat ["(", show x, ", ", show y, ")"]

instance (Show a, Show b, Show c) => Show (a, b, c) where
    show (x, y, z) = concat ["(", show x, ", ", show y, ", ", show z, ")"]

instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d) where
    show (a, b, c, d)
      = concat ["(", show a, ", ", show b, ", ", show c, ", ", show d, ")"]

instance (Show a) => Show [a] where
    show xs = concat ["[", showListHelper xs, "]"]

-- Show a list without the open and close brackets
showListHelper :: (Show a) => [a] -> String
showListHelper [] = "" 
showListHelper [x] = show x
showListHelper (x:xs) = concat [show x, ", ", showListHelper xs]

-- Primitive IO monad
data IO a = 

-- The IO monad primitives
return_io :: a -> IO a
bind_io :: IO a -> (a -> IO b) -> IO b

instance Monad IO where
  return = return_io
  (>>=) = bind_io

-- Print a character to stdou.
putChar :: Char -> IO ()

-- Print a string to stdout.
putStr :: String -> IO ()
putStr = mapM_ putChar

-- Print a line to stdout.
putStrLn :: String -> IO ()
putStrLn str = do
  putStr str
  putStr "\n"

-- Read the contents of stdin.
getContents :: IO String

type FilePath = String

