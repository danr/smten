
module Smten.Tests.SMT.Error (tests) where

import Smten.Symbolic
import Smten.Tests.SMT.Test

boom :: Bool -> Bool
boom x = boom (not x)

series :: Integer -> Integer
series x = if x > 0
              then x + series (x-1)
              else 0

series2 :: Integer -> Integer
series2 x = if x == 0
              then 0
              else x + series2 (x-1)

tests :: IO ()
tests = do
    -- After assert false, explicit error should not be evaluated.
    symtesteq "SMT.Error.Error" Nothing [Yices2] $ do
        p <- free
        assert (p && not p)
        assert (error "boom!")
        return p

    -- After assert false, non-termination should not be evaluated.
    -- TODO: this test case fails!
    symtesteq "SMT.Error.Boom" Nothing [] $ do
       p <- free
       assert (p && not p)
       assert (boom True)
       return p

    symtesteq "SMT.Error.QCasePush" (Just True) [Yices2] $ do
        p <- free
        assert p
        assert (case (if p then (Nothing :: Maybe Bool) else error "qcasepush else") of
                    Nothing -> True
                    _ -> error "qcasepush _"
                 )
        return p
            

    -- It should not take an infinite amount of time to test a finite number of
    -- things. Right?
    --
    -- Or maybe assert (x > 0) is an infinite number of things, so it's okay to
    -- blow up?
    -- TODO: this test case fails!
    symtesteq "SMT.Error.Inc" Nothing [] $ do
        x <- free
        assert (x == 2)
        assert (series x == 4)
        return x

    -- It should not take an infinite amount of time to test a finite number of
    -- things. Attempt 2. This clearly should not blow up.
    -- TODO: this test case fails!
    symtesteq "SMT.Error.Inc2" Nothing [] $ do
        p <- free
        let x = if p then 4 else 10
        assert (series x == 4)
        return x

    -- TODO: this test case fails!
    symtesteq "SMT.Error.Inc3" Nothing [] $ do
        p <- free
        let x = if p then 4 else 10
        assert (series2 x == 4)
        return x

    symtesteq "SMT.Error.QSymSym" (Just (False, True)) [Yices2] $ do
        a <- free
        b <- free
        assert (not a)
        if a
            then error "qsymsym is not pruning!"
            else assert b
        return (a, b)

    symtesteq "SMT.Error.QHFeager" Nothing [Yices2] $ do
        p <- free
        assert p
        assert (
            if p
                then False
                else error "qhfeager"
          )
        return p

    putStrLn "SMT.Error PASSED"

