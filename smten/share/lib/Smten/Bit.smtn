
module Smten.Bit (
    Bit,
    bv_or, bv_and, bv_not, bv_shl, bv_sign_extend, bv_concat, bv_extract,
    ) where

import Data.Ix

import Smten.Numeric

-- Primitive bit vector type
data Bit #n

foreign import hs "Smten.Runtime.SmtenHS.add_Bit"
    add_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.sub_Bit"
    sub_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.mul_Bit"
    mul_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.eq_Bit"
    eq_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Runtime.SmtenHS.leq_Bit"
    leq_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Runtime.SmtenHS.or_Bit"
    bv_or :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.and_Bit"
    bv_and :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.shl_Bit"
    bv_shl :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.not_Bit"
    bv_not :: Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.sign_extend_Bit"
    bv_sign_extend :: Bit #n -> Bit #m

foreign import hs "Smten.Runtime.SmtenHS.concat_Bit"
    bv_concat :: Bit #n -> Bit #m -> Bit #(n+m)

-- Extract m bits from the given vector, with the least significant bit to be
-- extracted specified in the argument. The most significant bit is inferred.
foreign import hs "Smten.Runtime.SmtenHS.extract_Bit"
    bv_extract :: Bit #n -> Integer -> Bit #m

foreign import hs "Smten.Runtime.Bit.show_Bit"
    show_Bit :: Bit #n -> String

foreign import hs "Smten.Runtime.Bit.fromInteger_Bit"
    fromInteger_Bit :: Integer -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.toInteger_Bit"
    toInteger_Bit :: Bit #n -> Integer

instance Eq (Bit #n) where
    (==) = eq_Bit

instance Ord (Bit #n) where
    (<=) = leq_Bit

instance Integral (Bit #n) where
    toInteger = toInteger_Bit 

instance Num (Bit #n) where
    (+) = add_Bit
    (-) = sub_Bit
    (*) = mul_Bit
    fromInteger = fromInteger_Bit

instance Show (Bit #n) where
    show = show_Bit

instance Ix (Bit #n) where
    range (l, h) = 
      case (l > h, l == h) of
          (True, _) -> []
          (_, True) -> [h]
          _ -> l : range (l + 1, h)

    index (l, _) x = toInteger (x - l)

