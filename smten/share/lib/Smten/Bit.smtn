
module Smten.Bit (
    Bit,
    bv_or, bv_and, bv_not, bv_xor, bv_shl, bv_sizeof,
    bv_sign_extend, bv_zero_extend,
    bv_slt, bv_ashr, bv_lshr,
    bv_concat, bv_extract, bv_truncate,
    ) where

import Data.Ix

import Smten.Numeric

-- Primitive bit vector type
data Bit #n

foreign import hs "Smten.Runtime.SmtenHS.add_Bit"
    add_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.sub_Bit"
    sub_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.mul_Bit"
    mul_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.eq_Bit"
    eq_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Runtime.SmtenHS.leq_Bit"
    leq_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Runtime.SmtenHS.or_Bit"
    bv_or :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.and_Bit"
    bv_and :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.shl_Bit"
    bv_shl :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.lshr_Bit"
    bv_lshr :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.not_Bit"
    bv_not :: Bit #n -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.sign_extend_Bit"
    bv_sign_extend :: Bit #n -> Bit #m

foreign import hs "Smten.Runtime.SmtenHS.concat_Bit"
    bv_concat :: Bit #n -> Bit #m -> Bit #(n+m)

-- Extract m bits from the given vector, with the least significant bit to be
-- extracted specified in the argument. The most significant bit is inferred.
foreign import hs "Smten.Runtime.SmtenHS.extract_Bit"
    bv_extract :: Bit #n -> Integer -> Bit #m

foreign import hs "Smten.Runtime.Bit.show_Bit"
    show_Bit :: Bit #n -> String

foreign import hs "Smten.Runtime.Bit.fromInteger_Bit"
    fromInteger_Bit :: Integer -> Bit #n

foreign import hs "Smten.Runtime.SmtenHS.toInteger_Bit"
    toInteger_Bit :: Bit #n -> Integer

bv_ntype :: Bit #n -> #n
bv_ntype _ = numeric

bv_sizeof :: Bit #n -> Integer
bv_sizeof x = valueof (bv_ntype x)

bv_truncate :: Bit #n -> Bit #m
bv_truncate x = bv_extract x 0

bv_xor :: Bit #n -> Bit #n -> Bit #n
bv_xor a b = bv_and (bv_or a b) (bv_not (bv_and a b))

bv_zero_extend :: Bit #n -> Bit #m
bv_zero_extend = bv_concat 0

-- Signed comparisons
bv_slt :: Bit #n -> Bit #n -> Bool
bv_slt a b =
  case (bv_positive a, bv_positive b) of
     (True, False) -> False
     (False, True) -> True
     _ -> a < b

-- Test whether a signed bit vector is positive.
bv_positive :: Bit #n -> Bool
bv_positive a = bv_extract a (bv_sizeof a - 1) == (0 :: Bit #1)

-- Arithmetic right shift
bv_ashr :: Bit #n -> Bit #n -> Bit #n
bv_ashr a b
  = if bv_positive a
       then bv_lshr a b
       else bv_or (bv_lshr a b) (bv_not (bv_lshr (bv_not 0) b))


instance Eq (Bit #n) where
    (==) = eq_Bit

instance Ord (Bit #n) where
    (<=) = leq_Bit

instance Integral (Bit #n) where
    toInteger = toInteger_Bit 

instance Num (Bit #n) where
    (+) = add_Bit
    (-) = sub_Bit
    (*) = mul_Bit
    fromInteger = fromInteger_Bit

instance Show (Bit #n) where
    show = show_Bit

instance Ix (Bit #n) where
    range (l, h) = 
      case (l > h, l == h) of
          (True, _) -> []
          (_, True) -> [h]
          _ -> l : range (l + 1, h)

    index (l, _) x = toInteger (x - l)

