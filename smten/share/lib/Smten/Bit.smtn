
module Smten.Bit where

import Data.Ix

data Bit #n =

foreign import hs "Smten.Prim.__prim_eq_BitP"
    __prim_eq_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Prim.__prim_lt_BitP"
    __prim_lt_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Prim.__prim_leq_BitP"
    __prim_leq_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Prim.__prim_gt_BitP"
    __prim_gt_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Prim.__prim_geq_BitP"
    __prim_geq_Bit :: Bit #n -> Bit #n -> Bool

foreign import hs "Smten.Prim.__prim_add_BitP"
    __prim_add_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_sub_BitP"
    __prim_sub_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_mul_BitP"
    __prim_mul_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_show_BitP"
    __prim_show_Bit :: Bit #n -> String

foreign import hs "Smten.Prim.__prim_fromInteger_BitP"
    __prim_fromInteger_Bit :: Integer -> Bit #n

foreign import hs "Smten.Prim.__prim_toInteger_BitP"
    __prim_toInteger_Bit :: Bit #n -> Integer

foreign import hs "Smten.Prim.__prim_zeroExtend_BitP"
    __prim_zeroExtend_Bit :: Bit #n -> Bit #m

foreign import hs "Smten.Prim.__prim_signExtend_BitP"
    __prim_signExtend_Bit :: Bit #n -> Bit #m

foreign import hs "Smten.Prim.__prim_or_BitP"
    __prim_or_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_and_BitP"
    __prim_and_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_shl_BitP"
    __prim_shl_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_lshr_BitP"
    __prim_lshr_Bit :: Bit #n -> Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_not_BitP"
    __prim_not_Bit :: Bit #n -> Bit #n

foreign import hs "Smten.Prim.__prim_extract_BitP"
    __prim_extract_Bit :: Bit #n -> Integer -> Bit #m

foreign import hs "Smten.Prim.__prim_concat_BitP"
    __prim_concat_Bit :: Bit #n -> Bit #m -> Bit #(n+m)


instance Eq (Bit #n) where
    (==) = __prim_eq_Bit
    (/=) a b = not (a == b)

instance Ord (Bit #n) where
    (<) = __prim_lt_Bit
    (>) = __prim_gt_Bit
    (<=) = __prim_leq_Bit
    (>=) = __prim_geq_Bit
    compare x y =
      if (x == y)
        then EQ
        else if (x <= y)
                then LT
                else GT

instance Show (Bit #n) where
    show = __prim_show_Bit

instance Num (Bit #n) where
   (+) = __prim_add_Bit
   (-) = __prim_sub_Bit
   (*) = __prim_mul_Bit
   negate x = 0 - x
   abs = error "todo: abs for Bit #n"
   fromInteger = __prim_fromInteger_Bit

bv_ntype :: Bit #n -> #n
bv_ntype _ = numeric

bv_sizeof :: Bit #n -> Integer
bv_sizeof x = valueof (bv_ntype x)

bv_shl :: Bit #n -> Bit #n -> Bit #n
bv_shl = __prim_shl_Bit

-- Logical right shift
bv_lshr :: Bit #n -> Bit #n -> Bit #n
bv_lshr = __prim_lshr_Bit

-- Arithmetic right shift
bv_ashr :: Bit #n -> Bit #n -> Bit #n
bv_ashr a b
  = if bv_positive a
       then bv_lshr a b
       else bv_or (bv_lshr a b) (bv_not (bv_lshr (bv_not 0) b))

bv_or :: Bit #n -> Bit #n -> Bit #n
bv_or = __prim_or_Bit

bv_and :: Bit #n -> Bit #n -> Bit #n
bv_and = __prim_and_Bit

bv_not :: Bit #n -> Bit #n 
bv_not = __prim_not_Bit

bv_xor :: Bit #n -> Bit #n -> Bit #n
bv_xor a b = bv_and (bv_or a b) (bv_not (bv_and a b))

bv_zero_extend :: Bit #n -> Bit #m
bv_zero_extend = bv_concat 0

bv_sign_extend :: Bit #n -> Bit #m
bv_sign_extend = __prim_signExtend_Bit

-- Test whether a signed bit vector is positive.
bv_positive :: Bit #n -> Bool
bv_positive a = bv_extract a (bv_sizeof a - 1) == (0 :: Bit #1)

bv_truncate :: Bit #n -> Bit #m
bv_truncate x = bv_extract x 0

bv_concat :: Bit #n -> Bit #m -> Bit #(n+m)
bv_concat = __prim_concat_Bit

-- Extract m bits from the given vector, with the least significant bit to be
-- extract specified in the argument. The most significant bit is inferred.
bv_extract :: Bit #n -> Integer -> Bit #m
bv_extract = __prim_extract_Bit

-- Signed comparisons
bv_slt :: Bit #n -> Bit #n -> Bool
bv_slt a b =
  case (bv_positive a, bv_positive b) of
     (True, False) -> False
     (False, True) -> True
     _ -> a < b

bv_sle :: Bit #n -> Bit #n -> Bool
bv_sle a b = bv_slt a b || a == b

bv_sgt :: Bit #n -> Bit #n -> Bool
bv_sgt a b = not $ bv_sle a b

bv_sge :: Bit #n -> Bit #n -> Bool
bv_sge a b = not $ bv_slt a b


instance Ix (Bit #n) where
    range (l, h) = 
      case (l > h, l == h) of
          (True, _) -> []
          (_, True) -> [h]
          _ -> l : range (l+1, h)

    index (l, _) x = __prim_toInteger_Bit (x - l)

