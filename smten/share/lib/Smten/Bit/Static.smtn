
module Smten.Bit.Static (Bit, bv_or) where

import Data.Ix

import Smten.Numeric
import qualified Smten.Bit.Dynamic as D
import Smten.Symbolic

data Bit #n = Bit {
  dbit :: D.Bit
}

instance Eq (Bit #n) where
    (==) a b = dbit a == dbit b

instance Ord (Bit #n) where
    (<=) a b = dbit a <= dbit b

instance Num (Bit #n) where
    (+) a b = Bit $ dbit a + dbit b
    (-) a b = Bit $ dbit a - dbit b
    (*) a b = Bit $ dbit a * dbit b
    fromInteger i = Bit (D.bv_make (valueof (numeric :: #n)) i)

instance Show (Bit #n) where
    show = show . dbit

instance Ix (Bit #n) where
    range (l, h) = map Bit $ range (dbit l, dbit h)
    index (l, h) x = index (dbit l, dbit h) (dbit x)

instance Free (Bit #n) where
    free = do
        x <- free_Bit (valueof (numeric :: #n))
        return (Bit x)

bv_or :: Bit #n -> Bit #n -> Bit #n
bv_or a b = Bit (D.bv_or (dbit a) (dbit b))

