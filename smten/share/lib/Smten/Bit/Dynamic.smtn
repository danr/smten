
-- | Bit vector library. Widths are specified dynamically instead of enforced
-- statically to avoid complications with numeric types. But all operations
-- assume properly related widths.
module Smten.Bit.Dynamic (
    Bit, bv_make, bv_width, bv_value, bv_or,
    ) where

import Data.Ix

-- Primitive bit vector type
data Bit = 

-- bv_make width value
-- Construct a bit vector of given width and value.
foreign import hs "Smten.Runtime.Primitives.bv_make"
    bv_make :: Integer -> Integer -> Bit

foreign import hs "Smten.Runtime.Primitives.bv_width"
    bv_width :: Bit -> Integer

foreign import hs "Smten.Runtime.Primitives.bv_value"
    bv_value :: Bit -> Integer

foreign import hs "Smten.Runtime.SmtenHS.add_Bit"
    add_Bit :: Bit -> Bit -> Bit

foreign import hs "Smten.Runtime.SmtenHS.sub_Bit"
    sub_Bit :: Bit -> Bit -> Bit

foreign import hs "Smten.Runtime.SmtenHS.mul_Bit"
    mul_Bit :: Bit -> Bit -> Bit

foreign import hs "Smten.Runtime.SmtenHS.eq_Bit"
    eq_Bit :: Bit -> Bit -> Bool

foreign import hs "Smten.Runtime.SmtenHS.leq_Bit"
    leq_Bit :: Bit -> Bit -> Bool

foreign import hs "Smten.Runtime.SmtenHS.or_Bit"
    bv_or :: Bit -> Bit -> Bit

foreign import hs "Smten.Runtime.Primitives.show"
    show_Bit :: Bit -> String

instance Eq Bit where
    (==) = eq_Bit

instance Ord Bit where
    (<=) = leq_Bit

instance Integral Bit where
    toInteger = bv_value 

instance Num Bit where
    (+) = add_Bit
    (-) = sub_Bit
    (*) = mul_Bit
    fromInteger = error "fromInteger.Bit with unspecified bit width"

instance Show Bit where
    show = show_Bit
    
instance Ix Bit where
    range (l, h) = 
      case (l > h, l == h) of
          (True, _) -> []
          (_, True) -> [h]
          _ -> l : range (l + (bv_make (bv_width l) 1), h)

    index (l, _) x = bv_value (x - l)

