
module Smten.SMT.Symbolic where

import Control.Monad.IO.Class
import Smten.Bit

-- Primitive SMT reference.
data Used a =

-- Primitive Symbolic monad
data Symbolic a =

-- Built in symbolic things:
foreign import hs "Smten.SMT.Primitives.__prim_free_BoolP"
    __prim_free_Bool :: Symbolic Bool

foreign import hs "Smten.SMT.Primitives.__prim_free_IntegerP"
    __prim_free_Integer :: Symbolic Integer

foreign import hs "Smten.SMT.Primitives.__prim_free_BitP"
    __prim_free_Bit :: Symbolic (Bit #n)

class Free a where
    free :: Symbolic a

instance Free () where
    free = return ()

instance Free Bool where
    free = __prim_free_Bool

instance Free Integer where
    free = __prim_free_Integer

instance Free (Bit #n) where
    free = __prim_free_Bit

instance (Free a, Free b) => Free (a, b) where
    free = do
        a <- free
        b <- free
        return (a, b)

instance (Free a, Free b, Free c) => Free (a, b, c) where
    free = do
        a <- free
        b <- free
        c <- free  
        return (a, b, c)

deriving instance (Free a) => Free (Maybe a)
deriving instance Free Ordering

foreign import hs "Smten.SMT.Primitives.assertP"
    assert :: Bool -> Symbolic ()

foreign import hs "Smten.SMT.Primitives.usedP"
    used :: Used a -> Symbolic a

-- The Symbolic monad primitives
foreign import hs "Smten.SMT.Primitives.return_symbolicP"
    return_symbolic :: a -> Symbolic a

foreign import hs "Smten.SMT.Primitives.nobind_symbolicP"
    nobind_symbolic :: Symbolic a -> Symbolic b -> Symbolic b

foreign import hs "Smten.SMT.Primitives.bind_symbolicP"
    bind_symbolic :: Symbolic a -> (a -> Symbolic b) -> Symbolic b

foreign import hs "Smten.SMT.Primitives.fail_symbolicP"
    fail_symbolic :: String -> Symbolic a

instance Monad Symbolic where
  return = return_symbolic
  (>>=) = bind_symbolic
  (>>) = nobind_symbolic
  fail = fail_symbolic

-- Primitive SMT monad
data SMT a = 

foreign import hs "Smten.SMT.Primitives.query_UsedP"
    query_Used :: Used a -> SMT (Maybe a)

-- Ask the SMT solver for a concrete value contained in the given symbolic
-- expression.
-- The SMT context is not affected by this call.
query :: Symbolic a -> SMT (Maybe a)
query s = nest (use s >>= query_Used)

-- Run an SMT computation without changing the current SMT context.
foreign import hs "Smten.SMT.Primitives.nestP"
    nest :: SMT a -> SMT a

-- Commit the given symbolic computation to the current SMT context.
-- Returns a reference to the result of the symbolic computation in the SMT
-- context.
foreign import hs "Smten.SMT.Primitives.useP"
    use :: Symbolic a -> SMT (Used a)

-- The SMT monad primitives
foreign import hs "Smten.SMT.Primitives.return_smtP"
    return_smt :: a -> SMT a

foreign import hs "Smten.SMT.Primitives.nobind_smtP"
    nobind_smt :: SMT a -> SMT b -> SMT b

foreign import hs "Smten.SMT.Primitives.bind_smtP"
    bind_smt :: SMT a -> (a -> SMT b) -> SMT b

foreign import hs "Smten.SMT.Primitives.fail_smtP"
    fail_smt :: String -> SMT a

instance Monad SMT where
  return = return_smt
  (>>=) = bind_smt
  (>>) = nobind_smt
  fail = fail_smt


foreign import hs "Smten.SMT.Primitives.liftIO_SMTP"
    liftIO_SMT :: IO a -> SMT a

instance MonadIO SMT where
    liftIO = liftIO_SMT

data Solver = Yices1 | Yices2 | STP
            | Debug FilePath Solver
            | DebugLL FilePath Solver
    deriving (Eq, Show)

foreign import hs "Smten.SMT.Primitives.runSMTP"
    runSMT :: Solver -> SMT a -> IO a

-- Run symbolic directly in IO. Uses its own SMT context.
runSymbolic :: Solver -> Symbolic a -> IO (Maybe a)
runSymbolic s q = runSMT s (query q)

