
module Smten.SMT.Tests.Core (testcore) where

import Smten.SMT.Symbolic
import Smten.SMT.Tests.Test

p :: Bool -> Bool -> Bool -> Bool
p x y z =
    if x && y
        then not z
        else x == (y || z)

testcore :: IO ()
testcore = do
    symtesteq "Core.Trivial" (Just True) [Yices1, Yices2, STP] $ do
        a <- free
        assert a
        return a

    -- Verify we can handle functions in let expressions.
    symtesteq "Core.Finlet" (Just ()) [Yices1, Yices2, STP] $ do
        assert (let f = (\x -> x) in f True)

    -- Test NOT
    symtesteq "Core.Not" (Just False) [Yices1, Yices2, STP] $ do
        b <- free
        assert (not b)
        return b

    -- Test OR
    symtesteq "Core.Or" (Just (False, True)) [Yices1, Yices2, STP] $ do
        c <- free
        d <- free
        assert (c || d)
        assert (not c)
        return (c, d)

    -- Test AND
    symtesteq "Core.And" (Just (True, True)) [Yices1, Yices2, STP] $ do
        e <- free
        f <- free
        assert (e && f)
        return (e, f)

    -- Test EQ
    symtesteq "Core.Eq" (Just (False, False)) [Yices1, Yices2, STP] $ do
        g <- free
        h <- free
        assert (g == h)
        assert (not g)
        return (g, h)

    -- Test IF
    symtesteq "Core.If" (Just False) [Yices1, Yices2, STP] $ do
        i <- free
        assert (if i then False else True)
        return i

    -- Test more complex
    let tstcmplx (Just (jv, kv, lv)) = p jv kv lv
        tstcmplx _ = False
    symtest "Core.Complex" tstcmplx [Yices1, Yices2, STP] $ do
        j <- free
        k <- free
        l <- free
        assert (p j k l)
        return (j, k, l)

    -- Test an issue with lambdas that we've had issues with in the past.
    symtesteq "Core.Lambda" (Just False) [Yices1, Yices2, STP] $ do
        m <- free
        assert ((if m then (==) True else (==) False) False)
        return m

    -- We should be able to using Integers, so long as they aren't free, even
    -- if the underlying solver doesn't support them.
    symtesteq "Core.Integer" (Just (False, True)) [Yices1, Yices2, STP] $ do
        n <- free
        o <- free
        assert ((if n then 3 else (4 :: Integer)) == (if o then 4 else 5))
        return (n, o)

    -- Same with lists
    symtesteq "Core.List" (Just False) [Yices1, Yices2, STP] $ do
        p <- free
        assert (null (if p then [1, 2, 3 :: Integer] else []))
        return p

    -- Same with char
    symtesteq "Core.Char" (Just True) [Yices1, Yices2, STP] $ do
        q <- free
        assert ('a' == (if q then 'a' else 'b'))
        return q

    -- Test that primitives are reapplied after substitution.
    symtesteq "Core.Substitute" (Just True) [Yices1, Yices2, STP] $ do
        a <- free
        assert (not a)
        return (not a)

    -- Test conversion of symbolic Symbolic to concrete Symbolic.
    symtesteq "Core.Symsym" (Just (False, False)) [Yices1, Yices2, STP] $ do
        a <- free
        b <- free
        if a
            then do
                assert b
                assert False
            else do
                assert (not b)
        return (a, b)


