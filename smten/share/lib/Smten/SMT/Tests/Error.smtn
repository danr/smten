
module Smten.SMT.Tests.Error (test) where

import Smten.SMT.Symbolic
import Smten.SMT.Tests.Test

boom :: Bool -> Bool
boom x = boom (not x)

series :: Integer -> Integer
series x = if x > 0
              then x + series (x-1)
              else 0

series2 :: Integer -> Integer
series2 x = if x == 0
              then 0
              else x + series2 (x-1)

test :: IO ()
test = do
    -- After assert false, explicit error should not be evaluated.
    symtesteq "Error.Error" Nothing [Yices2] $ do
        p <- free
        assert (p && not p)
        assert (error "boom!")
        return p

    -- After assert false, non-termination should not be evaluated.
    -- TODO: this test case fails!
--    symtesteq "Error.Boom" Nothing [Yices2] $ do
--       p <- free
--       assert (p && not p)
--       assert (boom True)
--       return p

    symtesteq "Error.QCasePush" (Just True) [Yices2] $ do
        p <- free
        assert p
        assert (case (if p then (Nothing :: Maybe Bool) else error "qcasepush else") of
                    Nothing -> True
                    _ -> error "qcasepush _"
                 )
        return p
            

    -- It should not take an infinite amount of time to test a finite number of
    -- things. Right?
    --
    -- Or maybe assert (x > 0) is an infinite number of things, so it's okay to
    -- blow up?
    -- TODO: this test case fails!
--    symtesteq "Error.Inc" Nothing [Yices2] $ do
--        x <- free
--        assert (x == 2)
--        assert (series x == 4)
--        return x

    -- It should not take an infinite amount of time to test a finite number of
    -- things. Attempt 2. This clearly should not blow up.
    -- TODO: this test case fails!
--    symtesteq "Error.Inc2" Nothing [Yices2] $ do
--        p <- free
--        let x = if p then 4 else 10
--        assert (series x == 4)
--        return x

    -- TODO: this test case fails!
--    symtesteq "Error.Inc3" Nothing [Yices2] $ do
--        p <- free
--        let x = if p then 4 else 10
--        assert (series2 x == 4)
--        return x

    symtesteq "Error.QSymSym" (Just (False, True)) [Yices2] $ do
        a <- free
        b <- free
        assert (not a)
        if a
            then error "qsymsym is not pruning!"
            else assert b
        return (a, b)

    symtesteq "Error.QHFeager" Nothing [Yices2] $ do
        p <- free
        assert p
        assert (
            if p
                then False
                else error "qhfeager"
          )
        return p

