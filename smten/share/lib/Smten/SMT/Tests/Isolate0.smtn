
module Smten.SMT.Tests.Isolate0 where

import Prelude
import Smten.Bit
import Smten.SMT.Symbolic
import Smten.SMT.Tests.Sketch2QBF
import Smten.SMT.Tests.Sketch2QBF2
import Smten.Tests.Test

-- Test the isolate0 sketch

-- The specification: returns a bit vector with a single bit set, and that bit
-- is the right most zero bit in the given word.
isolate0 :: Bit #n -> Bit #n
isolate0 = isolate0' 1

-- Helper function for isolate0. Takes a target mask as input.
isolate0' :: Bit #n -> Bit #n -> Bit #n
isolate0' m n =
  if m == 0
      then 0
      else if bv_and m n == 0
               then m
               else isolate0' (bv_shl m 1) n

-- isolate0 1010_0111 = 167
-- To get:  0000_1000 = 8
example :: Bit #8
example = isolate0 167

-- The sketch
data Holes a = Holes {
    hole1 :: a,
    hole2 :: a
} deriving (Eq, Free)

instance (Show a) => Show (Holes a) where
    show (Holes h1 h2) = concat [
        "Holes { hole1 = ", show h1, ", hole2 = ", show h2, " }"]

isolate0sketch :: Holes (Bit #n) -> Bit #n -> Bit #n
isolate0sketch holes n
  = bv_and (bv_not (n + hole1 holes)) (n + hole2 holes)

holeswanted :: Holes (Bit #n)
holeswanted = Holes { hole1 = 0, hole2 = 1 }

iscorrect :: Holes (Bit #n) -> Bit #n -> Bool
iscorrect h x = isolate0 x == isolate0sketch h x

qsketch :: SMT (Maybe (Holes (Bit #8)))
qsketch = sketch2qbf iscorrect

qsketch2 :: SMT (Maybe (Holes (Bit #8)))
qsketch2 = sketch2qbf2 iscorrect

qmain :: SMT ()
qmain = do
    r <- qsketch
    test "sketch" (r == Just holeswanted)

    w <- qsketch2
    test "sketch2" (w == Just holeswanted)

main :: IO ()
main = do
    runSMT Yices2 (Just "build/test/Isolate0.dbg") qmain
    putStrLn "Isolate0 PASSED"

