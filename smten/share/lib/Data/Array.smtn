
module Data.Array where

import Data.Ix

import Smten.PrimArray

data Array i e = MkArray (i, i) (PrimArray e)

array :: Ix i => (i, i) -> [(i, e)] -> Array i e
array b ivs =
  let f x = case filter ((==) x . fst) ivs of
                [] -> error "Array.!: undefined array element"
                [(_, v)] -> v
                _ -> error "Array.!: multiply defined array element"
      arr = primArray (map f (range b))
  in MkArray b arr

(!) :: Ix i => Array i e -> i -> e
(!) (MkArray b arr) x = primSelect arr (index b x)

bounds :: Ix i => Array i e -> (i, i)
bounds (MkArray b _) = b

indices :: Ix i => Array i e -> [i]
indices = range . bounds

assocs :: Ix i => Array i e -> [(i, e)]
assocs a = map (\i -> (i, a!i)) (indices a)

(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
(//) a new_ivs =
  let new_is = map fst new_ivs
      old_ivs = map (\i -> (i, a ! i))
                  (filter (\i -> (notElem i new_is)) (indices a))
  in array (bounds a) (old_ivs ++ new_ivs)

instance (Ix i, Eq e) => Eq (Array i e) where
    (==) a b = (assocs a == assocs b)
    (/=) a b = not (a == b)

