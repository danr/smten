
module Smten.SMT.Tests.Squares.FIFO2 where {

import Prelude;
import Smten.SMT.Tests.Squares.Prelude;
import Smten.SMT.Tests.Squares.Reg;

data FIFO2 a = 
    FIFO2_Empty
  | FIFO2_Single a
  | FIFO2_Full a a
    deriving (Eq);

data MOD_mkFIFO a = MOD_mkFIFO (MOD_mkReg (FIFO2 a))
  deriving (Eq);

instance State (MOD_mkFIFO a) where {
   newState (MOD_mkFIFO r) = MOD_mkFIFO (newState r);

   parMerge (MOD_mkFIFO a) (MOD_mkFIFO b) =
     let { 
        (g, s) = parMerge a b;
     } in (g, MOD_mkFIFO s);

   seqMerge (MOD_mkFIFO a) (MOD_mkFIFO b) = MOD_mkFIFO (seqMerge a b);
};

ctor_mkFIFO :: MOD_mkFIFO a;
ctor_mkFIFO = MOD_mkFIFO (ctor_mkReg (FIFO2_Empty));

meth_enq_mkFIFO :: MOD_mkFIFO a -> a -> (Bool, MOD_mkFIFO a);
meth_enq_mkFIFO (MOD_mkFIFO r) v =
  let {
    (g1, r1, fifo) = meth_read_mkReg r;
    (g2, r2) = case fifo of {
                 FIFO2_Empty -> meth_write_mkReg r1 (FIFO2_Single v);
                 FIFO2_Single x -> meth_write_mkReg r1 (FIFO2_Full x v);
                 FIFO2_Full _ _ -> (False, error "enq to full fifo");
               };
  } in (g1 && g2, MOD_mkFIFO r2);

meth_deq_mkFIFO :: MOD_mkFIFO a -> (Bool, MOD_mkFIFO a);
meth_deq_mkFIFO (MOD_mkFIFO r) =
  let {
    (g1, r1, fifo) = meth_read_mkReg r;
    (g2, r2) = case fifo of {
                 FIFO2_Empty -> (False, error "deq to empty fifo");
                 FIFO2_Single x -> meth_write_mkReg r1 (FIFO2_Empty);
                 FIFO2_Full x y -> meth_write_mkReg r1 (FIFO2_Single y);
               };
  } in (g1 && g2, MOD_mkFIFO r2);

meth_first_mkFIFO :: MOD_mkFIFO a -> (Bool, MOD_mkFIFO a, a);
meth_first_mkFIFO (MOD_mkFIFO r) =
  let {
    (g1, r1, fifo) = meth_read_mkReg r;
    (g2, a) = case fifo of {
                 FIFO2_Empty -> (False, error "first to empty fifo");
                 FIFO2_Single x -> (True, x);
                 FIFO2_Full x y -> (True, x);
               };
  } in (g1 && g2, MOD_mkFIFO r1, a);

}

