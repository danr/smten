

module Smten.SMT.Tests.Bluespec where

import Prelude
import Smten.SMT.SMT

import Smten.SMT.Tests.FIFO

-- The system state:
data TState = TState {
    a :: Integer,
    f :: FIFO2 Integer,
    b :: Integer
} deriving (Eq, Free)

instance Show TState where
    show (TState a f b) = concat [
        "TState { ",
        "a = ", show a, ", ",
        "f = ", show f, ", ",
        "b = ", show b, "}"
      ]
     

-- The initial state.
s0 :: TState
s0 = TState 1 FIFO2_Empty 0

-- Rules:
-- p: f.enq(a+2)
p :: TState -> Maybe TState
p (TState a f b) = do
    f' <- enq f a
    return (TState (a + 2) f' b)

-- c: b <= f.first() + b; f.deq();
-- TODO: Support let in a do statement in smten (?)
c :: TState -> Maybe TState
c (TState a f b) = do
    v <- first f
    f' <- deq f
    return (TState a f' (v + b))

-- A couple specific compositions:
ppc :: TState -> Maybe TState
ppc s = do
    s1 <- p s
    s2 <- p s1
    c s2

pcp :: TState -> Maybe TState
pcp s = do
    s1 <- p s
    s2 <- c s1
    p s2

-- Assert a predicate holds for every input.
always :: (Free a) => (a -> Bool) -> Query ()
always f = do
    answer <- queryS (do
        x <- free
        assert (not (f x))
        query ()
      )
    case answer of
        Unsatisfiable -> return ()
        _ -> assert False

(==>) :: Bool -> Bool -> Bool
(==>) False _ = True
(==>) True x = x

-- Now for our query:
--  Are the two compositions "equivalent"?
--  That is, are they equivalent for all states s?
qmain1 :: Query (Answer ())
qmain1 = do
    always (\s -> (f s == FIFO2_Empty) ==> (ppc s == pcp s))
    --always (\s -> ppc s == pcp s)
    query ()

qmain :: Query (Answer TState)
qmain = do
    s <- free
    assert (not ((f s == FIFO2_Empty) ==> (ppc s == pcp s)))
    query s

main :: IO ()
main = do
    putStr "yices1..."
    r1 <- runYices1 (Just "build/test/Bluespec.yices1.dbg") qmain
    putStrLn (show r1)

    putStr "yices2..."
    r2 <- runYices2 (Just "build/test/Bluespec.yices2.dbg") qmain
    putStrLn (show r2)

