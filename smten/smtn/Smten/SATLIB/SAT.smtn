
-- | Implementation of a DIMACS cnf SAT solver in smten.
module Smten.SATLIB.SAT where

import Prelude
import Smten.SMT.SMT

type Clause = [Integer]

-- Mapping from Integer to boolean value.
type Vars = [Bool]

vlookup :: Integer -> Vars -> Bool
vlookup i l = l !! (i - 1)

sat :: Integer -> [Clause] -> Query (Answer Vars)
sat n cs = do
    vars <- sequence (replicate n free)
    mapM_ (assert . clause vars) cs
    query vars

-- The value of a literal.
literal :: Vars -> Integer -> Bool
literal m i =
 if i < 0
    then not (vlookup (negate i) m)
    else vlookup i m

-- The value of a clause
clause :: Vars -> Clause -> Bool
clause m = any (literal m) 

-- print the result in SAT 2011 Competition output form.
putSatResult :: Answer Vars -> IO ()
putSatResult Unknown = putStrLn "s UNKNOWN"
putSatResult Unsatisfiable = putStrLn "s UNSATISFIABLE"
putSatResult (Satisfiable vs) = do
   putStrLn "s SATISFIABLE"
   putStr "v"
   putVars 1 vs

putVars :: Integer -> [Bool] -> IO ()
putVars _ [] = putStrLn " 0"
putVars i (x:xs) = do
    putStr $ " " ++ show (if x then i else negate i)
    putVars (i+1) xs

-- Format is:
--  Zero or more comment lines starting with "c"
--  A single problem line, starting with "p"
--  All the clause lines.
parseDimacs :: String -> Maybe (Integer, [Clause])
parseDimacs = parseLines . lines 

parseLines :: [String] -> Maybe (Integer, [Clause])
parseLines (('c':_):ls) = parseLines ls
parseLines (('p':' ':p):ls) = do
    n <- parseProblem p
    cs <- mapM parseClause ls
    return (n, cs)
parseLines s = Nothing

-- Format is:
-- cnf <nvars> <nclauses>
-- We ignore the number of clauses and just return the number of vars.
parseProblem :: String -> Maybe Integer
parseProblem s =
    case words s of
        [_, nstr, _] -> parseInt nstr
        _ -> Nothing

parseClause :: String -> Maybe Clause
parseClause s = mapM parseInt (init (words s))

parseInt :: String -> Maybe Integer
parseInt ('-':xs) = do
    n <- parseInt' 0 xs
    return (negate n)
parseInt xs = parseInt' 0 xs

parseInt' :: Integer -> String -> Maybe Integer
parseInt' n [] = return n
parseInt' n (d:xs) = do
    v <- parseDigit d
    parseInt' (n*10 + v) xs

parseDigit :: Char -> Maybe Integer
parseDigit '0' = Just 0
parseDigit '1' = Just 1
parseDigit '2' = Just 2
parseDigit '3' = Just 3
parseDigit '4' = Just 4
parseDigit '5' = Just 5
parseDigit '6' = Just 6
parseDigit '7' = Just 7
parseDigit '8' = Just 8
parseDigit '9' = Just 9
parseDigit _ = Nothing
    
sample :: String
sample = unlines [
    "c Example CNF format file",
    "c ",
    "p cnf 4 3",
    "1 3 -4 0",
    "4 0",
    "2 -3 0"]
    
dimacssat :: String -> Query (Answer Vars)
dimacssat s = 
  case parseDimacs s of
     Just (n, cs) -> sat n cs
     Nothing -> return Unknown

main :: IO ()
main = do
    dimacs <- getContents
    putStrLn (show (parseDimacs dimacs))
    r <- runYices1 Nothing (dimacssat dimacs)
    putSatResult r

