
module Data.Array where

import Data.Ix

data Array i e = MkArray (i, i) (i -> e)

-- TODO: check for out of bounds conditions.
array :: Ix i => (i, i) -> [(i, e)] -> Array i e
array b ivs =
  let isidx = \j -> \x -> fst x == j
  in MkArray b (\j -> 
        case filter (isidx j) ivs of
            [(_, v)] -> v
            [] -> error "Array.!: undefined array element"
            _ -> error "Array.!: multiply defined array element"
        )

(!) :: Ix i => Array i e -> i -> e
(!) (MkArray _ f) = f

bounds :: Ix i => Array i e -> (i, i)
bounds (MkArray b _) = b

indices :: Ix i => Array i e -> [i]
indices = range . bounds

assocs :: Ix i => Array i e -> [(i, e)]
assocs a = map (\i -> (i, a!i)) (indices a)

(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
(//) a new_ivs =
  let new_is = map fst new_ivs
      old_ivs = map (\i -> (i, a ! i))
                  (filter (\i -> (notElem i new_is)) (indices a))
  in array (bounds a) (old_ivs ++ new_ivs)

instance (Ix i, Eq e) => Eq (Array i e) where
    (==) a b = (assocs a == assocs b)
    (/=) a b = not (a == b)

