
module Prelude where

-- Return the integer value of a numeric type.
valueof :: #n -> Integer

-- The single possible value for the given numeric type.
numeric :: #n

-- Numeric type identity.
-- Checks dynamically if the two numeric types are the same. If so, acts as
-- the identity function, otherwise returns an error.
ntid :: #n -> #m
ntid n = 
  let m = numeric
  in if valueof n == valueof m
        then m
        else error "ntid: numeric type mismatch"

class Eq a where
   (==) :: a -> a -> Bool
   (/=) :: a -> a -> Bool

-- Default implementation for (/=)
(/=#) :: (Eq a) => a -> a -> Bool
(/=#) a b = not (a == b)

instance (Eq a) => Eq [a] where
   (==) [] [] = True
   (==) (x:xs) (y:ys) = (x == y) && (xs == ys)
   (==) _ _ = False

   (/=) = (/=#)

instance (Eq a, Eq b) => Eq (a, b) where
   (==) a b = (fst a == fst b) && (snd a == snd b)
   (/=) = (/=#)

-- TODO: turn this into an enum class method.
enumFromTo :: Integer -> Integer -> [Integer]
enumFromTo a b =
  if a > b
    then []
    else a : enumFromTo (a+1) b

class Num a where
  (+) :: a -> a -> a
  (*) :: a -> a -> a
  (-) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  fromInteger :: Integer -> a

class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a

sequence :: Monad m => [m a] -> m [a]
sequence [] = return []
sequence (x:xs) = do
    v <- x
    vs <- sequence xs
    return (v:vs)

mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f as = sequence (map f as)

mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f as = mapM f as >>= (\_ -> return ())


id :: a -> a
id x = x

(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

($) :: (a -> b) -> a -> b
($) f x = f x

data Bool = False | True

instance Eq Bool where
    (==) a b = if a then b else not b
    (/=) a b = if a then not b else b

(&&) :: Bool -> Bool -> Bool
(&&) True x = x
(&&) _ _ = False

(||) :: Bool -> Bool -> Bool
(||) True _ = True
(||) _ x = x

not :: Bool -> Bool
not True = False
not _ = True

type String = [Char]

data Maybe a = Nothing | Just a
  deriving (Eq)

instance Monad Maybe where
    fail _ = Nothing
    return = Just
    (>>) a b = a >>= (\_ -> b)
    (>>=) m f = 
        case m of
            Just x -> f x
            Nothing -> Nothing

instance Eq () where
    (==) () () = True
    (/=) = (/=#)

__prim_toInteger_Char :: Char -> Integer

instance Eq Char where
    (==) a b = __prim_toInteger_Char a == __prim_toInteger_Char b
    (/=) = (/=#)

__prim_eq_Integer :: Integer -> Integer -> Bool

instance Eq Integer where
    (==) = __prim_eq_Integer
    (/=) = (/=#)

__prim_add_Integer :: Integer -> Integer -> Integer
__prim_sub_Integer :: Integer -> Integer -> Integer
__prim_mul_Integer :: Integer -> Integer -> Integer

instance Num Integer where
  (+) = __prim_add_Integer
  (-) = __prim_sub_Integer
  (*) = __prim_mul_Integer
  negate x = 0 - x
  abs x = if x < 0 then negate x else x
  fromInteger x = x

class Ord a where
    (<) :: a -> a -> Bool
    (>) :: a -> a -> Bool
    (<=) :: a -> a -> Bool
    (>=) :: a -> a -> Bool

__prim_lt_Integer :: Integer -> Integer -> Bool
__prim_gt_Integer :: Integer -> Integer -> Bool
__prim_leq_Integer :: Integer -> Integer -> Bool
__prim_geq_Integer :: Integer -> Integer -> Bool

instance Ord Integer where
    (<) = __prim_lt_Integer
    (>) = __prim_gt_Integer
    (<=) = __prim_leq_Integer
    (>=) = __prim_geq_Integer

fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y

-- Note: curry is used in syntactic sugar for multi arg pattern matching, so
-- we can't use that in its implementation.
curry :: ((a, b) -> c) -> a -> b -> c
curry = \f -> \a -> \b -> f (a, b)

error :: String -> a

undefined :: a
undefined = error "Prelude.undefined"

-- Standard list functions

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

(++) :: [a] -> [a] -> [a]
(++) [] x = x
(++) (x:xs) ys = x : (xs ++ ys)

filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs) =
  if p x
    then (x : filter p xs)
    else filter p xs

concat :: [[a]] -> [a]
concat xss = foldr (++) [] xss

concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f = concat . map f

head :: [a] -> a
head (x:_) = x
head [] = error "Prelude.head: empty list"

tail :: [a] -> [a]
tail (_:xs) = xs
tail [] = error "Prelude.tail: empty list"

init :: [a] -> [a]
init [x] = []
init (x:xs) = x : init xs
init [] = error "Prelude.init: empty list"

null :: [a] -> Bool
null [] = True
null _ = False

length :: [a] -> Integer
length [] = 0
length (_:l) = 1 + length l

(!!) :: [a] -> Integer -> a
(!!) [] _ = error "Prelude.!!: index too large"
(!!) (x:_) 0 = x
(!!) (_:xs) n = xs !! (n-1)

foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f z (x:xs) = foldl f (f z x) xs
foldl f z _ = z

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z (x:xs) = f x (foldr f z xs)
foldr f z _ = z

replicate :: Integer -> a -> [a]
replicate 0 _ = []
replicate n x = x : (replicate (n-1) x)

take :: Integer -> [a] -> [a]
take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n-1) xs

drop :: Integer -> [a] -> [a]
drop 0 xs = xs
drop _ [] = []
drop n (_:xs) = drop (n-1) xs

splitAt :: Integer -> [a] -> ([a],[a])
splitAt n xs = (take n xs, drop n xs)

dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile p [] = []
dropWhile p (x:xs) =
  if p x 
     then dropWhile p xs
     else x:xs

span :: (a -> Bool) -> [a] -> ([a], [a])
span p [] = ([], [])
span p (x:xs) =
  if p x
    then let (ys, zs) = span p xs
         in (x:ys, zs)
    else ([], x:xs)

break :: (a -> Bool) -> [a] -> ([a], [a])
break p = span (not . p)

isSpace :: Char -> Bool
isSpace ' ' = True
isSpace '\n' = True
isSpace _ = False

lines :: String -> [String]
lines [] = []
lines s =
  let (l, s') = break ((==) '\n') s
  in l : (case s' of
            [] -> []
            (_:s'') -> lines s''
         )

words :: String -> [String]
words s =
  case dropWhile isSpace s of
    [] -> []
    s' -> let (w, s'') = break isSpace s'
          in w : words s''

unlines :: [String] -> String
unlines = concatMap (flip (++) "\n")

reverse :: [a] -> [a]
reverse =  foldl (flip (:)) []

and :: [Bool] -> Bool
and = foldr (&&) True

or :: [Bool] -> Bool
or = foldr (||) False

any :: (a -> Bool) -> [a] -> Bool
any p = or . map p

all :: (a -> Bool) -> [a] -> Bool
all p = and . map p

elem :: (Eq a) => a -> [a] -> Bool
elem x = any (\v -> v == x)

notElem :: (Eq a) => a -> [a] -> Bool
notElem x = all (\v -> v /= x)

class Show a where
    show :: a -> String

__prim_show_Integer :: Integer -> String

instance Show Integer where
    show = __prim_show_Integer

instance Show Char where
    show c = ['\'', c, '\'']

instance Show Bool where
    show True = "True"
    show False = "False"

instance Show () where
    show () = "()"

instance (Show a, Show b) => Show (a, b) where
    show (x, y) = concat ["(", show x, ", ", show y, ")"]

instance (Show a, Show b, Show c) => Show (a, b, c) where
    show (x, y, z) = concat ["(", show x, ", ", show y, ", ", show z, ")"]

instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d) where
    show (a, b, c, d)
      = concat ["(", show a, ", ", show b, ", ", show c, ", ", show d, ")"]

instance (Show a) => Show [a] where
    show xs = concat ["[", showListHelper xs, "]"]

instance (Show a) => Show (Maybe a) where
    show Nothing = "Nothing"
    show (Just x) = "Just " ++ show x

-- Show a list without the open and close brackets
showListHelper :: (Show a) => [a] -> String
showListHelper [] = "" 
showListHelper [x] = show x
showListHelper (x:xs) = concat [show x, ", ", showListHelper xs]

-- Primitive IO monad
data IO a = 

-- The IO monad primitives
return_io :: a -> IO a
nobind_io :: IO a -> IO b -> IO b
bind_io :: IO a -> (a -> IO b) -> IO b
fail_io :: String -> IO a

instance Monad IO where
  return = return_io
  (>>=) = bind_io
  (>>) = nobind_io
  fail = fail_io

-- Print a character to stdou.
putChar :: Char -> IO ()

-- Print a string to stdout.
putStr :: String -> IO ()
putStr = mapM_ putChar

-- Print a line to stdout.
putStrLn :: String -> IO ()
putStrLn str = do
  putStr str
  putStr "\n"

-- Read the contents of stdin.
getContents :: IO String

type FilePath = String

