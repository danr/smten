
module Prelude where

-- Return the integer value of a numeric type.
valueof :: #n -> Integer

-- The single possible value for the given numeric type.
numeric :: #n

-- Numeric type identity.
-- Checks dynamically if the two numeric types are the same. If so, acts as
-- the identity function, otherwise returns an error.
ntid :: #n -> #m
ntid n = 
  let m = numeric
  in if valueof n == valueof m
        then m
        else error "ntid: numeric type mismatch"

class Eq a where
   (==) :: a -> a -> Bool
   (/=) :: a -> a -> Bool

-- Default implementation for (/=)
(/=#) :: (Eq a) => a -> a -> Bool
(/=#) a b = not (a == b)

instance (Eq a) => Eq [a] where
   (==) [] [] = True
   (==) (x:xs) (y:ys) = (x == y) && (xs == ys)
   (==) _ _ = False

   (/=) = (/=#)

instance (Eq a, Eq b) => Eq (a, b) where
   (==) a b = (fst a == fst b) && (snd a == snd b)
   (/=) = (/=#)

class Num a where
  (+) :: a -> a -> a
  (*) :: a -> a -> a
  (-) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  fromInteger :: Integer -> a

class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: [Char] -> m a

sequence :: Monad m => [m a] -> m [a]
sequence [] = return []
sequence (x:xs) = do
    v <- x
    vs <- sequence xs
    return (v:vs)

mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f as = sequence (map f as)

mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
mapM_ f as = mapM f as >>= (\_ -> return ())


id :: a -> a
id x = x

(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g = \x -> f (g x)

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

($) :: (a -> b) -> a -> b
($) f x = f x

data Bool = False | True
  deriving (Eq)

-- && as a primitive
(&&) :: Bool -> Bool -> Bool

-- && as not a primitive
(&&#) :: Bool -> Bool -> Bool
(&&#) True x = x
(&&#) False _ = False

(||) :: Bool -> Bool -> Bool

(||#) :: Bool -> Bool -> Bool
(||#) True _ = True
(||#) False x = x

not :: Bool -> Bool

not_ :: Bool -> Bool
not_ True = False
not_ False = True

data Maybe a = Nothing | Just a
  deriving (Eq)

instance Monad Maybe where
    fail _ = Nothing
    return = Just
    (>>) a b = a >>= (\_ -> b)
    (>>=) m f = 
        case m of
            Just x -> f x
            Nothing -> Nothing

instance Eq () where
    (==) () () = True
    (/=) = (/=#)

__prim_eq_Char :: Char -> Char -> Bool

instance Eq Char where
    (==) = __prim_eq_Char
    (/=) = (/=#)

__prim_eq_Integer :: Integer -> Integer -> Bool

instance Eq Integer where
    (==) = __prim_eq_Integer
    (/=) = (/=#)

__prim_add_Integer :: Integer -> Integer -> Integer
__prim_sub_Integer :: Integer -> Integer -> Integer
__prim_mul_Integer :: Integer -> Integer -> Integer

instance Num Integer where
  (+) = __prim_add_Integer
  (-) = __prim_sub_Integer
  (*) = __prim_mul_Integer
  negate x = 0 - x
  abs x = if x < 0 then negate x else x
  fromInteger x = x

(<) :: Integer -> Integer -> Bool
(>) :: Integer -> Integer -> Bool

(<=) :: Integer -> Integer -> Bool
--(<=) a b = (a == b) || (a < b)

(>=) :: Integer -> Integer -> Bool
(>=) a b = (a == b) || (a > b)

fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y

error :: [Char] -> a

undefined :: a
undefined = error "Prelude.undefined"

-- Standard list functions

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

(++) :: [a] -> [a] -> [a]
(++) [] x = x
(++) (x:xs) ys = x : (xs ++ ys)

filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs) =
  if p x
    then (x : filter p xs)
    else filter p xs

concat :: [[a]] -> [a]
concat xss = foldr (++) [] xss

head :: [a] -> a
head (x:_) = x
head [] = error "Prelude.head: empty list"

tail :: [a] -> [a]
tail (_:xs) = xs
tail [] = error "Prelude.tail: empty list"

null :: [a] -> Bool
null [] = True
null (_:_) = False

length :: [a] -> Integer
length [] = 0
length (_:l) = 1 + length l

(!!) :: [a] -> Integer -> a
(!!) [] _ = error "Prelude.!!: index too large"
(!!) (x:[]) 0 = x
(!!) (_:xs) n = xs !! (n-1)

foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z [] = z
foldr f z (x:xs) = f x (foldr f z xs)

replicate :: Integer -> a -> [a]
replicate 0 _ = []
replicate n x = x : (replicate (n-1) x)

take :: Integer -> [a] -> [a]
take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n-1) xs

drop :: Integer -> [a] -> [a]
drop 0 xs = xs
drop _ [] = []
drop n (_:xs) = drop (n-1) xs

splitAt :: Integer -> [a] -> ([a],[a])
splitAt n xs = (take n xs, drop n xs)

reverse :: [a] -> [a]
reverse =  foldl (flip (:)) []

and :: [Bool] -> Bool
and = foldr (&&) True

or :: [Bool] -> Bool
or = foldr (||) False

any :: (a -> Bool) -> [a] -> Bool
any p = or . map p

all :: (a -> Bool) -> [a] -> Bool
all p = and . map p

elem :: (Eq a) => a -> [a] -> Bool
elem x = any (\v -> v == x)

notElem :: (Eq a) => a -> [a] -> Bool
notElem x = all (\v -> v /= x)

class Show a where
    show :: a -> [Char]

__prim_show_Integer :: Integer -> [Char]

instance Show Integer where
    show = __prim_show_Integer

instance Show Bool where
    show True = "True"
    show False = "False"

instance Show () where
    show () = "()"

instance (Show a, Show b) => Show (a, b) where
    show (x, y) = concat ["(", show x, ", ", show y, ")"]

instance (Show a, Show b, Show c) => Show (a, b, c) where
    show (x, y, z) = concat ["(", show x, ", ", show y, ", ", show z, ")"]

instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d) where
    show (a, b, c, d)
      = concat ["(", show a, ", ", show b, ", ", show c, ", ", show d, ")"]

instance (Show a) => Show [a] where
    show xs = concat ["[", showListHelper xs, "]"]

-- Show a list without the open and close brackets
showListHelper :: (Show a) => [a] -> [Char]
showListHelper [] = "" 
showListHelper [x] = show x
showListHelper (x:xs) = concat [show x, ", ", showListHelper xs]

