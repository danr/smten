
module Seri.Bit where

import Prelude

data Bit #n =

__prim_eq_Bit :: Bit #n -> Bit #n -> Bool
__prim_lt_Bit :: Bit #n -> Bit #n -> Bool
__prim_leq_Bit :: Bit #n -> Bit #n -> Bool
__prim_gt_Bit :: Bit #n -> Bit #n -> Bool
__prim_geq_Bit :: Bit #n -> Bit #n -> Bool
__prim_add_Bit :: Bit #n -> Bit #n -> Bit #n
__prim_sub_Bit :: Bit #n -> Bit #n -> Bit #n
__prim_mul_Bit :: Bit #n -> Bit #n -> Bit #n
__prim_show_Bit :: Bit #n -> String
__prim_fromInteger_Bit :: Integer -> Bit #n
__prim_toInteger_Bit :: Bit #n -> Integer
__prim_zeroExtend_Bit :: Bit #n -> Bit #m
__prim_or_Bit :: Bit #n -> Bit #n -> Bit #n
__prim_and_Bit :: Bit #n -> Bit #n -> Bit #n
__prim_shl_Bit :: Bit #n -> Bit #n -> Bit #n
__prim_lshr_Bit :: Bit #n -> Bit #n -> Bit #n
__prim_not_Bit :: Bit #n -> Bit #n
__prim_truncate_Bit :: Bit #n -> Bit #m
__prim_extract_Bit :: Bit #n -> Integer -> Bit #m
__prim_concat_Bit :: Bit #n -> Bit #m -> Bit #(n+m)


instance Eq (Bit #n) where
    (==) = __prim_eq_Bit
    (/=) a b = not (a == b)

instance Ord (Bit #n) where
    (<) = __prim_lt_Bit
    (>) = __prim_gt_Bit
    (<=) = __prim_leq_Bit
    (>=) = __prim_geq_Bit
    compare x y =
      if (x == y)
        then EQ
        else if (x <= y)
                then LT
                else GT

instance Show (Bit #n) where
    show = __prim_show_Bit

instance Num (Bit #n) where
   (+) = __prim_add_Bit
   (-) = __prim_sub_Bit
   (*) = __prim_mul_Bit
   negate = error "todo: negate for Bit #n"
   abs = error "todo: abs for Bit #n"
   fromInteger = __prim_fromInteger_Bit

bv_ntype :: Bit #n -> #n
bv_ntype _ = numeric

bv_sizeof :: Bit #n -> Integer
bv_sizeof x = valueof (bv_ntype x)

bv_shl :: Bit #n -> Bit #n -> Bit #n
bv_shl = __prim_shl_Bit

bv_lshr :: Bit #n -> Bit #n -> Bit #n
bv_lshr = __prim_lshr_Bit

bv_or :: Bit #n -> Bit #n -> Bit #n
bv_or = __prim_or_Bit

bv_and :: Bit #n -> Bit #n -> Bit #n
bv_and = __prim_and_Bit

bv_not :: Bit #n -> Bit #n 
bv_not = __prim_not_Bit

bv_zero_extend :: Bit #n -> Bit #m
bv_zero_extend = __prim_zeroExtend_Bit

bv_truncate :: Bit #n -> Bit #m
bv_truncate = __prim_truncate_Bit

bv_concat :: Bit #n -> Bit #m -> Bit #(n+m)
bv_concat = __prim_concat_Bit

-- Extract m bits from the given vector, with the least significant bit to be
-- extract specified in the argument. The most significant bit is inferred.
bv_extract :: Bit #n -> Integer -> Bit #m
bv_extract = __prim_extract_Bit

