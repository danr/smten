
-- | Implementation of a DIMACS cnf SAT solver in seri.
module Seri.SATLIB.SAT where

import Prelude
import Seri.SMT.SMT

type Clause = [Integer]

-- Mapping from Integer to boolean value.
type Vars = [Bool]

vlookup :: Integer -> Vars -> Bool
vlookup i l = l !! (i - 1)

sat :: Integer -> [Clause] -> Query (Answer Vars)
sat n cs = do
    vars <- sequence (replicate n free)
    mapM_ (assert . clause vars) cs
    query vars

-- The value of a literal.
literal :: Vars -> Integer -> Bool
literal m i =
 if i < 0
    then not (vlookup (negate i) m)
    else vlookup i m

-- The value of a clause
clause :: Vars -> Clause -> Bool
clause m = any (literal m) 


-- A small sample
sampleN :: Integer
sampleN = 4

sampleC :: [Clause]
sampleC = [
    [1, 3, negate 4],
    [4],
    [2, negate 3]]

main :: IO ()
main = do
    r <- runYices2 (Just "sat.y2.dbg") (sat sampleN sampleC)
    putStrLn $ show r

