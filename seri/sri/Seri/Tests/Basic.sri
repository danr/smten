
-- vim: ft=haskell
module Seri.Tests.Basic where

import Seri.Tests.Test

import Debug.Trace

import Data.Array
import Data.Char
import Data.List
import Seri.Vector
import Seri.Bit
import Seri.Bit -- test duplicate import

------ This is a comment with lots of dashes

foo1 :: Integer
foo1 = (\x -> x*x + 3*x + 2) 5

foo2 :: Integer -> Integer
foo2 x = x*x + 3*x + 2

rfact :: Integer -> Integer
rfact x = if (x < 1) then 1 else x * rfact (x-1)

data MaybeInteger = NoInteger | JustInteger Integer
    deriving (Show)

fromMaybeInteger :: Integer -> MaybeInteger -> Integer
fromMaybeInteger def = \mi ->
    case mi of
        JustInteger i -> i
        NoInteger -> def

fromMaybeBool :: Bool -> Maybe Bool -> Bool
fromMaybeBool def = \mb ->
    case mb of
        Just b -> b
        Nothing -> def

multiclause :: Integer -> Integer
multiclause 2 = 10
multiclause 3 = 20
multiclause 4 = 30
multiclause 5 = 40
multiclause _ = 50

tupleswap :: (a, b) -> (b, a)
tupleswap (x, y) = (y, x)

listswaptop :: [a] -> [a]
listswaptop (x:xs) = (head xs) : (x : (tail xs))

listdifftop :: [Integer] -> Integer
listdifftop (x:y:_) = x - y

sum2 :: Integer -> Integer -> Integer
sum2 a b = a + b

sum3 :: Integer -> Integer -> Integer -> Integer
sum3 a b c = (a + b) + c

unary2int :: [()] -> Integer
unary2int [] = 0
unary2int (_:xs) = 1 + unary2int xs

class Foo a where
    foo :: a -> Integer

instance Foo Bool where
    foo _ = 1

instance Foo Integer where
    foo _ = 2

foofun :: (Foo a) => a -> Integer
foofun x = foo x * foo x + 3*(foo x) + foo True

class (Foo a) => FooBar a where
    bar :: a -> a -> Integer

instance FooBar Bool where
    bar a b = foo a + foo b

instance FooBar Integer where
    bar a b = foo a - foo b

foobarfun :: (FooBar a) => a -> Integer
foobarfun x = foo x + bar x x 

data Apple = Apple {
    isgreen :: Bool,
    numseeds :: Integer
}

data Wonderful a = Wonderful {
    thething :: a,
    howgreat :: Integer
}

thegreatthing :: Wonderful Integer -> Integer
thegreatthing w = thething w + howgreat w

-- record type construction with no fields
data EmptyRecord = EmptyRecord {}

class MultiFoo a b where
    multifoo :: a -> b -> Integer

instance MultiFoo Bool Bool where
    multifoo _ _ = 1

instance MultiFoo Integer Integer where
    multifoo _ _ = 2

instance MultiFoo Bool Integer where
    multifoo _ _ = 3

instance MultiFoo Integer Bool where
    multifoo _ _ = 4

unused :: a -> Integer
unused x = 42

multifoofun :: (MultiFoo a b) => a -> b -> Integer
multifoofun x y = (((multifoo x y) * (multifoo x y))
                    + (3 * (multifoo x y))) + (multifoo True False)

-- shadow x = 2*(x+1)
shadow :: Integer -> Integer
shadow = \x -> (\x -> 2*x) (x+1)

caseshadow :: Integer -> Integer
caseshadow = \x -> (case 2*x of { x -> x; })

thedo :: Maybe Bool -> Maybe Integer
thedo m = do
    b <- m
    if b then return 5 else Nothing

notand :: Bool
notand = True && False

testlet :: Integer
testlet = 
  let fudge = 1 + 2
      bar = fudge + 3
  in bar + bar

arr :: Array Integer Integer
arr = array (0, 2) [(0, 42), (1, 12), (2, 19)]

testarray :: IO ()
testarray = do
    test "arrsub0" (42 == (arr ! 0))
    test "arrsub1" (12 == (arr ! 1))
    test "arrsub2" (19 == (arr ! 2))
    test "arrupd" (23 == ((arr // [(1, 23)]) ! 1))

v4 :: Vector #4 Bool
v4 = vreplicate True

v2x4 :: Vector #2 (Vector #4 Bool)
v2x4 = vreplicate v4

testvector :: IO ()
testvector = do
    test "vecreplen" (4 == vlength v4)
    test "vecconcat" (8 == vlength (vconcat v2x4))

bit3 :: Integer -> Bit #3
bit3 = fromInteger

bit5 :: Integer -> Bit #5
bit5 = fromInteger

testbit :: IO ()
testbit = do
    test "bit simple" (bit3 0 == ((bit3 7) + 1))
    test "bit zeroext" (bit5 7 == bv_zero_extend (bit3 (0-1)))
    test "bit or" (bit5 0x1E == bv_or (bit5 0x12) (bit5 0x0C))
    test "bit shl" (bit5 10 == bv_shl (bit5 5) (bit5 1))
    test "bit extract" (bit3 3 == bv_extract (bit5 7) 1)
    test "bit not" (bit5 0x15 == bv_not (0x0A))
    test "toInteger" (__prim_toInteger_Bit (bit5 0x15) == 0x15)

shadowmeth :: Integer
shadowmeth = let { foo = 3; } in foo

parsenotctx :: (Maybe Integer -> Bool) -> Bool
parsenotctx = undefined

patternlet :: Integer
patternlet = 
  let (a, b) = (1, 5)
  in a + b

data DerivedEq a = DEq1 a | DEq2 a a
    deriving (Eq)

testbasic :: IO ()
testbasic = do
    test "a" ((42 :: Integer) == (\x -> (((x*x) + (3*x)) + 2)) 5)
    test "b" (42 == (foo1))
    test "c" (42 == (foo2 5))
    test "d" (True)
    test "e" ((23 :: Integer) == (if 6 < (4 :: Integer) then 42 else 23 ))
    test "f" ((5 :: Integer) == ((id id) 5))
    test "g" (5 == (fromMaybeInteger 10 (JustInteger 5)))
    test "h" (10 == (fromMaybeInteger 10 NoInteger))
    test "i" (fromMaybeBool False (Just True))
    test "j" (Just (18 :: Integer) == Just 18)
    test "k" (Just (18 :: Integer) /= Just 16)
    test "l" (Just (18 :: Integer) /= Nothing)
    test "m" ((30 :: Integer) == (case ((1+3) :: Integer) of
                                       2 -> 10
                                       3 -> 20
                                       4 -> 30
                                       5 -> 40
                                       _ -> 50
                                 ))
    test "n" (30 == (multiclause 4))
    test "o" (30 == (snd (tupleswap (30 :: Integer, 40 :: Integer))))
    test "p" ((20 :: Integer) == (listdifftop (listswaptop [10, 30, 50, 0])))
    test "q" (12 == (sum2 5 7))
    test "r" (20 == (sum3 5 7 8))
    test "s" (3 == (unary2int [(), (), ()]))
    test "t" (1 == (foo True))
    test "u" (2 == (foo (42 :: Integer)))
    test "v" (5 == (foofun False))
    test "w" (11 == (foofun (5 :: Integer)))
    test "x" (11 == (numseeds (Apple True 11)))
    test "y" (11 == (numseeds (Apple { numseeds = 11 })))
    test "z" (8 == (numseeds ((Apple True 11) { numseeds = 8 })))
    test "A" ((11 :: Integer) == (thething (Wonderful 11 32)))
    test "B" (42 == (unused True))
    test "C" (19 == (multifoofun True (12 :: Integer)))
    test "D" (8 == (shadow 3))
    test "E" (6 == (caseshadow 3))
    test "F" (12 == testlet)
    test "G" (3 == shadowmeth)
    test "H" (3 == (length [1 :: Integer, 5, 2]))
    test "I" (and [True, True, True])
    test "J" ('A' == 'A')
    test "K" ('A' /= 'B')
    test "L" (6 == patternlet)
    test "M" (DEq2 (5 :: Integer) 9 == DEq2 5 9)
    test "N" (DEq1 (5 :: Integer) /= DEq2 5 9)
    test "P" (length "foo\n" == 4)
    test "hex literal" (0x18 == (24 :: Integer))
    test "HEX literal" (0X18 == (24 :: Integer))
    test "or lazy" (True || (error "or is not lazy"))
    test "and lazy" (not (False && (error "and is not lazy")))
    test "precedence" (1*2+3-4*5+6-7 == negate (16 :: Integer))
    testaspattern
    testarithsequence
    teststringliteralpattern
    testletclause
    testbitpattern
    testlistcomprehension
    testdopattern
    testlambda
    testvarop
    testpatternguard
    testpatsig
    testtypesyn
    testwhereclause
    testclassctx
    testsaderiving

data SDerivedEq a = SDEq1 a | SDEq2 a a
deriving instance (Eq a) => Eq (SDerivedEq a)

testsaderiving :: IO ()
testsaderiving = do
    test "saderive1" (SDEq2 (5 :: Integer) 9 == SDEq2 5 9)
    test "saderive2" (SDEq1 (5 :: Integer) /= SDEq2 5 9)

testclassctx :: IO ()
testclassctx = do
    test "class ctx" (foobarfun True == 3)

type AMultiArgSynonym a = (a, a)

fsyn :: AMultiArgSynonym Integer -> Integer
fsyn (a, b) = a + b

testtypesyn :: IO ()
testtypesyn = do
    test "type syn" (fsyn (1, 2) == 3)

patsigf :: Integer -> Integer
patsigf = \(x :: Integer) -> x + 3

testpatsig :: IO ()
testpatsig = do
    test "pat sig" (patsigf 4 == 7)


fpatgd :: (Integer, Integer) -> Integer
fpatgd p = case p of
             (x, _) | x == 1 -> 0
                    | x > 3 -> 1
             _ | (x, y) <- p, y == 2 -> x
             _ -> 3

fpatgd2 :: (Integer, Integer) -> Integer
fpatgd2 (x, _)
  | x == 1 = 0
  | x > 3 = 1
fpatgd2 p
  | (x, y) <- p, y == 2 = x
fpatgd2 _ = 3

testpatternguard :: IO ()
testpatterngaurd = do
    test "case pattern guard" ([0, 1, 2, 3] == map fpatgd [(1, 4), (4, 3), (2, 2), (3, 7)])
    test "function pattern guard" ([0, 1, 2, 3] == map fpatgd2 [(1, 4), (4, 3), (2, 2), (3, 7)])

testvarop :: IO ()
testvarop = do
    test "var op" (4 `elem` [1, 4, 2 :: Integer])

testlambda :: IO ()
testlambda = do
    test "simple lambda" ((\a -> a || False) True)
    test "patmatch lambda" ((\(_, a) -> a) (False, True))
    test "multi lambda" ((\a b -> a || b) False True)

testdopattern :: IO ()
testdopattern = do
    Just b <- return (Just True)
    test "do pattern" b

testbitpattern :: IO ()
testbitpattern = do
    test "bit pattern" (
        case bit3 3 of
            3 -> True
            _ -> False
      )

testaspattern :: IO ()
testaspattern = do
    test "as pattern" (
        case [1, 2, 3 :: Integer] of
          v@(x:xs) -> (length v + x + length xs) == 6
          _ -> False
      )

wheref :: Integer -> Integer -> Integer
wheref x y = 1 + z
  where z = x + y 

testwhereclause :: IO ()
testwhereclause = do
    test "where clause f" (wheref 1 2 == 4)
    test "where clause c" (
        case Just True of
            Just v | False <- nv -> True   
               where nv = not v
            _ -> False
      )

testletclause :: IO ()
testletclause = do
    test "let clause" (
        let foo (a, True) = a
            foo (a, False) = not a
        in foo (False, False)
     )
    test "let clause2" (
        let foo a True = a
            foo a False = not a
        in foo False False
     )

testarithsequence :: IO ()
testarithsequence = do
    test "fromto" ([1..5] == [1,2,3,4,5 :: Integer])
    test "from" (take 4 [1..] == [1, 2, 3, 4 :: Integer])
    test "fromthento" ([1, 3 .. 9] == [1,3,5,7,9 :: Integer])
    test "fromthen" (take 4 [1, 3 ..] == [1,3,5,7 :: Integer])

testlistcomprehension :: IO ()
testlistcomprehension = do
    test "lcomp" (
      let l = [a | (a, _) <- [(1, 2), (3, 4), (5 :: Integer, 6 :: Integer)]]
      in [1, 3, 5] == l
     )

teststringliteralpattern :: IO ()
teststringliteralpattern = do
    test "stringliteralpattern" (
        case "foo" of
          "bar" -> False
          "foo" -> True
      )

testprelude :: IO ()
testprelude = do
   test "p.take" ([8 :: Integer, 3] == take 2 [8, 3, 5, 1])
   test "p.drop" ([5 :: Integer, 1] == drop 2 [8, 3, 5, 1])
   test "p.splitAt" (([8 :: Integer, 3], [5, 1]) == splitAt 2 [8, 3, 5, 1])
   test "p.concat" ([8 :: Integer, 3, 5, 1, 2, 5] == concat [[8, 3], [5], [1, 2, 5]])
   test "p.bang1" (([7 :: Integer, 2, 5, 3, 1] !! 0) == 7)
   test "p.bang2" (([7 :: Integer, 2, 5, 3, 1] !! 2) == 5)

testnumeric :: IO ()
testnumeric = do
   test "n.3" ((3 :: Integer) == (valueof (numeric :: #3)))

testlist :: IO ()
testlist = do
   test "tails" (tails "abc" == ["abc", "bc", "c", ""])
   test "isPrefixOf" (isPrefixOf "foo" "foosball")
   test "not isPrefixOf" (not $ isPrefixOf "fish" "foosball")
   test "isInfixOf" (isInfixOf "oba" "foobar")
   test "not isInfixOf" (not $ isInfixOf "abo" "foobar")
   test "nub" (nub "abaabccabdabeaabc" == "abcde")

testchar :: IO ()
testchar = do
   test "char.lt" ('a' < 'z')
   test "char.ord" (ord 'a' == 97)
   test "char.chr" (chr 98 == 'b')

testtrace :: IO ()
testtrace = do
   test "trace" (trace "tracehi!" True)

testbasics :: IO ()
testbasics = do
    testbasic
    testprelude
    testnumeric
    testarray
    testvector
    testbit
    testlist
    testchar
    testtrace

