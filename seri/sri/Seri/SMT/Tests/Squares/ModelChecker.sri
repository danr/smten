
module Seri.SMT.Tests.Squares.ModelChecker where {

import Prelude;
import Seri.SMT.SMT;
import Seri.SMT.Tests.Squares.Prelude;

data Model s = Model { 
  rules :: [([Char], (s -> (Bool, s)))],
  initial :: (s -> Bool),
  target :: (s -> Bool)
}; 

-- Perform model checking.
--   length - maximum length of sequence to fine.
-- Finds a sequence of rules within the given length from an initial state to
-- final state if one exists. Returns the initial state, final state, and rule
-- sequence.
check :: (Eq s) => Model s -> Integer -> Query (Answer (s, s, [[Char]]));
check m d = queryS $ do {
  s0 <- free;
  assert (initial m s0);
  targetS <- queryS $ do {
    assert (target m s0);
    query s0;
  };
  case targetS of {
    Satisfiable sx -> return (Satisfiable (sx, sx, []));
    Unsatisfiable -> do {
      r <- checklist m d s0 [] s0 (rules m);
      case r of { 
        Satisfiable (a, b, rs) -> return (Satisfiable (a, b, reverse rs));
        _ -> return r;
      };
    };
  };
};

checklist :: (Eq s) => Model s -> Integer
             -> s -> [[Char]]
             -> s -> [([Char], (s -> (Bool, s)))]
             -> Query (Answer (s, s, [[Char]]));
checklist _ 0 _ _ _ _ = return Unsatisfiable;
checklist _ _ _ _ _ [] = return Unsatisfiable;
checklist m d s0 rs sx (rc:rcs) = do {
  v <- checkone m d s0 rs sx rc;
  case v of {
    Satisfiable x -> return (Satisfiable x);
    Unsatisfiable -> checklist m d s0 rs sx rcs;
  };
};

checkone :: (Eq s) => Model s       -- model being checked
          -> Integer    -- depth of sequence to use
          -> s          -- initial (abstract) state
          -> [[Char]]   -- list of rules executed so far in reverse order
          -> s          -- previous (abstract) state
          -> ([Char], (s -> (Bool, s))) -- next rule to try executing
          -> Query (Answer (s, s, [[Char]]));
checkone model depth s0 rs sx (nm, r) = queryS $ do {
  g <- free;
  s <- free;
  assert ((g, s) == r sx);
  assert (g && not (initial model s));
  anyS <- query ();
  case anyS of {
    Unsatisfiable -> return Unsatisfiable;
    Satisfiable () -> do {
      targetS <- queryS $ do {
        assert (target model s);
        query (s0, s);
      };
      case targetS of {
        Satisfiable (sv0, svt) -> return (Satisfiable (sv0, svt, nm:rs));
        Unsatisfiable -> checklist model (depth-1) s0 (nm:rs) s (rules model);
      };
    };
  };
};


}

