
module Seri.SMT.Tests.Squares.Squares where {

import Prelude;
import Seri.Bit;
import Seri.SMT.SMT;

import Seri.SMT.Tests.Squares.Prelude;
import Seri.SMT.Tests.Squares.Reg;
import Seri.SMT.Tests.Squares.FIFO2;
import Seri.SMT.Tests.Squares.ModelChecker;

-- Lambda Calculus description for the following bluespec module.
-- Generates the sequence of squares: 1, 4, 9, 16, ...
-- module mkSquares
--   Reg#(Bit#(32)) odds <- mkReg(1)
--   Reg#(Bit#(32)) squares <- mkReg(0)
-- 
--   FIFO#(Bit#(32)) pipeQ <- mkFIFO()
-- 
--   rule produce
--     pipeQ.enq(odds)
--     odds <= odds + 2
-- 
--   rule consume
--     squares <= pipeQ.first() + squares
--     pipeQ.deq()

data MOD_mkSquares = MOD_mkSquares {
  inst_odds :: MOD_mkReg (Bit #32),
  inst_squares :: MOD_mkReg (Bit #32),
  inst_pipeQ :: MOD_mkFIFO (Bit #32)
} deriving (Eq);

instance State MOD_mkSquares where {
  newState (MOD_mkSquares odds1 squares1 pipeQ1)
    = let {
        odds = newState odds1;
        squares = newState squares1;
        pipeQ = newState pipeQ1;
      } in MOD_mkSquares odds squares pipeQ;

  parMerge (MOD_mkSquares odds1 squares1 pipeQ1) (MOD_mkSquares odds2 squares2 pipeQ2)
    = let {
        (g1, odds) = parMerge odds1 odds2;
        (g2, squares) = parMerge squares1 squares2;
        (g3, pipeQ) = parMerge pipeQ1 pipeQ2;
      } in (g1 && (g2 && g3), MOD_mkSquares odds squares pipeQ);

  seqMerge (MOD_mkSquares odds1 squares1 pipeQ1) (MOD_mkSquares odds2 squares2 pipeQ2)
    = let {
        odds = seqMerge odds1 odds2;
        squares = seqMerge squares1 squares2;
        pipeQ = seqMerge pipeQ1 pipeQ2;
      } in MOD_mkSquares odds squares pipeQ;
};

ctor_mkSquares :: MOD_mkSquares;
ctor_mkSquares =
  MOD_mkSquares {
    inst_odds = ctor_mkReg 1,
    inst_squares = ctor_mkReg 0,
    inst_pipeQ = ctor_mkFIFO
  };

rule_RL_produce_mkSquares :: MOD_mkSquares -> (Bool, MOD_mkSquares);
rule_RL_produce_mkSquares =
  \s0 ->
     let {
       (g1, s1_odds, v1) = meth_read_mkReg (inst_odds s0);
       s1 = s0 { inst_odds = s1_odds};
       (g2, s2_pipeQ) = meth_enq_mkFIFO (inst_pipeQ s1) v1;
       s2 = s1 { inst_pipeQ = s2_pipeQ };
       (g3, s3_odds) = meth_write_mkReg (inst_odds s2) (v1 + 2);
       s3 = s2 { inst_odds = s3_odds };
     } in (and [g1, g2, g3], s3);

rule_RL_consume_mkSquares :: MOD_mkSquares -> (Bool, MOD_mkSquares);
rule_RL_consume_mkSquares =
  \s0 ->
     let {
       (g1, s1_pipeQ, v1) = meth_first_mkFIFO (inst_pipeQ s0);
       s1 = s0 { inst_pipeQ = s1_pipeQ};
       (g2, s2_squares, v2) = meth_read_mkReg (inst_squares s1);
       s2 = s1 { inst_squares = s2_squares };
       (g3, s3_squares) = meth_write_mkReg (inst_squares s2) (v1 + v2);
       s3 = s2 { inst_squares = s3_squares };
       (g4, s4_pipeQ) = meth_deq_mkFIFO (inst_pipeQ s3);
       s4 = s3 { inst_pipeQ = s4_pipeQ };
     } in (and [g1, g2, g3, g4], s4);

-- Some rule sequences.
p :: MOD_mkSquares -> (Bool, MOD_mkSquares);
p = rule_RL_produce_mkSquares;

c :: MOD_mkSquares -> (Bool, MOD_mkSquares);
c = rule_RL_consume_mkSquares;

pc :: MOD_mkSquares -> (Bool, MOD_mkSquares);
pc = p <$> c;

ppc :: MOD_mkSquares -> (Bool, MOD_mkSquares);
ppc = seq [p, p, c];

pcp :: MOD_mkSquares -> (Bool, MOD_mkSquares);
pcp = seq [p, c, p];

-- Return an example state demonstrating produce and consume are not mutually
-- exclusive.
produce_consume_not_me :: Query (Answer (MOD_mkSquares));
produce_consume_not_me = do {
    s <- free;
    assert (fst (p s) && fst (c s));
    query s;
};

-- Test of two rule results are equivalent.
-- This is the Maybe eq, which ignores the state as appropriate.
req :: (Eq s) => (Bool, s) -> (Bool, s) -> Bool;
req (True, a) (True, b) = a == b;
req (False, _) (False, _) = True;
req _ _ = False;

-- Return an example state demonstrating ppc and pcp aren't always equivalent.
ppc_pcp_ne :: Query (Answer (MOD_mkSquares));
ppc_pcp_ne = do {
    s <- free;
    assert (not (req (pcp s) (ppc s)));
    query (s);
};

isEven :: Bit #n -> Bool;
isEven b = (bv_and b 1) == 0;

isOdd :: Bit #n -> Bool;
isOdd b = (bv_and b 1) == 1;

-- Do a model check.
model :: Model (MOD_mkSquares);
model = Model {
  rules = [("p", rule_RL_produce_mkSquares),
           ("c", rule_RL_consume_mkSquares)],
  initial = (\s -> s == ctor_mkSquares),
  target = (\s -> (value (inst_squares s)) == 9)
};

mctest :: Query (Answer (MOD_mkSquares, MOD_mkSquares, [String]));
mctest = check model 10;

main :: Query (Answer (MOD_mkSquares, MOD_mkSquares, [String]));
main = mctest;

}

