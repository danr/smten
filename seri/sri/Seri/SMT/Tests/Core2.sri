
module Seri.SMT.Tests.Core2 where

import Prelude
import Seri.SMT.Symbolic
import Seri.Tests.Test

p :: Bool -> Bool -> Bool -> Bool
p x y z =
    if x && y
        then not z
        else x == (y || z)

qtest :: SMT ()
qtest = do
    test "core.dummy" True

    -- Trivial test. Verifies we can make free booleans and assert things
    -- about them.
    ra <- query $ do
        a <- free
        assert a
        return a
    test "core.trivial" (ra == Satisfiable True)

    -- Verify we can handle functions in let expressions.
    ra2 <- query $
        assert (let f = (\x -> x)
                in f True)
    test "core.finlet" (ra2 == Satisfiable ())

    -- Test NOT
    rb <- query $ do
        b <- free
        assert (not b)
        return b
    test "core.not" (rb == Satisfiable False)

    -- Test OR
    rcd <- query $ do
        c <- free
        d <- free
        assert (c || d)
        assert (not c)
        return (c, d)
    test "core.or" (rcd == Satisfiable (False, True))

    -- Test AND
    ref <- query $ do
        e <- free
        f <- free
        assert (e && f)
        return (e, f)
    test "core.and" (ref == Satisfiable (True, True))

    -- Test EQ
    rgh <- query $ do
        g <- free
        h <- free
        assert (g == h)
        assert (not g)
        return (g, h)
    test "core.eq" (rgh == Satisfiable (False, False))

    -- Test IF
    ri <- query $ do
        i <- free
        assert (if i then False else True)
        return i
    test "core.if" (ri == Satisfiable False)

    -- Test more complex
    rjkl <- query $ do
        j <- free
        k <- free
        l <- free
        assert (p j k l)
        return (j, k, l)
    test "core.complex" $
        case rjkl of
            Satisfiable (jv, kv, lv) -> p jv kv lv
            _ -> False

    -- Test an issue with lambdas that we've had issues with in the past.
    rm <- query $ do
        m <- free
        assert ((if m then (==) True else (==) False) False)
        return m
    test "core.lambda" (rm == Satisfiable False)

    -- We should be able to using Integers, so long as they aren't free, even
    -- if the underlying solver doesn't support them.
    rno <- query $ do
        n <- free
        o <- free
        assert ((if n then 3 else (4 :: Integer)) == (if o then 4 else 5))
        return (n, o)
    test "core.integer" (rno == Satisfiable (False, True))

    -- Same with lists
    rp <- query $ do
        p <- free
        assert (null (if p then [1, 2, 3 :: Integer] else []))
        return p
    test "core.list" (rp == Satisfiable False)

    -- Same with char
    rq <- query $ do
        q <- free
        assert ('a' == (if q then 'a' else 'b'))
        return q
    test "core.char" (rq == Satisfiable True)

    qsubstitute

-- Test that primitives are reapplied after substitution.
qsubstitute :: SMT ()
qsubstitute = do
    r <- query $ do
        a <- free
        assert (not a)
        return (not a)
    test "core.substitute" (r == Satisfiable True)


main :: IO ()
main = do
    runSMT Yices1 (Just "build/test/Core2.yices1.dbg") qtest
    runSMT Yices2 (Just "build/test/Core2.yices2.dbg") qtest
    runSMT STP (Just "build/test/Core2.stp.dbg") qtest
    putStrLn "CORE2 PASSED"

